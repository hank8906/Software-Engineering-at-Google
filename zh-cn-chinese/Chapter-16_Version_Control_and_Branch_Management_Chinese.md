第十六章版本控制和分支管理

’

也許沒有一種軟件工程工具像版本控制工具那樣在整個行業中被廣泛採用。我們很難想象，任何超過幾個人的軟件組織不依靠正式的版本控制系統（）來管理其源代碼和協調工程師之間的活動。

’’“”’

在本章中，我們將瞭解爲什麼版本控制工具的使用在軟件工程中已成爲如此明確的規範，我們將描述版本控制和分支管理的各種可能方法，包括我們如何在整個谷歌範圍內大規模地使用。我們還將研究各種方法的優缺點；儘管我們認爲每個人都應該使用版本控制，但某些版本控制策略和流程可能比其他策略和流程更適合你的組織（或總體而言）。特別是，我們發現由推廣的基於主幹的開發（一個版本庫，沒有開發分支）是一種特別可擴展的策略方法，我們將提供一些建議來解釋爲什麼會這樣。

>“”>>研究協會，在本章初稿和出版之間被谷歌收購，在年度狀況報告和《加速》一書中廣泛發表了這方面的內容。據我們所知，它推廣了基於主幹的開發這一術語。

什麼是版本控制？

“”’’“”“”

是一個跟蹤文件隨時間變化的修訂（版本）的系統。維護一些關於被管理的文件集的元數據，文件和元數據的副本統稱爲版本庫（簡稱）。通過允許多個開發者同時在同一組文件上工作來幫助協調團隊的活動。早期的是通過每次授予一個人編輯文件的權利來實現的這種鎖定方式足以建立順序（一種約定的“更新的”，的一個重要特性）。更高級的系統確保對一次提交的文件集合的更改被視爲單個單元（當邏輯更改涉及多個文件時，原子性）。像（年代流行的）這樣的系統，如果沒有這種提交的原子性，就會出現損壞和丟失更改。確保原子性消除了以前的更改被無意覆蓋的可能性，但需要跟蹤最後同步的版本在提交時，如果提交中的任何文件在本地開發者最後一次同步後被修改過，則提交將被拒絕。特別是在這樣一個變化跟蹤的中，開發者管理着的文件的工作副本因此需要有自己的元數據。根據的設計，這個版本庫的副本可以是一個版本庫本身，也可以包含一個精簡的元數據這樣一個精簡的副本通常是一個客戶端或工作區。

這似乎很複雜：爲什麼需要一個？是什麼讓這種工具成爲爲數不多的軟件開發和軟件工程幾乎通用的工具之一？

’’’

想象一下，在沒有的情況下工作。對於一個（非常）小的分佈式開發人員小組，在一個範圍有限的項目上工作，而不瞭解版本控制，最簡單和最低要求的基礎設施解決方案是隻是來回傳遞項目的副本。這在非同步編輯時效果最好（人們在不同的時區工作，或至少在不同的工作時間）。如果有讓人們不知道哪個版本是最新的時刻，我們馬上就會有一個惱人的問題：追蹤哪個版本是最新的。任何試圖在非網絡環境下進行協作的人都可能會想起來回複製名爲的文件的恐怖。正如我們將看到的那樣，當沒有一個統一的信息來源時，合作就會變得阻力很大，容易出錯。

’’’’’

引入共享存儲需要稍多的基礎設施（獲得對共享存儲的訪問），但提供了一個簡單而顯著的解決方案。在一個共享存儲驅動器中協調工作，在人數足夠少的情況下可能已經足夠了，但仍然需要帶外協作以避免覆蓋彼此的工作。此外，直接在共享存儲中工作意味着任何不能保持構建持續工作的開發任務都會開始阻礙團隊中的每個人如果我在你啓動構建的同時對這個系統的某些部分進行了修改，你的構建就無法工作。很明顯，這並不能很好地擴展。

’’’

在實踐中，缺乏文件鎖和缺乏合併跟蹤將不可避免地導致衝突和工作被覆蓋。這樣一個系統很有可能引入帶外協調，以決定誰在任何給定的文件上工作。如果這種文件鎖定被編碼在軟件中，我們就開始重新發明像（包括其他）這樣的早期版本控制。當你意識到一次授予一個文件的寫入權限過於粗放，而你開始需要行級跟蹤時，我們肯定在重新發明版本控制。似乎不可避免的是，我們將需要一些結構化的機制來管理這些合作。因爲在這個假設中，我們似乎只是在重新發明車輪，我們不妨使用一個現成的工具。

>>>雖然什麼是和什麼不是版本庫的正式概念會因你選擇的而有些變化，術語也會有所不同。

爲什麼版本控制很重要？

“”

雖然現在版本控制幾乎無處不在，但情況並非總是如此。最早的可以追溯到世紀年代（）和年代（）比首次將軟件工程作爲一門獨立學科的時間晚了許多年。在業界有任何正式的版本控制概念之前，團隊就參與了多版本軟件的多人開發。版本控制是爲了應對數字協作的新挑戰而發展起來的。經過幾十年的演變和傳播，版本控制的可靠、一致的使用才演變成今天的規範。那麼，它是如何變得如此重要的呢？鑑於它似乎是一個不言而喻的解決方案，爲什麼會有人抵制的想法呢？

’’

回顧一下，軟件工程是隨着時間的推移而集成的編程；我們在源代碼的即時生產和隨着時間的推移維護該產品的行爲之間（在維度上）進行了區分。這一基本區別在很大程度上解釋了的重要性和對的疑慮：在最基本的層面上，版本控制是工程師管理原始源和時間之間相互作用的主要工具。我們可以將概念化爲一種擴展標準文件系統的方式。文件系統是一個從文件名到內容的映射。擴展了它，提供了從（文件名，時間）到內容的映射，以及跟蹤最後同步點和審計歷史所需的元數據。版本控制把時間的操作的一個明確的部分：在編程任務中是不必要的，在軟件工程任務中是關鍵的。在大多數情況下，還允許對該映射有一個額外的輸入（一個分支名稱），以允許並行映射；因此：

>

“”“”“”

在默認的用法中，該分支輸入將有一個普遍理解的默認值：我們稱之爲“”、“”或“”來表示主分支

’’“”

對持續使用版本控制的（微小的）剩餘疑慮幾乎直接來自於編程和軟件工程的融合我們教編程，我們培訓程序員，我們根據編程問題和技術來面試工作。對於一個新員工來說，即使是在像谷歌這樣的地方，對於由一個以上的人或幾個星期以上的時間來處理的代碼，幾乎沒有經驗，這是完全合理的。鑑於這種經驗和對問題的理解，版本控制似乎是一個陌生的解決方案。版本控制正在解決一個我們的新僱員不一定經歷過的問題：“撤銷”，不是針對單個文件，而是針對整個項目，這增加了很多複雜性，有時並沒有帶來了明顯的好處。

“”“”’“”

在一些軟件團隊中，當管理層將技術人員的工作視爲“軟件開發”（坐下來編寫代碼）而不是“軟件工程”（生成代碼，使其在較長時間內保持工作和有效）時，也會產生同樣的結果。在把編程作爲主要任務的思維模式下，以及對代碼和時間流逝之間的相互作用瞭解甚少的情況下，很容易把返回到以前的版本以撤銷錯誤這樣的描述看作是一種奇怪的、高開銷的奢侈品。

“”“”

除了允許隨着時間的推移單獨存儲和長期引用版本外，版本控制還幫助我們彌合單個開發人員和多個開發人員流程之間的差距。在實踐中，這就是爲什麼版本控制對軟件工程如此關鍵，因爲它允許我們擴大團隊和組織的規模，儘管我們只是不經常使用它作爲一個撤銷按鈕。開發本質上是一個分支和合並的過程，無論是在多個開發人員之間還是在不同時間點的單個開發人員之間進行協調。版本控制系統消除了哪個是最新的？的問題。使用現代的版本控制可以將容易出錯的操作自動化，比如跟蹤哪一組修改已經被應用。版本控制是我們在多個開發者和或多個時間點之間協調的方式。

由於已經完全融入到軟件工程的過程中，甚至連法律和監管實踐也迎頭趕上。允許對每一行代碼的每一次更改進行正式記錄，這對於滿足審計要求越來越必要。當混合使用內部開發和第三方資源時，幫助跟蹤每行代碼的出處和起源。

’

除了隨時間跟蹤源和處理同步分支合併操作的技術和法規方面外，版本控制還會觸發一些行爲上的非技術性更改。提交到版本控制並生成提交日誌的慣例是引發思考的一刻：自上次提交以來，你完成了什麼？源碼是否處於你滿意的狀態？對於許多人來說，與提交、撰寫總結和完成任務相關的內省時刻本身可能具有價值。提交過程的開始是運行檢查表、運行靜態分析（參見第章）、檢查測試覆蓋率、運行測試和動態分析等的最佳時機。

’

與任何流程一樣，版本控制也會帶來一些開銷：必須有人配置和管理你的版本控制系統，並且每個開發人員都必須使用它。但別搞錯了：這些幾乎總是相當低成本的。有趣的是，大多數經驗豐富的軟件工程師會本能地對任何持續一到兩天以上的項目使用版本控制，即使是單個開發人員的項目。這一結果的一致性表明，在價值（包括風險降低）和管理費用方面的權衡必須非常容易。但我們要承認背景的重要性，並鼓勵工程負責人獨立思考。即使在像版本控制這樣的基本問題上，也總是值得考慮其他選擇。

’’

事實上，很難設想任何可以被認爲是現代軟件工程的任務不立即採用。鑑於你瞭解版本控制的價值和需要，你現在可能會問你需要什麼類型的版本控制。

>’“”’>>事實上，我曾多次公開演講，以版本控制的採用爲例，說明軟件工程的規範是如何隨着時間的推移而演變的。根據我的經驗，在世紀年代，版本控制被理解爲一種最佳實踐，但沒有得到普遍遵守。在世紀初，不使用版本控制的專業團體仍然很常見。今天，即使在從事個人項目的大學生中，像這樣的工具的使用似乎也是無處不在的。這種採用率的上升可能是由於在工具中更好的用戶體驗（沒有人願意回到），但經驗和不斷變化的規範的作用也很重要。

集中式與分佈式

“”’

在最簡單的層面上，所有現代都是一樣的：只要你的系統有一個將更改以原子方式提交給一批文件的概念，其他一切都只是不同。你可以用另一個和一堆簡單的腳本構建任何現代的通用語義（而不是工作流）。因此，討論哪些“更好”主要是用戶體驗的問題。核心功能是相同的，不同之處在於用戶體驗、命名、邊緣案例功能和性能。選擇一個就像選擇一個文件系統格式：在一個足夠現代的格式中進行選擇時，差異是相當小的，到目前爲止，更重要的問題是你在該系統中填充的內容以及你使用它的方式。然而，中的主要架構差異可能會使配置、策略和擴展決策變得更容易或更困難，因此重要的是要意識到巨大的架構差異，主要是集中式和分散式之間的決策。

集中式

在集中式的實現中，模型是一個單一的中央存儲庫（可能存儲在你的組織的一些共享計算資源上）。儘管開發者可以在他們的本地工作站上籤出和訪問文件，但與這些文件的版本控制狀態交互的操作需要與中央服務器通信（添加文件、同步、更新現有文件，等等）。任何由開發者提交的代碼都會被提交到中央存儲庫。第一批的實現都是集中式。

’

回溯到世紀年代和年代初，我們看到最早的這些，如，側重於鎖定和防止多個同時編輯。你可以複製版本庫的內容，但如果你想編輯一個文件，你可能需要獲得一個鎖，由強制執行的鎖，以確保只有你在進行編輯。當你完成了一個編輯，你就可以釋放鎖。當任何給定的變化是一個很快的事情，或者在任何給定的時間內很少有超過一個人想要鎖定一個文件時，這種模式工作得很好。像調整配置文件這樣的小的編輯工作是可以的，就像在一個小團隊中工作一樣，這個團隊要麼保持不連貫的工作時間，要麼很少長時間處理重疊的文件。這種簡單化的鎖定在規模上有固有的問題：對幾個人來說，它可以很好地工作，但如果這些鎖中的任何一個被爭奪，就有可能在較大的羣體中崩潰。

’’

作爲對這一規模問題的回應，在年代和世紀初流行的在更高水平上運行。這些更現代化的集中式避免了獨佔鎖定，但會跟蹤你已同步的更改，要求你的編輯基於提交中每個文件的最新版本。通過（主要是）一次操作一批文件並允許多個開發人員同時簽出一個文件來包裝和細化：只要你的基礎版本包含存儲庫中的所有更改，你就可以提交。通過提供真正的提交原子性、版本跟蹤和對不尋常操作（重命名、使用符號鏈接等）的更好跟蹤而進一步發展。集中式版本庫檢出客戶端的模式在以及大多數商業中延續至今。

>’’>>軼事：爲了說明這一點，我尋找了谷歌在我最近的項目中對一個半流行的文件所做的未提交未提交編輯的信息。在撰寫本文時，有項變更尚未完成，其中項來自我的團隊，項來自相關團隊，項來自我從未見過的工程師。這基本上按照預期工作。需要帶外協調的技術系統或策略當然不能擴展到分佈式位置的全天候軟件工程。

分佈式

“”“”

從年中期開始，許多流行的遵循分佈式版本控制系統（）的範式，在和等系統中看到。和更多傳統的集中式（，）之間的主要概念差異在於問題：你可以在哪裏提交？或者說，這些文件的哪些副本算作一個存儲庫？

世界不強制執行中央存儲庫的約束：如果你有存儲庫的副本（克隆、分叉），那麼你就有一個可以提交的存儲庫以及查詢有關修訂歷史等信息所需的所有元數據。標準工作流是克隆一些現有存儲庫，進行一些編輯，在本地提交，然後將一組提交推送到另一個存儲庫，該存儲庫可能是克隆的原始源，也可能不是克隆的原始源。任何關於中心性的概念都純粹是概念性的，是一個策略問題，而不是技術或底層協議的根本。

’“”“”’

模型允許更好的離線操作和協作，而無需預先聲明某個特定存儲庫是信息源。一個存儲庫不必“領先”或“落後”，因爲更改不會固有地投射到線性時間線中。然而，考慮到通用性，集中式和模型在很大程度上是可互換的：集中式通過技術提供了一個明確定義的中央存儲庫，而大多數生態系統將項目的中央存儲庫定義爲一個策略問題。也就是說，大多數項目都是圍繞一個信息源的概念（例如上的特定存儲庫）構建的。模型傾向於假設一個更分佈式的用例，並且在開源世界中得到了特別強烈的採用。

’

一般來說，今天占主導地位的源碼控制系統是，它實現了。當有疑問時，使用它做別人做的事是有價值的。如果你的用例預期不尋常，請收集一些數據並評估權衡。

’’

谷歌與有着複雜的關係：我們的主要資源庫是基於一個（巨大的）自定義的內部集中式。我們定期嘗試整合更多標準的外部選項，並與我們的工程師（尤其是）所期望的外部開發的工作流程相匹配。不幸的是，由於代碼庫和用戶羣的巨大規模，以及海勒姆定律的影響，這些向這樣的通用工具發展的嘗試受到了阻礙，更不用說將我們束縛在一個特定的和的界面上了。這也許並不奇怪：大多數現有的工具在面對萬名工程師和數千萬的提交時都不能很好地擴展。模型，通常（但不總是）包括歷史和元數據的傳輸，需要大量數據來加速存儲庫的運行。

在我們的工作流程中，代碼庫的中心化和雲存儲似乎對擴展至關重要。模型是圍繞下載整個代碼庫並在本地訪問它的思想構建的。在實踐中，隨着時間的推移和組織規模的擴大，任何給定的開發人員都會在相對較小比例的文件庫中進行操作，而且這些文件的版本也只佔一小部分。隨着我們的增長（在文件數和工程師數方面），這種傳輸幾乎完全變成了浪費。大多數文件在構建時只需要本地局部文件，但分佈式（和可複製的）構建系統似乎也能更好地擴展該任務（參見第章）。

>>>開發者調查結果，年。>>>>單調增加的版本號，而不是提交哈希值，是特別麻煩的。許多系統和腳本已經在谷歌開發者生態系統中成長起來，它們假定提交的數字順序與時間順序相同消除這些隱藏的依賴關係是很困難的。>>>>就這一點而言，截至論文發表時，倉庫本身有大約的數據和元數據，不包括髮布分支。將其直接裝入開發者的工作站將是挑戰。

信息源

“”

集中式（、、等）將信息源的概念融入到系統的設計中：最近提交到主幹的就是當前的版本。當一個開發者去檢查項目時，默認情況下，他們將看到的是主幹版本。當你的修改被重新提交到該版本上時，你的修改就完成了。

’’

然而，與集中式不同，在系統中，並不存在哪個分佈式版本庫的副本是單信息源的固有概念。理論上，在沒有集中化或協調的情況下，提交標籤和的傳遞是可能的，允許不同的開發分支不受檢查地傳播，從而有可能在概念上回到的世界。正因爲如此，比集中式需要更明確的策略和規範。

“”

使用的管理良好的項目宣佈一個特定的分支在一個特定的存儲庫中是信息源，從而避免了更多混亂的可能性。在實踐中，我們看到或等託管解決方案的普及用戶可以克隆和分叉一個項目的倉庫，但仍有一個單一的主倉庫：當事情出現在該倉庫的主幹分支時，就已經完成了。

’’’

即使在的世界裏，集中化和信息源已經悄悄地回到了人們的使用中，這並不是一個偶然。爲了說明信息源這個概念有多重要，讓我們想象一下，當我們沒有明確的信息源時會發生什麼。

情景：沒有明確的信息源

想象一下，你的團隊堅持的理念，足以避免將特定的分支版本庫定義爲最終的信息源。

’’’’’

在某些方面，這讓人想起的模式當你從隊友的版本庫中提取後，並不一定清楚哪些改動是存在的，哪些是不存在的。在某些方面，它比這更好，因爲模型在更細的粒度上跟蹤單個補丁的合併，而不是那些臨時的命名方案，但知道哪些變化被納入，和每個工程師確保他們已經表示了所有過去相關的更改，這兩者之間存在差異。。

考慮一下如何確保一個發佈版本包括每個開發人員在過去幾周內開發的所有功能。有什麼（非集中的、可擴展的）機制可以做到這一點？我們能不能設計出從根本上比讓每個人簽字更好的策略？是否有任何隨着團隊規模的擴大只需要亞線性的人力努力？隨着團隊中開發人員數量的增加，這是否會繼續發揮作用？就我們所見：可能不會。如果沒有一個核心的信息源，就會有人記下哪些功能有可能被納入下一個版本的清單。最終，這種記賬方式正在重現擁有一個集中式信息源的模式。

進一步想象：當一個新的開發人員加入團隊時，他們從哪裏得到一個最新的、已知的好的代碼副本？

’’

實現了很多出色的工作流程和有趣的使用模式。但如果你關心的是找到一個系統，隨着團隊的成長，需要亞線性的人力來管理，那麼將一個存儲庫（和一個分支）實際定義爲最終的信息源是相當重要的。

’

信息源具有某種相對性。也就是說，對於一個特定的項目，信息源對於不同的組織可能是不同的。這一點很重要：谷歌或的工程師對內核補丁有不同的信息源是合理的，這與（內核維護者）自己的信息源還是不同的。當組織和他們的信息源是分層的（對組織外的人來說是不可見的），就能很好地工作這也許是模型最實際的作用。一個的工程師可以提交到本地信息源倉庫，並且可以定期從那裏向上遊推送變化，而對什麼是信息源有完全不同的概念。只要沒有選擇或不確定一個變化應該被推到哪裏，我們就可以避免模型中的一大類混亂的擴展問題。

’“”’’’

在所有這些想法中，我們爲主幹分支賦予了特殊的意義。但當然，中的主幹只是技術默認，一個組織可以在此基礎上選擇不同的策略。也許默認的分支已經被放棄了，所有的工作實際上都發生在某個自定義的開發分支上除了需要在更多操作中提供分支名稱之外，這種方法沒有任何內在的缺陷；它只是非標準的。在討論版本控制時，有一個（經常不說的）事實：對於任何特定的組織來說，技術只是其中的一部分；幾乎總是有同等數量的策略和使用約定在上面。

版本控制中沒有一個主題比關於如何使用和管理分支的討論更具策略和約定。我們將在下一節更詳細地介紹分支管理。

版本控制與依賴管理

’’’

關於版本控制策略和依賴管理的討論在概念上有很多相似之處（見第章）。差異主要體現在兩種形式上。策略主要是關於你如何管理你自己的代碼，而且通常是更細的粒度。依賴管理更具挑戰性，因爲我們主要關注由其他組織管理和控制的項目，顆粒度更高，這些情況意味着你沒有完美的控制。我們將在本書後面討論更多的這些高級問題。

分支管理

“”

能夠在版本控制中跟蹤不同的修訂版，爲如何管理這些不同的版本提供了各種不同的方法。總的來說，這些不同的方法屬於分支管理，與單一的主幹形成對比。

正在進行的工作類似於一個分支

’’

組織對分支機構管理策略的任何討論都應該至少承認組織中正在進行的每一項工作都相當於一個分支。這一點在中更爲明顯，因爲在中，開發者更有可能在推送回上游信息源之前進行大量本地暫存提交。集中式仍然如此：未提交的本地更改在概念上與分支上提交的更改沒有區別，只是可能更難發現和區分。一些集中式系統甚至明確了這一點。例如，當使用時，每個更改都會有兩個修訂號：一個表示創建更改的隱含分支點，另一個表示重新提交更改的位置，如圖所示。用戶可以查詢查看誰對給定文件有未完成的更改，檢查其他用戶未提交更改中的未決更改，等等。

圖中的兩個修訂號

“”“”’

這個未提交的工作類似於分支的想法在思考重構任務時特別重要。想象一下，一個開發者被告知，將重命名爲。根據組織的分支管理策略和理解，什麼是分支，以及哪個分支重要，這可能有幾種解釋：

在信息源版本庫的主幹分支上重命名在信息源版本庫中的所有分支上重命名在信息源版本庫的所有分支上重命名，並找到所有對引用的文件有未完成修改的開發者。

“”“”’

如果我們猜測，試圖支持“到處重命名，即使在未完成的更改中”用例是爲什麼商業集中式傾向於跟蹤“哪些工程師打開此文件進行編輯？”（我們不認爲這是執行重構任務的可擴展方式，但我們理解這個觀點。）

開發分支

“’”“”

在沒有一致的單元測試的時代（見第章），當任何給定的更改的引入都有很大的風險會使系統中其他地方的功能回滾時，特別對待是有意義的。我們不會向主幹提交，你的技術負責人可能會說，在新的變更通過一輪測試之前，我們不會合並搭配主幹。我們的團隊使用特定於功能的開發分支。

“”“”“”

開發分支（通常是）是介於這個已經完成但未提交和這個是新工作的基礎之間的中間點。這些試圖解決的問題（產品的不穩定性）是一個合理的問題，但我們發現通過更廣泛地使用測試、持續集成（）（見第章）和徹底的代碼審查等質量執行實踐可以更好地解決這個問題。

’

我們認爲，大量使用開發分支作爲產品穩定性手段的版本控制策略本身上是錯誤的。同一組提交最終將合併到主幹中。小的合併比大的合併容易。由編寫這些更改的工程師進行的合併比把不相關的修改分批合併要容易（如果團隊共享開發分支，最終會發生這種情況）。如果對合並進行的預提交測試發現了任何新問題，同樣的論點也適用：如果只有一名工程師參與，則更容易確定誰的更改導致了迴歸。合併一個大型開發分支意味着在該測試運行中會發生更多的更改，從而使故障更難隔離。處理和根除問題是困難的，而修復問題就更難了。

除了在合併單個分支時缺乏專業知識和固有問題之外，依賴開發分支時還存在重大的擴展風險。對於軟件組織來說，這是一種非常常見的生產力損失。當有多個分支長期獨立開發時，協調合並操作會比基於主幹的開發成本更高（可能更高）。

我們是如何沉迷於開發分支的？

’“”“”“”“’”’“”’

很容易看出組織是如何落入這個陷阱的：他們看到，“合併這個長期存在的開發分支會降低穩定性”，並得出結論，“分支合併是有風險的。”而不是通過“更好的測試”和“不要使用基於分支的開發策略”來解決這個問題，只是專注於減緩和協調症狀：分支合併。團隊開始在其他正在運行的分支的基礎上開發新的分支。在一個長期存在的開發分支上工作的團隊可能會也可能不會定期讓該分支與主開發分支同步。隨着組織規模的擴大，開發分支的數量也在增加，在協調該分支合併策略上的努力也就越多。越來越多的精力投入到分支合併的協調上這是一項本質上無法擴展的任務。一些不走運的工程師成爲構建主管合併協調人內容管理工程師，專注於充當單點協調人，以合併組織中所有不同的分支。定期安排的會議試圖確保組織“制定了本週的合併策略”。未被選擇合併的團隊通常需要在每次大型合併後重新同步和測試。

“”“”

所有這些合併和重新測試的努力都是純粹的開銷。替代方案需要一個不同的範式：基於主幹的開發，嚴重依賴測試和，保持綠色構建，並在運行時禁用不完整未經測試的功能。每個人都有責任同步到主幹和提交；沒有合併策略會議，沒有大型高成本的合併。而且，沒有關於應該使用哪個版本的庫的激烈討論只能有一個。必須有一個單一的信息源。最終，一個版本將使用一個單一的修訂版：縮小到一個單信息源，這只是確定哪些是和哪些沒有被包括在內的“左移”方法。

>“”>>最近的非正式推特民意調查顯示，大約的軟件工程師參加了“定期”的合併策略會議。

發佈分支

如果某個產品的發佈間隔（或發佈生命週期）超過幾個小時，那麼創建一個發佈分支來表示進入產品發佈構建的確切代碼可能是明智的。如果在該產品的實際發佈和下一個發佈週期之間發現了任何關鍵缺陷，那麼可以從主幹到你的發佈分支進行修復（最小的、有針對性的合併）。

’’

與開發分支相比，發佈分支通常是良性的：麻煩的不是分支的技術，而是用法。開發分支和發佈分支的主要區別在於預期的最終狀態：開發分支預期會合併到主幹上，甚至可能會被另一個團隊進一步分支。而發佈分支預計最終會被放棄。

’’

在谷歌的研究和評估組織（）所確定的最高效的技術組織中，發佈分支實際上是不存在的。那些已經實現了持續部署（）的組織每天多次從主幹發佈的能力很可能傾向於跳過發佈分支：只需添加修復和重新部署就更容易了。因此，挑選（）和分支似乎是不必要的開銷。顯然，這更適用於以數字方式部署的組織（如網絡服務和應用程序），而不是那些向客戶推送任何形式的有形發佈的組織；通常，準確地瞭解向客戶推出的產品是很有價值的。

“”“”

同樣的研究也表明，基於主幹的開發、沒有長期的開發分支和良好的技術成果之間有很強的正相關關係。這兩個觀點的基本思路似乎都很清楚：分支拖累了生產力。在許多情況下，我們認爲複雜的分支和合並策略是一種可感知的安全支柱試圖保持主幹的穩定。正如我們在本書中所看到的，還有其他的方法來實現這一結果。

谷歌的版本控制

在谷歌，我們的絕大多數源代碼都在一個由大約名工程師共享的存儲庫（）中管理。除了像和這樣的大型開源項目，幾乎所有屬於谷歌的項目都在這裏。這包括面向公衆的產品，如搜索、、我們的廣告產品、我們的谷歌雲平臺產品，以及支持和開發所有這些產品所需的內部基礎設施。

’’’

我們依靠內部開發的集中式，名爲，該是爲在我們的生產環境中作爲分佈式微服務運行而構建的。這使我們能夠使用谷歌標準的存儲、通信和計算即服務技術，提供一個全球可用的，存儲超過的內容和元數據。然後，單版本庫每天由成千上萬的工程師同時進行編輯和提交。在人類和利用版本控制（或改進簽入的內容）的人工流程和半自動化流程之間，我們每個工作日會定期處理到次提交到版本庫。二進制構件是相當常見的，因爲並不需要完整地傳輸到版本庫，因此二進制構件的成本並不高。由於從最初的概念就專注於谷歌規模，這個生態系統的操作在人羣規模上仍然是低成本的：在主幹上創建一個新的客戶端，添加一個文件，並向提交一個（未經審查的）更改，總共可能需要秒。這種低延遲的互動和良好的理解設計的擴展簡化了很多開發者的體驗。

“”

由於是一個內部產品，我們能夠定製它並實施我們選擇的任何源代碼控制策略。例如，我們在單版本庫中有一個細粒度所有權的概念：在文件層次結構的每一級，我們都可以找到文件，其中列出了允許批准該版本庫的子樹中的提交的工程師的用戶名（除了在樹中更高層次列出的）。在具有多個版本庫的環境中，這可能是通過單獨的版本庫和文件系統權限執行控制提交訪問，或者通過的提交鉤子（提交時觸發的動作）進行單獨的權限檢查來實現。通過控制，我們可以使所有權和批准的概念更加明確，並在嘗試提交操作時由強制執行。這個模型也很靈活：所有權只是一個文本文件，並不與存儲庫的物理分離相聯繫，所以在團隊轉移或組織結構調整的情況下，更新它是很容易的。

一個版本

’’’“”“”“”“”

單憑令人難以置信的擴展能力，是無法實現我們所依賴的那種協作的。正如我們之前所說：版本控制也是關於策略的。除了我們的之外，谷歌版本控制策略的一個關鍵特徵就是我們所說的一個版本。這擴展了我們前面提到的單信息源的概念確保開發者知道哪個分支和版本庫是他們的信息源到類似於對於我們版本庫中的每個依賴，必須只有一個版本的依賴可以選擇。對於第三方軟件包，這意味着在穩定狀態下，該軟件包只能有一個版本被檢入我們的倉庫。對於內部軟件包，這意味着沒有重新打包重命名的分支：在技術上必須是安全的，無需特別努力就可以將原始和分支混合到同一個項目中。這對我們的生態系統來說是一個強大的功能：很少有包有類似如果你包括這個軟件包（），你就不能包括其他軟件包（）的限制。

’

將單個副本放在單個版本庫中的單個分支上作爲信息源的概念是直觀的，但在應用中也有一些微妙的深度。讓我們研究一下這樣的場景：我們有一個單版本庫（因此可以說已經履行了關於單信息源的法律條文），但允許我們的庫的分支在主幹上傳播。

>>>例如，在升級操作期間，可能簽入了兩個版本，但如果開發人員正在現有軟件包上添加新的依賴，則應該沒有選擇依賴哪個版本。>>>>也就是說，我們在很多情況下都會失敗，因爲外部軟件包有時會在它們的源版本中捆綁有它們自己的依賴性的釘子副本。你可以在第章中閱讀更多關於這一切是如何出錯的。

場景：多個可用版本

“”

想象一下以下情況：一些團隊發現了公共基礎組件代碼中的一個（在我們的例子中，是或之類的）。該團隊決定不在原地修復它，而是分支該基礎組件，並對其進行調整，以解決該錯誤而不重命名庫或符號。它通知他們附近的其他團隊：嘿，我們這裏有一個改進的版本：請查看。其他一些團隊建立的庫也依賴於這個新的分支。

’’’“”“”“”“”’’’

正如我們將在第章中看到的，我們現在處於危險的境地。如果代碼庫中的任何項目同時依賴的原始版本和分支版本，在最好的情況下，構建將失敗。在最壞的情況下，我們將受到難以理解的運行時錯誤的影響，這些錯誤源於同一個庫的兩個不匹配的版本的鏈接。“”有效地爲代碼庫添加了一個着色分區屬性：任何給定目標的可傳遞依賴項集必須只包含該庫的一個副本。從“原始味道”的代碼庫添加到“新分支”分區的任何鏈接都可能會破壞事物。這意味着到最後，像添加一個新的依賴這樣簡單的操作，可能需要運行整個代碼庫的所有測試，以確保我們沒有違反這些分區的要求。這很昂貴，很不幸，而且不能很好地擴展。

’

在某些情況下，我們也許可以通過黑客技術將一些東西拼湊在一起，使產生的可執行文件能夠正常運行。例如，有一個相對標準的做法，叫做，它調整了庫的內部依賴的名稱，以便從應用程序的其他部分隱藏這些依賴關係。當處理函數時，這在技術上是合理的，即使它在理論上有點像黑客。當處理可以從一個包傳遞到另一個包的類型時，着色解決方案在理論上和實踐中都不起作用。據我們所知，任何允許一個庫的多個孤立版本在同一個二進制中運作的技術伎倆都有這個限制：這種方法對函數來說是可行的，但對於着色類型來說，沒有好的（有效的）解決方案任何提供詞彙類型（或任何更高級別的構造）的庫的多個版本都會失敗。着色和相關的方法是對基本問題的修補：同一依賴的多個版本是需要的。我們將在第章中討論如何在一般情況下儘量減少這種情況。

’’

任何允許在同一代碼庫中使用多個版本的策略系統都可能會出現這些代價高昂的不兼容。你有可能暫時逃過一劫（我們當然有一些小的違反這一策略的行爲），但一般來說，任何多版本的情況都有導致大問題的非常現實的可能性。

“”“一個版本”規則

考慮到這個例子，在單信息源模型的基礎上，我們希望能夠充分理解這一看似簡單的源代碼控制和分支管理規則的深度：

“”決不能讓開發人員選擇我應該依賴這個組件的哪個版本？

“”“”

俗話說，這就變成了類似於一個版本規則的東西。在實踐中，一個版本並不是硬性規定，但在添加新依賴項時限制可以選擇的版本這一措辭傳達了一種非常有力的理解。

’“”

對於個人開發者來說，缺乏選擇似乎是一個大障礙。然而，我們一再看到，對於一個組織來說，它是高效擴展的一個關鍵組成部分。一致性在一個組織的各個層面都有深遠的意義。從一個角度來看，這是討論一致性和確保利用一致瓶頸的能力的直接副作用。

>>>例如，如果有定期更新的外部第三方庫，更新該庫並在一次原子變化中更新對它的所有使用可能是不可行的。因此，通常有必要添加該庫的新版本，防止新用戶添加對舊版本的依賴，並逐步將使用從舊版本切換到新版本。

幾乎沒有長期存在的分支

“”

在我們的一個版本規則中隱含着幾個更深層次的想法和策略；其中最重要的是：開發分支應該是最小的，或者最多隻能是很短的時間。這來自於過去年裏發表的大量工作，從敏捷過程到基於主幹的開發的研究成果，甚至鳳凰計劃關於減少進行中的工作的教訓。當我們把待完成的工作看作是類似於開發分支的想法時，這就進一步強化了工作應該針對主幹，定期提交，以小的增量完成。

’

作爲一個反例：在一個嚴重依賴長期存在的開發分支的開發社區，不難想象選擇的場景又悄然而至。

“”’“”’

想象一下這樣的場景：一些基礎組件團隊正在開發一個新的，比老的更好。興奮之情油然而生。其他新開始的項目問：我們可以依賴你的新嗎？顯然，如果你在代碼庫的可見性策略上進行了投資，這種情況是可以處理的，但當新的被允許，深層次的問題就會發生但只存在於並行分支中。記住：新的開發在添加依賴關係時不能有選擇。那個新的應該被提交到主幹，在它準備好之前被禁止在運行時使用，並且如果可能的話，通過可見性來隱藏其他開發者，或者兩個選項應該被設計成它們可以共存，被鏈接到同一個程序中。

’

有趣的是，已經有證據表明這在行業中是很重要的。在《加速》和最近的《狀況》報告中，指出，基於主幹的開發和高績效的軟件組織之間存在着可預測關係。谷歌並不是唯一發現這一點的組織當這些策略演變時，我們也不一定有預期的結果只是看起來沒有別的辦法了。的結果當然與我們的經驗相符。

我們的大規模變更（；見第章）的策略和工具給基於主幹的開發的重要性增加了砝碼：當修改所有簽入主幹分支的內容時，適用於整個代碼庫的廣泛淺層變更已經是一項巨大的（通常是乏味的）工作。如果在同一時間有數量不限的額外開發分支需要被重構，那麼對於執行這些類型的修改來說，將是一個非常大的負擔，因爲要找到一組不斷擴大的隱藏分支。在模型中，甚至可能無法識別所有這些分支。

當然，我們的經驗並不是萬能的。你可能會發現自己處於不尋常的情況下，需要更長的開發分支與主幹並行（並定期合併）。

“”’’“”

這些場景應該是罕見的，並且應該理解爲代價高昂。在谷歌單版本庫的大約個團隊中，只有少數團隊有這樣一個開發分支。這些場景的存在通常有一個非常具體（非常不尋常）的原因。大多數原因歸結爲“隨着時間的推移，我們對兼容性有着苛刻的要求。”通常，這是一個確保跨版本的靜態數據的兼容性的問題：某些文件格式的讀寫器需要隨着時間的推移對該格式達成一致意見，即使讀寫器實現被修改。其他時候，長期的開發分支可能來自於對兼容性的承諾當一個版本還不夠時，我們需要承諾舊版本的微服務客戶端仍能與新版本的服務器兼容（反之亦然）。這可能是一個非常具有挑戰性的要求，對於一個積極發展的，你不應該輕易承諾，而且你應該謹慎對待，以確保這段時間不會意外地開始增長。任何形式的跨時間的依賴都比時間不變的代碼要昂貴和複雜得多。在內部，谷歌生產服務相對來說很少做出這種形式的承諾。我們也從我們的構建範圍所施加的潛在版本偏差上限中獲益匪淺：生產中的每項工作最多每六個月就需要重建和重新部署。通常要比這頻繁得多）。

’

我們確信還有其他情況可能需要長期的開發分支。只需確保它們很少。如果你採用了本書所討論的其他工具和實踐，很多人都會傾向於對長期的開發分支施加壓力。自動化和工具在主幹分支上運行良好，而在開發分支上則失敗（或花費更多精力），這有助於鼓勵開發人員保持更新。

>>、和，《鳳凰城項目》（波特蘭：革命出版社，年）。>>’>很難準確統計，但這樣的隊伍幾乎肯定少於支。>>>雲接口是另一回事。

發佈分支呢？

’’’’“”’’

許多谷歌團隊使用發佈分支，但選擇的版本有限。如果你打算每月發佈一個版本，並繼續爲下一個版本工作，那麼創建一個發佈分支是完全合理的。同樣，如果你打算將設備交付給客戶，準確地知道什麼版本“在當前”是很有價值的。謹慎和理智，儘量減少偷樑換柱的行爲，並且不要計劃與主幹分支重新合併。鑑於很少有團隊達到承諾的快速發佈節奏，我們的各個團隊對發佈分支有各種各樣的策略（見第章）這樣就不需要或不需要發佈分支。一般來說，根據我們的經驗，發佈分支不會導致任何廣泛的成本。或者說，至少在的額外固有成本之外，沒有明顯的成本。

單版本庫（單庫）

’’’’

年，我們發表了一篇關於的單版本庫（方法的論文（引用率很高，討論很多）。方法有一些固有的好處，其中最主要的是遵守一個版本是微不足道的：通常違反一個版本比做正確的事情更難。沒有過程來決定任何東西的哪個版本是官方的，也沒有發現哪個版本庫是重要的。構建工具來了解構建的狀態（見第章）也不需要發現哪裏有重要的軟件庫。一致性有助於擴大引入新工具和優化的影響。總的來說，工程師們可以看到其他人在做什麼，並利用這些來告知他們自己在代碼和系統設計中的選擇。這些都是非常好的事情。

“”

考慮到所有這些，以及我們對單一版本規則優點的信念，我們有理由問，單版本庫是否是唯一正確的方法。相比之下，開源社區似乎可以用多版本的方法來工作，而這種方法是建立在看似無限多的不協調和不同步的項目庫之上的。

’’’

簡而言之：不，我們不認爲我們所描述的單版本庫方法對每個人都是完美答案。持續文件系統格式和之間的並行，很容易想象在使用個驅動器提供一個非常大的邏輯文件系統還是個單獨訪問的小文件系統之間做出決定。在文件系統的世界裏，兩者都有優點和缺點。在評估文件系統的選擇時，技術上的問題包括中斷恢復能力、大小限制、性能特點等等。可用性問題可能會更多地集中在跨文件系統邊界引用文件、添加符號鏈接和同步文件的能力上。

’

一組非常類似的問題決定了是選擇單版本庫（還是選擇更細粒度的版本庫的集合。如何存儲你的源代碼（或存儲你的文件）的具體決定是很容易爭論的，在某些情況下，你的組織和你的工作流程的特殊性會比其他的更重要。這些都是你需要自己做出的決定。

’

重要的不是我們是否關注單版本庫；而是最大限度地堅持一個版本的原則：開發人員在向組織中已經使用的某個庫添加依賴時，不能有選擇。違反一個版本原則的選擇會導致合併策略的討論、鑽石依賴、工作損失和工作消耗。

包括和構建系統在內的軟件工程工具越來越多地提供了在細粒度版本庫和單版本庫之間巧妙融合的機制，以提供類似於單版本庫的體驗一種約定的提交順序和對依賴關係圖的理解。子模塊、帶有外部依賴關係的和子項目都允許現代開發者合成一些弱的近似於單版本庫的行爲，而沒有單版本庫的成本和弊端。例如，細粒度的版本庫在規模上更容易處理（在幾百萬次提交後經常出現性能問題，而且當倉庫包括大型二進制構件時，克隆速度往往很慢）和存儲（元數據會增加，特別是如果你的版本控制系統中有二進制構件）。聯合虛擬單版本庫（）風格的細粒度版本庫可以更容易地隔離實驗性或最高機密的項目，同時同時仍保留一個版本並允許訪問通用工具。

換言之：如果你組織中的每個項目都有相同的保密、法律、隱私和安全要求，真正的單版本庫是一個不錯的選擇。否則，以單版本庫的功能爲目標，但允許自己以不同的方式靈活實施該體驗。如果你可以用不相干的軟件庫來管理，並且堅持一個版本，或者你的工作量都是不相干的，足以允許真正的獨立軟件庫，那就太好了。否則，以某種方式合成類似於的東西可能代表了兩個世界的最佳狀態。

’

畢竟，你對文件系統格式的選擇與你向其寫入的內容相比，真的並不重要。

>“”>>和，爲什麼谷歌將數十億行代碼存儲在一個庫中，《通訊》，（）：。>>’’>>我們認爲我們還沒有看到任何系統能特別順利地做到這一點，但版本庫間的依賴關係虛擬單庫的想法顯然是在空想中。>>’>>或者你有意願和能力來定製你的並且在你的代碼庫組織的生命週期內保持這種定製。然後，也許不要把它作爲一個選項，那是一個很大的開銷。

版本控制的未來

’’’

谷歌並不是唯一一個公開討論單版本庫方法的好處的組織。微軟、、和也公開提到他們對這種方法的依賴。已經廣泛地發表了關於它的文章。很可能所有這些成功的、長期存在的公司都被誤導了，或者至少他們的情況差異很大，不適用於一般較小的組織。雖然這是可能的，但我們認爲不太可能。

大多數反對單版本庫的論點都集中在擁有一個大型版本庫的技術限制上。如果從上游克隆一個版本庫又快又便宜，開發者就更有可能保持小規模和隔離的更改（避免提交到錯誤的工作分支）。如果克隆一個版本庫（或做一些其他常見的操作）需要浪費開發人員幾個小時的時間，你很容易理解爲什麼一個組織會避開對這種大型版本庫操作的依賴。我們很幸運地避免了這個陷阱，因爲我們專注於提供一個可以大規模擴展的。

’“”

回顧過去幾年對的重大改進，顯然有很多工作是爲了支持更大的倉庫：淺複製，稀疏分支，更好的優化，等等。我們希望這種情況能繼續下去，而但我們需要保持倉庫的小型化的重要性則會降低。

’’

反對單版本庫的另一個主要論點是，它不符合開源軟件（）世界中的開發方式。雖然這是事實，但開放源碼軟件世界中的許多做法（正確地）來自於對自由的優先考慮，缺乏協調，以及缺乏計算資源。在開放源碼軟件世界中，獨立的項目實際上是獨立的組織，碰巧可以看到彼此的代碼。在一個組織的邊界內，我們可以做出更多的假設：我們可以假設計算資源的可用性，我們可以假設協調，我們可以假設有一定程度的集中權限。

對於單版本庫的方法，一個不太常見但也許更合理的擔憂是，隨着你的組織規模的擴大，越來越不可能每段代碼都受到完全相同的法律、合規、監管、保密和隱私要求的約束。多版本庫方法的一個原生優勢是，獨立的版本庫顯然能夠擁有不同的授權開發者、可見性、權限等集合。集成這個功能到一個單庫中是可以做到的，但意味着在定製和維護方面有一些持續的承載成本。

“”“”

與此同時，業界似乎在一次又一次地發明輕量級的庫間鏈接。有時，這是在（子模塊）或構建系統中。只要版本庫的集合對什麼是主幹、哪個變化先發生有一致的理解，並有描述依賴關係的機制，我們就可以很容易地想象把不同的物理版本庫的集合縫合到一個更大的中。儘管爲我們做得很好，但投資於一個高度擴展的和工具來管理它，並依靠現成的定製來滿足每個版本庫的策略要求，可能是一個更好的投資。

一旦有人在開放源碼軟件社區建立了足夠大的兼容和相互依賴的項目，併發布了這些軟件包的視圖，我們懷疑開放源碼軟件開發者的做法將開始改變。我們在能合成虛擬單一版本庫的工具中，以及在（例如）大型發行版發現和發佈數千個軟件包的相互兼容的修訂版所做的工作中看到了這一跡象。有了單元測試、，以及對其中一個修訂版的新提交的自動版本升級，使軟件包所有者能夠爲他們的軟件包更新主幹（當然是以不破壞的方式），我們認爲這種模式將在開源世界中流行起來。畢竟，這只是一個效率問題：一個（虛擬的）單一版本的方法與一個版本的規則，將軟件開發的複雜性減少了一整個（困難的）層面：時間。

’

我們預計在未來到年內，版本控制和依賴管理將朝着這個方向發展。將專注於允許大型版本庫，並有更好的性能擴展，但也通過提供更好的機制來消除對大版本庫的需求，使它們跨越項目和組織的界限。其中一個，也許是現有的軟件包管理小組或發行商，將促成一個事實上的標準虛擬單一版本庫。依靠單一版本庫中的實用程序，可以方便地訪問作爲一個單元的兼容的依賴關係。我們將更普遍地認識到，版本號是時間戳，允許版本偏差增加了一個維度的複雜性（時間），這需要花費很多，而且我們可以學習如何避免。它從邏輯上類似於單一版本庫的東西開始。

總結

版本控制系統是技術帶來的協作挑戰和機遇的自然延伸，尤其是共享計算資源和計算機網絡。它們在歷史上與我們當時理解的軟件工程規範同步發展。

早期的系統提供了簡單的文件細粒度鎖功能。隨着典型的軟件工程項目和團隊規模的擴大，這種方式的擴展問題變得很明顯，我們對版本控制的理解也隨着這些挑戰而改變。然後，隨着開發越來越多地轉向具有分佈式貢獻者的開放源碼軟件模型，變得更加分散。我們期待着技術的轉變，即假設網絡的持續可用性，更加關注雲存儲和雲構建，以避免傳輸不必要的文件和工件。這對於大型、長週期的軟件工程項目來說越來越關鍵，即使這意味着與簡單的單設備單機器編程項目相比，方法上的改變。這種向雲計算的轉變將使方法中出現的內容具體化：即使我們允許分佈式開發，也必須集中認識到某些東西是信息源。

’

目前的去中心化是該技術對行業（尤其是開源社區）需求的合理反應。然而，的配置需要嚴格控制，並與對你的組織有意義的分支管理策略結合起來。它還常常會引入意想不到的擴展問題：完美仿真的離線操作需要更多的本地數據。如果不控制分支自由生成的潛在複雜性，就會導致開發人員和該代碼的部署之間可能會出現無限開銷。然而，複雜的技術並不需要以複雜的方式來使用：正如我們在單一版本庫和基於主幹的開發模式中看到的那樣，保持分支策略的簡單通常會帶來更好的工程結果。

’

選擇帶來了成本。我們高度贊同這裏提出的單一版本規則：組織內的開發者不能選擇提交到哪裏，或者選擇依賴現有組件的哪個版本。據我們所知，很少有策略能對組織產生如此大的影響：儘管這對個別開發者來說可能很煩人，但從總體上看，最終結果要好得多。

內容提要

“”’“”’’’“”“”“”

對任何大於“只有一名開發人員且永遠不會更新的玩具項目”的軟件開發項目都要使用版本控制。當存在我應該依賴哪個版本的選擇時，就會存在內在的擴展問題。單一版本規則對組織效率的重要性出人意料。刪除提交地點或依賴內容的選擇可能會導致顯著的簡化。在某些語言中，你可能會花一些精力來躲避這個問題，比如着色、單獨編譯、鏈接器隱藏等等技術方法。使這些方法正常工作的工作完全是徒勞的你的軟件工程師並沒有生產任何東西，他們只是在解決技術債務。以前的研究（）表明，基於幹線的開發是高績效開發組織的一個預測因素。長週期的開發分支不是一個好的默認計劃。使用任何對你有意義的版本控制體系。如果你的組織想優先考慮爲不同的項目建立獨立的倉庫，那麼取消存儲庫間的依賴關係“基於頭部”“基於主幹”可能仍然是明智的越來越多的和構建系統設施允許您擁有小型、細粒度的存儲庫以及整個組織一致的“虛擬”頭主幹概念。