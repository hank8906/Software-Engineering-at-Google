第二十五章計算即服務

’

“”

在完成了編寫代碼的艱苦工作之後，你需要一些硬件來運行它。因此，你可以購買或租用這些硬件。本質上，這就是“計算即服務”（，），其中“計算”是實際運行程序所需的計算能力的簡寫。

“”“”“”’’“”“”

本章講述的是這個簡單的概念如何爲我提供硬件如何組成一個系統，隨着你的組織的發展和壯大而生存和擴展。本章有點長，因爲主題很複雜，分爲四個部分：

第頁的馴服計算環境涵蓋了谷歌是如何得出這個問題的解決方案的，並解釋了的一些關鍵概念。第頁的爲託管計算編寫軟件展示了託管計算解決方案如何影響工程師編寫軟件。我們相信，牛，而不是寵物靈活的調度模式是谷歌在過去年成功的根本，也是軟件工程師工具箱中的重要工具。第頁的隨時間和規模的變化更深入地探討了谷歌在組織成長和發展過程中對計算架構的各種選擇是如何發揮的一些經驗。最後，第頁的選擇計算服務主要是獻給那些將決定在其組織中使用何種計算服務的工程師。

>“”>>免責聲明：對於某些應用程序，“運行它的硬件”是你客戶的硬件（例如，想想你十年前購買的一款壓縮包裝的遊戲）。這就提出了我們在本章中沒有涉及的非常不同的挑戰。

馴服計算機環境

’’’

谷歌的內部系統是今天許多架構（如或）的前身。爲了更好地理解這種服務的特定方面如何滿足一個不斷增長和發展的組織的需要，我們將追溯的發展和谷歌工程師爲馴服計算環境所做的努力。

自動化操作

’’’’“”

想象一下，你是世紀之交時的大學生。如果你想部署一些新的、牛逼的代碼，你會把代碼從複製到大學計算機實驗室的一臺機器上，進入機器，編譯並運行代碼。這是一個簡單而誘人的解決方案，但隨着時間的推移和規模的擴大，它遇到了相當多的問題。然而，因爲這大概是許多項目開始時的情況，多個組織最終採用的流程在某種程度上是這個系統的流程演變，至少對於某些任務來說是這樣的機器的數量增加了（所以你和進入其中許多機器），但底層技術仍然存在。例如，年，谷歌最資深的工程師之一傑夫·迪恩（）寫了以下關於在發佈過程中運行自動數據處理任務的文章：運行任務是一個組織管理的、耗時的噩夢。目前，它需要獲得一個多臺機器的列表，在這多臺機器上各啓動一個進程，並在這多臺機器上各監控其進度。如果其中一臺機器宕機了，不支持自動將計算遷移到另一臺機器上，而且監測工作的進展是以臨時的方式進行的此外，由於進程可以相互干擾，有一個複雜的、人工實現的註冊文件來節制機器的使用，這導致了非最優調度，增加了對稀缺機器資源的爭奪。

’

這是谷歌努力馴服計算環境的早期導火索，這很好地解釋了這種幼稚的解決方案如何在更大範圍內變得不可維護。

>“”>>、、、、和，“谷歌與的大規模集羣管理”，，文章編號：（年月）：。

簡單自動化

“”

一個組織可以做一些簡單的事情來減輕一些痛苦。將二進制文件部署到多臺機器上並在其中啓動的過程可以通過一個腳本輕鬆實現自動化，如果這是一個可重用的解決方案，則可以通過一段更健壯的代碼，使用一種更易於維護的語言，並行執行部署（特別是因爲“”可能會隨着時間的推移而增長）。

“”“”

更有趣的是，對每臺機器的監控也可以自動化。最初，負責進程的人希望知道（並能夠進行干預），如果其中一個副本出了問題。這意味着從進程中輸出一些監控指標（如進程是活的和處理的文件數）讓它寫到一個共享存儲中，或調用一個監控服務，在那裏他們可以一眼看到異常情況。目前該領域的開源解決方案是，例如，在或等監控工具中設置一個儀表盤。

’

“’”“”“”

如果檢測到異常，通常的緩解策略是通過進入機器，殺死進程（如果進程仍然在運行），然後重新啓動它。這很繁瑣，可能容易出錯（要確保你連接到正確的機器，並確保關閉正確的進程），並且可以自動化：

與其手動監控故障，不如在機器上使用一個代理，檢測異常情況（比如該進程在過去分鐘內沒有報告它處於”活動狀態或該進程在過去分鐘內沒有處理任何文件），如果檢測到異常情況，就關閉該進程。與其在宕掉後登錄到機器上再次啓動進程，不如將整個執行過程包裹在一個的腳本中。

在雲計算世界中，相當於設置了一個自動修復策略（在運行狀況檢查失敗後關閉並重新創建或容器）。

’

這些相對簡單的改進解決了前面描述的傑夫·迪恩問題的一部分，但不是全部；人工實現的流程，以及轉移到新機器，需要更復雜的解決方案。

自動調度

“”“”“”

下一步自然是自動化機器資源分配。這需要第一個真正的“服務”，最終將發展爲“計算即服務”。也就是說，爲了自動化調度，我們需要一箇中心服務，它知道可用機器的完整列表，並且可以根據需要選擇一些未佔用的機器，並自動將二進制文件部署到這些機器上。這樣就不需要人動了維護“註冊”文件，而不是將機器列表的維護委託給計算機。該系統強烈地讓人聯想起早期的分時貢獻體系結構。

這種想法的自然延伸是將這種調度與對機器故障的響應結合起來。通過掃描機器日誌以查找表示運行狀況不良的指標（例如，大量磁盤讀取錯誤），我們可以識別出損壞的機器，向（工程師）發出修復此類機器的信號，同時避免將任何工作安排到這些機器上。爲了進一步消除繁重的工作，自動化可以在人工干預之前先嚐試一些修復，比如重新啓動機器，希望任何錯誤都能消失，或者運行自動磁盤掃描。

’’

引用的最後一個抱怨是，如果正在運行的機器出現故障，人們需要將計算機遷移到另一臺機器上。這裏的解決方案很簡單：因爲我們已經有了調度自動化和檢測機器故障的能力，我們可以簡單地讓調度器分配一臺新機器，並在這臺新機器上重新啓動工作，放棄舊機器。執行此操作的信號可能來自機器內部守護進程或來自於對單個進程的監控。

“”

所有這些改進都系統地處理了組織規模不斷擴大的問題。當集羣是一臺機器時，和是完美的解決方案，但在數百或數千臺機器的規模上，需要自動化來接管。我們所引用的這句話來自年全局工作隊列的設計文件，這是早期針對某些工作負載的內部解決方案。

容器化和多租戶

’’

到目前爲止，我們隱含地假設機器和運行在機器上的程序之間存在一對一的映射。在計算資源（、）消耗方面，這在許多方面都是非常低效的：

很可能有許多不同類型的任務（具有不同的資源需求），而機器類型（具有不同的資源可用性）則較少。因此，許多任務將需要使用相同類型的機器（需要爲最大的任務配置機器）。這樣會導致資源利用率低下。機器部署需要很長時間，而程序的資源需求會隨着時間的推移而增長。如果組織需要花費數月時間來獲取新的更大機器，那麼在配置新機器所需的時間內，你需要確保它們足夠大，以適應預期的資源需求增長，這會導致資源浪費，因爲新機器的利用率無法充分發揮。即使新機器到達，你仍然擁有舊機器（丟棄它們可能是浪費的），因此你必須管理一個異構的機器羣，它不能自動適應你的需求。

最自然的解決方案是爲每個程序指定其資源需求（、、磁盤空間），然後要求調度器將程序的副本打包到可用的機器資源池中。

>>>請注意，如果你的組織從公共雲提供商那裏租用機器，這一點和下一點就不適用。

’鄰居家的狗在我的內存中吠叫

上述解決方案在每個人都遵守規則的情況下運作得很好。然而，如果我在配置中指定我的數據處理流水線的每個副本將使用一個和的內存，並且由於錯誤或指數式增長，它開始消耗更多的資源，那麼它調度到的機器將耗盡資源。在消耗的情況下，這將導致相鄰的服務工作出現延遲；在消耗的情況下，它要麼會導致內核內存不足，要麼會由於磁盤交換而導致可怕的延遲。

同一臺計算機上的兩個程序在其他方面也會相互影響。許多程序希望在特定版本的計算機上安裝它們的依賴項，這些依賴項可能會與其他程序的版本要求發生衝突。一個程序可能期望某些系統資源（例如）可供自己專用。安全性是一個問題程序可能正在處理敏感數據，需要確保同一臺計算機上的其他程序無法訪問它。

因此，多租戶計算服務必須提供一定程度的隔離，某種程度上保證一個進程能夠安全進行而不被機器的其他租戶干擾。

’

隔離的一個經典解決方案是使用虛擬機（）。然而，這些虛擬機在資源使用（它們需要資源在裏面運行一個完整的操作系統）和啓動時間（同樣，它們需要啓動一個完整的操作系統）方面有很大的開銷。這使得它們成爲一個不太完美的解決方案，使用於資源佔用少、運行時間短的批量作業容器化。這導致谷歌在年設計的工程師們尋找不同的解決方案，最終找到了容器一種基於（由谷歌工程師在年貢獻給內核）和、和或文件系統進行文件系統隔離的輕型機制。開源容器的實現包括和。

隨着時間的推移和組織的發展，發現了越來越多的潛在隔離故障。舉個具體的例子，年，在工作的工程師發現，進程空間（默認設置爲個）的耗盡正在成爲一個隔離故障，因此不得不引入對單個副本可產生的進程線程總數的限制。我們將在本章後面更詳細地討論這個例子。

>’’>>谷歌很久以前就確認了，由於磁盤交換導致的延遲降低是如此可怕，以至於內存不足殺死和遷移到另一臺機器是普遍可取的，因此在谷歌的情況下，總是內存不足殺死進程。>>>>儘管有大量的研究正在致力於減少這種開銷，但它永遠不會像一個本機運行的進程那麼低。

合理調整和自動縮放

年的根據工程師在配置中提供的參數，如複製的數量和資源要求，進行工作。

從長遠來看這個問題，要求人類確定資源需求量的想法有些缺陷：這些並不是人類每天都要與之交互的數字。因此，隨着時間的推移，這些配置參數本身就成爲效率低下的來源。工程師需要花時間在最初的服務啓動時確定這些參數，而隨着你的組織積累越來越多的服務，確定這些參數的成本也在增加。此外，隨着時間的推移，程序的發展（可能不斷增長），但配置參數並沒有跟上。這最終導致了故障的發生事實證明，隨着時間的推移，新版本的資源需求喫掉了留預期外高峯或故障的冗餘資源，而當這種高峯或故障實際發生時，剩餘的冗餘資源被證明是不夠的。

“”’’

自然的解決方案是將這些參數的設置自動化。不幸的是，要做好這件事非常棘手。作爲一個例子，谷歌最近才達到一個點，即整個集羣超過一半的資源使用是由調整大小有自動化系統決定的。也就是說，儘管這只是一半的使用量，但它是配置中較大的一部分，這意味着大多數工程師不需要擔心確定容器大小的繁瑣且容易出錯的問題。我們認爲這是對簡單的事情應該是容易的，複雜的事情應該是可能的這一理念的成功應用僅僅因爲工作負載的某些部分過於複雜，無法通過自動調整大小進行適當的管理，並不意味着在處理簡單情況時沒有巨大的價值。

總結

隨着你的組織的發展和產品的普及，你將在所有這些軸上成長：

需要管理的不同應用程序的數量需要運行的應用程序的副本數量最大的應用程序的規模

爲了有效地管理規模，需要自動化，使你能夠解決所有這些增長軸。隨着時間的推移，你應該期待自動化本身變得更多，既要處理新類型的要求（例如，和的調度是在過去年裏發生的一個主要變化），又要處理規模的增加。在較小的規模下，可能是手動的操作，將需要自動化，以避免組織在負載下的崩潰。

一個例子谷歌仍在摸索的轉變是自動管理我們的數據中心。十年前，每個數據中心是一個獨立的實體。我們手動管理它們。啓用一個數據中心是一個複雜的手動過程，需要專門的技能，需要幾周的時間（從所有機器準備好的那一刻開始），而且本身就有風險。然而，谷歌管理的數據中心數量的增長意味着我們轉向了一種模式，即啓動數據中心是一個不需要人工干預的自動化過程。

爲管理計算能力編寫軟件

從手工管理的機器列表轉向自動化的計劃和調整規模，這使得谷歌更容易管理集羣，但也給我們編寫和思考軟件的方式帶來了深刻的變化。

故障架構

想象一下，一個工程師要處理一批萬份文件並驗證其正確性。如果處理一個文件需要一秒鐘，那麼整個工作將需要一臺機器大約天這可能太長了。因此，我們把工作分散到臺機器上，這將運行時間減少到更易於管理的分鐘。

“”“”

正如第頁自動調度中所討論的，在世界中，調度中心可以單方面殺死箇中的一個，並把它移到不同的機器上。把它移到不同的機器上這部分意味着你的的新實例可以自動被輸出出來，不需要人手動去進入機器，調整一些環境變量或安裝軟件包。

“”“”“”

從工程師必須手動監控個任務中的每一個，並在出現問題時對其進行處理到如果其中一個任務出現問題，系統會被設計成由其他任務來承擔，而自動化系統會將其殺死並在新的機器上重新執行，這一轉變在許多年後通過寵物與牛的比喻來描述。

’’“”’’

如果你的服務器是一隻寵物，當它壞了時，一個人會來看它（通常是驚慌失措），瞭解出了什麼問題，並希望護理它恢復健康。很難更換。如果你的服務器是牛羣，你可以將它們命名爲到，如果其中一個服務器出現故障，自動化將刪除它並在其位置提供一個新的服務器。“牛羣”的獨特之處在於，它可以很容易地刪除相關作業的新實例它不需要手動設置，可以完全自動完成。這就實現了前面描述的自愈特性。在發生故障的情況下，自動化可以接管不健康的工作，並用一個新的、健康的工作替換它，而無需人工干預。請注意，儘管最初的隱喻談到了服務器（），但同樣適用於容器：如果你可以在無需人工干預的情況下從鏡像中刪除容器的新版本，那麼你的自動化將能夠在需要時自動修復你的服務。

’

如果你的服務器是寵物，你的維護負擔將隨着你的集羣規模線性增長，甚至是超線性增長，這是任何組織都不應輕視的負擔。另一方面，如果你的服務器是牛羣，你的系統將能夠在故障後恢復到一個穩定的狀態，你將不需要花週末的時間來護理一個寵物服務器或容器恢復健康。

’’’

不過，讓虛擬機或容器正常運行並不足以保證系統在出現故障時表現良好。對於臺機器，很可能會殺死其中一個複製副本，可能不止一次，每次都會將整個持續時間延長分鐘（或者無論損失多少處理時間）。爲了優雅地處理這個問題，處理的架構需要改變：我們不是固定地分配工作，而是將萬個文檔的整個集合劃分爲個塊，每個塊包含個文檔。每當一個完成了一個特定的塊，它就會報告結果，並拿起另一個。這意味着，如果在完成區塊後但在報告之前宕機，我們在失敗時最多損失一個區塊的工作。幸運的是，這非常符合當時谷歌標準的數據處理架構：在計算開始時，任務並不是平均分配給一組的；而是在整個處理過程中動態分配的，以便考慮到的失敗。

“”

同樣的，對於服務於用戶流量的系統來說，理想情況下，希望容器調度不會導致向用戶提供錯誤。當調度器由於維護原因計劃重新調度一個容器時，會向容器發出信號以提前通知它。容器可以通過拒絕新的請求來做出反應，同時還有時間來完成它正在進行的請求。這反過來要求負載均衡器系統理解我不能接受新請求的響應（並將流量重定向到其他副本）。

總而言之：將容器或服務器視爲“牛羣”意味着你的服務可以自動恢復到正常狀態，但還需要付出額外的努力，以確保它能夠在遇到中等故障率的情況下順利運行。

>>>調度器並不是隨意這樣做的，而是出於具體的原因（比如需要更新內核，或者機器上的磁盤壞了，或者爲了更好地打包數據中心容器中的工作負載的總體分佈而進行的改組）。然而，擁有計算服務的意義在於，作爲軟件作者，我不應該知道也不關心爲什麼會發生這種情況。>>“”’“”>>寵物與牛羣的比喻是由歸功於的，它作爲描述複製的軟件單元概念的一種方式，已經變得非常流行。作爲一個比喻，它也可以用來描述服務器以外的概念；例如，見第章。

批量作業與服務作業

“”“”

全局工作隊列（）（我們在本章第一節中描述過）解決了谷歌工程師所說的批處理作業的問題這些程序要完成一些特定的任務（如數據處理），並且要運行到完成。批量作業的典型例子是日誌分析或機器學習模型學習。批量作業與服務作業形成鮮明對比這些程序預計將無限期地運行併爲傳入的請求提供服務，典型的例子是爲來自預構建索引的實際用戶搜索查詢提供服務的作業。

’

這兩類作業（通常）具有不同的特點，特別是：

批量作業主要關心的是處理的吞吐量。服務作業關心的是服務單個請求的延遲。批量作業的生命週期很短（幾分鐘，或最多幾個小時）。服務工作通常是長期存在的（默認情況下，只有在新版本發佈時纔會重新啓動）。因爲它們是長期存在的，所以服務工作更有可能有較長的啓動時間。

到目前爲止，我們大部分的例子都是關於批處理作業的。正如我們所看到的，爲了使批處理作業適應失敗，我們需要確保工作被分散成小塊，並動態地分配給。在谷歌，這樣做的典型框架是，後來被取代。

在許多方面，服務作業比批量作業更自然地適合於抗故障。他們的工作自然地分成小塊（單個用戶請求），動態地分配給。從互聯網流量服務的早期開始，就採用了通過服務器集羣負載平衡來處理大量請求的策略。

“”’

然而，也有多個服務應用程序不適合這種模式。典型的例子是任何你直觀地描述爲某個特定系統“領導者”的服務器。這樣的服務器通常會維護系統的狀態（在內存中或在其本地文件系統中），如果它所運行的機器出現故障，新創建的實例通常無法重新創建系統的狀態。另一個例子是，當你有大量的數據需要服務超過一臺機器所能容納的於是你決定將數據分片，比如說，臺服務器，每臺都持有的數據，並處理這部分數據的請求。這類似於將工作靜態地分配給批處理工作的；如果其中一個服務器發生故障，你就會（暫時）失去爲部分數據服務的能力。最後一個示例是，系統的其他部分是否知道服務器的主機名。在這種情況下，無論服務器的結構如何，如果此特定主機失去網絡連接，系統的其他部分將無法與之聯繫。

>’’>>像所有的分類一樣，這個分類並不完美；有些類型的程序不適合任何類別，或者具有服務作業和批處理作業的典型特徵。然而，與最有用的分類一樣，它仍然抓住了許多實際案例中存在的區別。>>“”>>見和，。簡化大型集羣上的數據處理，第六屆操作系統設計與實現研討會（），。>>“”>>編程語言設計與實現會議（），。>>“”“”>>另見等人，數據中心應用的自動分片，，；以及、、和，快速鍵值存儲。一個時代已經到來的想法，，年。

管理狀態

“”

在前面的描述中，有一個共同的主題集中在狀態上，當試圖像對待牛一樣對待作業時，狀態是問題的來源。每當你替換你的一個牛的作業時，你會失去所有的進程中的狀態（以及所有在本地存儲的東西，如果作業被轉移到不同的機器上）。這意味着進程內狀態應被視爲瞬態，而“真實存儲”需要發生在其他地方。

處理這個問題的最簡單方法是將所有的存儲提取到外部存儲系統。這意味着任何應該在服務單一請求（在服務工作的情況下）或處理一個數據塊（在批處理的情況下）的範圍內生存的東西都需要存儲在機器外的持久性存儲中。如果所有的本地狀態都是不可變的，那麼讓應用程序具有抗故障能力應該是相對容易的。

“”“”

不幸的是，大多數應用並不那麼簡單。可能會想到的一個自然而然問題是：這些持久的存儲解決方案是如何實現的它們是牛嗎？答案應該是是的。牛可以通過狀態複製來管理持久狀態。在不同的層面上，陣列是一個類似的概念；我們將磁盤視爲暫時的（接受其中一個可以消失的事實），同時仍保持主要狀態。在服務器世界中，這可以通過多個副本來實現，多個副本保存一個數據段並進行同步，以確保每個數據段都被複制足夠的次數（通常爲到次）。請注意，正確設置此選項很困難（需要某種一致性處理方式來處理寫操作），因此開發了許多專門的存儲解決方案，這些解決方案是採用所有狀態都是瞬態的模型的大多數應用程序的推動者。

“”

牛可以使用的其他類型的本地存儲包括本地保存的“可重新創建”數據，以改善服務延遲。緩存是這裏最明顯的例子：緩存只不過是在一個短暫的位置上保存狀態的本地存儲，但卻依賴於該狀態不會一直消失，這使得平均性能特徵更好。谷歌生產基礎設施的一個關鍵經驗是，配置緩存以滿足你的延遲要求，但爲總負載配置核心應用程序。這使得我們能夠在緩存層丟失時避免故障，因爲非緩存路徑的配置能夠處理總的負載（儘管延遲更高）。然而，這裏有一個明顯的權衡：當緩存容量丟失時，要在冗餘上花多少錢才能減輕故障的風險。

與緩存類似，在應用程序的預熱過程中，數據可能從外部存儲拉到本地，以改善請求服務延遲。

’

還有一種使用本地存儲的情況這次是在數據寫入多於讀取的情況下是批量寫入。這是監控數據的常見策略（例如，考慮從機羣中收集利用率的統計數據，以指導自動伸縮系統），但它也可以用在任何可以接受部分數據丟失的地方，因爲我們不需要的數據覆蓋（這是監控的情況），或者因爲丟失的數據可以重新創建（這是一個批處理作業的情況，它分塊處理數據，併爲每個分塊寫一些輸出）。請注意，在很多情況下，即使一個特定的計算需要很長的時間，也可以通過定期檢查狀態到持久性存儲的方式將其分割成更小的時間窗口。

>“”’>>請注意，除了分佈式狀態，建立一個有效的服務器即牛解決方案還有其他要求，比如發現和負載平衡系統（以便你的應用程序，在數據中心內移動，可以被有效訪問）。因爲這本書與其說是關於建立一個完整的基礎設施，不如說是關於這樣的基礎設施與軟件工程藝術的關係，所以我們在這裏就不多說了。>>“”“”“’”>>例如，見等人一個結構化數據的分佈式存儲系統，第七屆操作系統設計和實施研討會（）；或等人，”谷歌的全球分佈式數據庫，，。

連接到服務

如前所述，如果系統中的任何內容都有你的程序所運行的主機的名字的硬編碼（甚至在啓動時作爲配置參數提供），則程序副本不可用。然而，爲了連接到你的應用程序，另一個應用程序確實需要從某個地方獲得你的地址。在哪裏？

“”

答案是有一個額外的代理層；也就是說，其他應用程序通過某個標識符來引用你的應用程序，這些標識符在特定的後端實例的重啓中是持久的。這個標識符可以由另一個系統來解決，當調度器把你的應用程序放在一個特定的機器上時，它就會寫到這個系統。現在，爲了避免在向你的應用程序發出請求的關鍵路徑上進行分佈式存儲查詢，客戶可能會在啓動時查詢你的應用程序的地址，並建立一個連接，並在後臺監控它。這通常被稱爲服務發現，許多計算產品有內置或模塊化的解決方案。大多數這樣的解決方案還包括某種形式的負載平衡，這就進一步減少了與特定後端的耦合。

’

這種模式的影響是，在某些情況下，你可能需要重複你的請求，因爲你對話的服務器可能在響應之前就被關閉了。由於網絡問題，重試請求是網絡通信的標準做法（例如，移動應用程序到服務器），但對於像服務器與數據庫通信的事情來說，這可能不夠直接。這使得在設計你的服務器的時，必須能夠優雅地處理這種故障。對於突變的請求，處理重複請求是很棘手的。你想保證的屬性是冪等性變體發出一個請求兩次的結果與發出一次相同。幫助實現冪等性的一個有用工具是客戶機指定的標識符：如果你正在創建一些內容（例如，將比薩餅送到一個特定的地址的訂單），該訂單由客戶端分配一些標識符；如果一個具有該標識符的訂單已經被記錄下來，服務器會認爲這是一個重複的請求並報告成功（它也可能驗證該訂單的參數是否匹配）。

“”

我們看到的另一件令人驚訝的事情是，有時調度器會因爲一些網絡問題而與某臺機器失去聯繫。然後它認爲那裏的所有工作都丟失了，並將其重新安排到其他機器上然後這臺機器又回來了現在我們在兩臺不同的機器上有兩個程序，都認爲自己是。他們消除歧義的方法是檢查他們中的哪一個被地址解析系統提及（而另一個應該終止自己或被終止）；但這也是冪等性的另一個案例：兩個執行相同工作並擔任相同角色的副本是請求重複的另一個潛在來源。

>>>請注意，重試需要正確地實現用後退、優雅降級和工具來避免像抖動那樣的失敗。因此，這可能應該是遠程過程調用庫的一部分，而不是由每個開發人員手工實現。例如，見書中的第章：解決級聯故障。

一次性代碼

前面的討論大多集中在生產質量的工作上，要麼是那些爲用戶流量服務的工作，要麼是產生生產數據的數據處理管道。然而，軟件工程師的生活也涉及到運行一次性分析、探索性原型、定製數據處理管道等等。這些都需要計算資源。

’

通常，工程師的工作站是滿足計算資源需求的滿意解決方案。比如說，如果想自動瀏覽服務在最後一天生成的日誌，以檢查可疑行是否總是出現在錯誤行之前，他們可以下載日誌，編寫一個簡短的腳本，然後讓它運行一兩分鐘即可。

但是，如果他們想自動瀏覽去年服務生產的日誌（出於類似目的），等待大約一天的結果可能是不可接受的。一個允許工程師在幾分鐘內（利用幾百個內核）在分佈式環境中運行分析的計算服務意味着立即得到分析結果和明天才能得到結果之間的區別。例如，對於需要迭代的任務，如果我在看到結果後需要優化查詢，那麼在一天內完成任務和根本無法完成任務之間可能存在差異。

’’’’

這種方法有時會引起一個問題，即允許工程師在分佈式環境中運行一次性作業可能會浪費資源。當然，這是一種權衡，但應該有意識地進行權衡。工程師運行的處理成本很可能不會比工程師寫處理代碼的時間更貴。確切的權衡取決於一個組織的計算環境和它付給工程師的工資多少，但一千個核心小時的成本不太可能接近一天的工程工作量。在這方面，計算資源類似於標記，我們在本書的開篇中討論過；對於公司來說，建立一個獲取更多計算資源的過程是一個很小的節約機會，但是這個過程在失去工程機會和時間方面的成本可能比它節省的成本高得多。

’’’’

這就是說，計算資源與標記的不同之處在於，很容易因意外而佔用過多的資源。雖然不太可能有人會攜帶上千個標記，但完全有可能有人會無意中編寫一個程序，在沒有注意到的情況下佔用了上千臺機器。解決這一問題的自然方法是爲每個工程師的資源使用設定配額。谷歌使用的一個替代方案是，由於我們正在有效地免費運行低優先級的批處理工作負載（見後面關於多租戶的部分），我們可以爲工程師提供幾乎無限的低優先級批處理配額，這對於大多數一次性工程任務來說已經足夠了。

>>>這種情況在谷歌發生過多次；例如，因爲有人在休假時留下了佔用一千臺谷歌計算引擎虛擬機的負載測試基礎設施，或者因爲一個新員工在他們的工作站上調試一個主二進制文件時，沒有意識到它在後臺催生了個全機器。

隨時間和規模的變化

“”

我們在上面討論了是如何在發展起來的，以及實現它所需要的基本部分只需給我資源來運行我的東西的簡單任務是如何過渡到像這樣的架構。體系結構如何跨時間和規模影響軟件生命週期的幾個方面值得仔細研究。

容器是一種抽象

正如我們前面所描述的，容器主要是一種隔離機制，一種實現多租戶的方法，同時最大限度地減少共享一臺機器的不同任務之間的干擾。這是最初的動機，至少在谷歌是這樣。但事實證明，容器在抽象計算環境方面也起着非常重要的作用。

’

容器在部署的軟件和它所運行的實際機器之間提供了一個抽象邊界。這意味着，隨着時間的推移，機器發生了變化，只有容器軟件（大概由一個團隊管理）需要調整，而應用軟件（隨着組織的發展，由每個團隊管理）可以保持不變。

’

讓我們來討論兩個例子，說明容器化的抽象如何讓一個組織管理變化。

文件系統抽象提供了一種方法，將不是由公司編寫的軟件整合進來的方式，而無需管理自定義的機器配置。這可能是某個組織在其數據中心運行的開源軟件，或者是它想在其上進行的整合。在沒有文件系統抽象的情況下，如果一個二進制文件需要一個不同的文件系統佈局（例如，期望在有一個附加二進制文件）將需要修改機羣中所有機器的基本佈局，或者對集羣進行分段操作，或者修改軟件（這可能會由於許可證考慮而變得困難甚至不可能）。

即使這些解決方案可能是可行的，如果導入一個外部軟件是一生中只會發生一次的事情，但如果導入軟件成爲一種常見的（甚至只是有點罕見的）做法，這不是一個可持續的解決方案。

某種類型的文件系統抽象也有助於依賴性管理，因爲它允許軟件預先聲明和預包裝軟件運行所需的依賴性（例如，特定版本的庫）。依賴於安裝在機器上的軟件提出了一個漏洞百出的抽象，迫使每個人都使用相同版本的預編譯庫，使任何組件的升級都非常困難，甚至不可能。

容器還提供了一種簡單的方法來管理計算機上的命名資源。典型的示例是網絡端口；其他命名資源包括專用目標；例如和其他加速器。

“”“”

最初並沒有將網絡端口作爲容器抽象的一部分，因此二進制文件不得不自己搜索未使用的端口。結果，函數在谷歌代碼庫中有超過次的使用。是在命名空間引入後建立的，它使用命名空間爲容器提供虛擬私有網卡，這意味着應用程序可以監聽他們想要的任何端口。網絡堆棧然後將機器上的一個端口映射到容器內的端口。最初建立在之上的更進一步，要求網絡實現將容器（術語爲）視爲真正的地址，可從主機網絡獲得。現在，每個應用程序都可以監聽他們想要的任何端口，而不用擔心衝突。

當處理不是爲在特定計算機技術棧上運行而設計的軟件時，這些改進尤其重要。儘管許多流行的開源程序都有使用哪個端口的配置參數，但它們之間對於如何配置並不一致。

容器和隱性依賴

’

與任何抽象一樣，海勒姆定律的隱性依賴適用於容器抽象。由於用戶數量巨大（在谷歌，所有生產軟件和許多其他軟件都將在上運行），它可能比通常更適用而且因爲用戶在使用文件系統之類的東西時感覺不到自己在使用（而且更不可能考慮此是否穩定、是否有版本等）。

’

爲了說明這一點，讓我們回到在年經歷的進程空間耗盡的例子。你可能想知道爲什麼進程是可耗盡的。它們不僅僅是可以從位或位空間分配的整數嗎？在中，它們實際上是在，，範圍內分配的，其中默認爲。然而，可以通過簡單的配置更改（達到相當高的限制）來提高。問題解決了嗎？

’’

嗯，沒有。根據海勒姆定律，在上運行的進程得到的被限制在範圍內，這一事實成爲人們開始依賴的隱含的保證；例如，日誌存儲進程依賴於可以存儲爲五位數的事實，而對於六位數的來說，就會出現問題，因爲記錄名稱超出了最大允許長度。處理這個問題成爲一個漫長的、分兩個階段的項目。首先，對單個容器可以使用的數量設定一個臨時的上限（這樣單個線程泄漏的工作就不會導致整個機器無法使用）。第二，爲線程和進程分割空間。因爲事實證明，很少有用戶依賴分配給線程的的個保證，而不是進程。所以，我們可以增加線程的限制，而將進程的限制保持在個）。第三階段是在中引入命名空間，讓每個容器擁有自己完整的空間。可以預見的是（又是定律），許多系統最終都認爲這三者可以唯一地識別一個進程，如果引入命名空間，這將會被打破。識別所有這些地方並修復它們（以及回傳任何相關數據）的努力在八年後仍在進行。

’’’’

這裏的重點不是說你應該在命名空間中運行你的容器。儘管這是個好主意，但這並不是有趣的經驗。當的容器被建立時，命名空間並不存在；即使它們存在，期望年設計的工程師認識到引入它們的價值也是不合理的。即使是現在，機器上也肯定有一些資源沒有被充分隔離，這可能會在某一天造成問題。這強調了設計一個容器系統的挑戰，該系統將被證明是可以長期維護的，因此使用一個由更廣泛的社區開發和使用的容器系統的價值，在那裏，這些類型的問題已經存在爲其他人發生的事件，已將所吸取的經驗教訓納入其中。

一種服務統治一切

如前所述，最初的設計只針對一些批處理作業，這些作業最終都共享一個由管理的機器資源池，而對於服務作業則採用不同的架構，每個特定的服務作業都運行在自己的專用機器資源池中。開源的替代方案是爲每種類型的工作負載單獨運行一個集羣（以及一個用於所有批處理作業的池）。

’

年，項目啓動，旨在（並最終成功地）建立一個計算服務，將這些不同的機器資源池整合爲一個大機器資源池。的機器資源池涵蓋了服務和批處理工作，併成爲任何數據中心的唯一機器資源池（相當於爲每個地理位置的所有工作負載運行一個大型集羣）。這裏有兩個顯著的效率提升值得討論。

“’”’’

第一個是，服務於機器的人變成了牛（設計文檔是這樣說的。機器是透明的：程序並不關心它們在哪臺機器上運行，只要它有正確的特徵）。如果每個管理服務工作的團隊都必須管理他們自己的機器資源池（他們自己的集羣），那麼維護和管理這個機器資源池的組織開銷也同樣適用於這些團隊中的每個人。隨着時間的推移，這些機器資源池的管理實踐會隨着時間的推移而產生分歧，使整個公司範圍內的變化（如轉移到一個新的服務器架構，或切換數據中心）變得越來越複雜。一個統一的管理基礎設施也就是一個適用於組織中所有工作負載的通用計算服務允許谷歌避免這種線性擴展因素；對於機羣中的物理機器沒有種不同的管理實踐，只有。

’

第二個問題更加微妙，可能並不適用於每個組織，但它與谷歌非常相關。批量作業和服務作業的不同需求是互補的。服務工作通常需要超額配置，因爲它們需要有能力爲用戶流量提供服務而不出現明顯的延遲下降，即使在使用量激增或部分基礎設施中斷的情況下。這意味着僅運行服務作業的機器將未得到充分利用。試圖通過過度使用機器來利用這種閒置是很有誘惑力的，但這首先違背了閒置的目的，因爲如果出現高峯中斷出現，我們需要的資源將無法使用。

然而，這種推理僅適用於服務作業！如果我們在一臺機器上有許多服務作業，而這些作業請求的和總計爲機器的總和，即使資源的實際利用率僅爲容量的，也不能在其中放置更多的服務作業。但我們可以（而且，在，我們）將批處理作業放在備用中，策略是，如果任何服務作業需要內存或，我們將從批處理作業中回收（在的情況下凍結它們，在的情況下殺死它們）。因爲批處理作業對吞吐量感興趣（在數百名中進行聚合測量，而不是針對單個任務），而且它們的單個副本無論如何都是牛，所以它們將非常樂意吸收服務作業的這一剩餘容量。

’

根據給定機器資源池池中工作負載的形狀，這意味着要麼所有批處理工作負載都有效地運行在空閒資源上（因爲我們無論如何都是在空閒的服務作業中爲它們付費）或者，所有的服務性工作負載實際上只爲他們使用的東西付費，而不是爲他們抵抗故障所需的閒置容量付費（因爲批處理作業是在這種閒置狀態下運行的）。在谷歌的案例中，大多數時候，事實證明我們免費有效地運行批處理。

>’>>正如任何複雜的系統一樣，也有例外。並非所有谷歌擁有的機器都由管理，也不是每個數據中心都由一個單元覆蓋。但大多數工程師的工作環境是，他們不接觸非機，也不接觸非標準的單元。

爲工作提供服務的多租戶

“”

’’’’

早些時候，我們討論了計算服務必須滿足的一些要求，以適合運行服務作業。正如之前所討論的，讓服務作業由一個共同的計算解決方案來管理有多種好處，但這也伴隨着挑戰。一個值得重複的特殊要求是發現服務，在第頁的連接到服務中討論過。當我們想把託管計算解決方案的範圍擴展到服務任務時，還有一些其他的要求是新的，比如說

作業的重新調度需要節制：儘管殺死並重新啓動一個批處理作業的的副本可能是可以接受的（因爲這隻會導致處理過程中的暫時性突變，而我們真正關心的是吞吐量），但殺死並重新啓動一個服務作業的的副本是不太可能接受的（因爲剩下的作業可能太少，無法在等待重新啓動的作業再次出現的同時爲用戶流量提供服務）。一個批處理作業通常可以在沒有警告的情況下被殺死。我們失去的是一些已經執行的處理，這些處理可以重新進行。當一個服務工作在沒有警告的情況下被殺死時，我們很可能冒着一些面向用戶的流量返回錯誤或（最多）延遲增加的風險；最好是提前幾秒鐘發出警告，以便工作能夠完成服務它在運行中的請求，不再接受新的請求。

出於上述效率原因，同時涵蓋了批處理和服務作業，但多個計算產品將這兩個概念分割開來通常情況下，批處理作業使用共享的機器資源池，而服務工作使用專用的、穩定的機器資源池。然而，無論這兩類工作是否使用相同的計算架構，這兩類工作都會因被當作牛一樣對待而受益。

提交配置

’

調度器接收擴容服務或批處理作業的配置，作爲遠程過程調用（）的內容在單元中運行。服務運營商可以通過使用命令行界面（）對其進行管理，該界面發送這些，並將參數存儲在共享文檔或其中。

在一般情況下，依靠文檔和團隊知識而不是提交給資源庫的代碼不會是個好主意，因爲文檔和團隊知識都有隨着時間推移而退化的趨勢（見第三章）。然而，前進中的下一個自然步驟將的執行包裹在本地開發的腳本中仍然不如使用專門的配置語言來指定服務的配置。

隨着時間的推移，邏輯服務的運行時存在通常會超過在一個數據中心的部署容器組，跨越多個區域：

它將在多個數據中心分散其存在（既有用戶親和力，也有抗故障能力）。除了生產環境配置之外，它還會分叉到擁有臨時和開發環境。它將以附加服務的形式累積不同類型的額外副本容器，如服務附帶的。

“”

如果這種複雜的設置可以用一種標準化的配置語言來表達，那麼服務的管理就會大大簡化，這種語言可以方便地表達標準操作（比如“將我的服務更新爲新版本的二進制文件，但在任何給定時間佔用的容量不超過”）。

標準化配置語言提供標準配置，其他團隊可以輕鬆地將其包含在服務定義中。像往常一樣，我們強調這種標準配置在時間和規模上的價值。如果每個團隊都編寫不同的自定義代碼片段以支持其服務，則執行組織範圍內的任務（如切換到新的實現）或將安全更新推送到所有部署將變得非常困難。還要注意，這種標準化配置語言是部署自動化的一個要求（參見第章。

選擇計算服務

’’’

不太可能有別的組織會重走谷歌走過的路，從頭開始構建自己的計算架構。如今，現代計算產品在開源世界（比如或，或者在不同的抽象層次上，或），或作爲公共雲管理產品（同樣，在不同的複雜性級別，從雲平臺的託管實例組或服務彈性計算雲自動伸縮；到類似於的託管容器，如服務或谷歌引擎；提供類似或谷歌雲功能的無服務器服務）。

’

然而，大多數組織會選擇一個計算服務，就像谷歌內部那樣。請注意，計算基礎設施有一個很高的鎖定因素。其中一個原因是，代碼的編寫方式將充分利用系統的所有特性（海勒姆定律）；因此，例如，如果你選擇了一個基於虛擬機的產品，團隊將調整他們特定的虛擬機鏡像；如果你選擇了一個特定的基於容器的解決方案，團隊將調用集羣管理器的。如果你的架構允許代碼將虛擬機（或容器）視爲寵物，那麼團隊將這樣做，然後轉向一種解決方案，將它們視爲牛（甚至不同形式的寵物）將是困難的。

爲了說明即使是計算解決方案中最小的細節也會最終被鎖定，考慮一下如何運行用戶在配置中提供的命令。在大多數情況下，該命令將是執行一個二進制文件（後面可能有一些參數）。然而，爲了方便起見，的作者也包括了傳入一個腳本的可能性；例如，。然而，二進制的執行可以通過一個簡單的來完成（這就是的做法），腳本需要由一個像這樣的來運行。所以，實際上是執行，該命令也適用於簡單的二進制執行。

’

在某種程度上，團隊意識到在的規模下，這個包裝器所消耗的資源主要是內存是不可忽視的，並決定轉而使用一個更輕量級的：。因此，該團隊對進程運行器的代碼進行了修改，改爲運行。

’’“”

你會認爲這不是一個有風險的改變；畢竟，我們控制了環境，我們知道這兩個二進制文件都存在，所以這不可能不起作用。事實上，這不起作用的原因是，的工程師們並不是第一個注意到運行的額外內存開銷的人。一些團隊在限制內存使用方面很有創意，他們（在他們的自定義文件系統覆蓋中）用一段自定義編寫的執行第二個參數的代碼來替換命令。當然，這些團隊非常清楚他們的內存使用情況，因此當團隊將進程運行器改爲使用（沒有被自定義代碼覆蓋）時，他們的內存使用量增加了（因爲它開始包括的使用量而不是自定義代碼的內存使用量），這引起了警報、回滾變化和一定程度的不愉快。

計算服務的選擇難以隨時間變化的另一個原因是，任何計算服務的選擇最終都會被一個龐大的輔助服務生態系統所包圍用於記錄、監控、調試、警報、可視化、即時分析、配置語言和元語言、用戶界面等等的工具。這些工具需要作爲計算服務變革的一部分被重寫，甚至理解和列舉這些工具對於一個大中型組織來說都可能是一個挑戰。

’

因此，計算架構的選擇是很重要的。與大多數軟件工程的選擇一樣，這個選擇涉及到權衡。讓我們來討論一下。

>’>>這個特殊的命令在下是有害的，因爲它阻止處理故障的機制啓動。但是，更復雜的包裝器（例如，將環境的一部分回送到日誌記錄）仍然在使用，以幫助調試啓動問題。

統一與定製

從計算棧的管理開銷的角度來看（也從資源效率的角度來看），一個組織能做的最好的事情就是統一採用一個的解決方案來管理它的整個機羣，並且只使用那裏的工具供大家使用。這可以確保隨着組織的發展，管理集羣的成本仍然是可控的。這條路基本上就是谷歌對所做的。

定製化

“”“”’’

然而，一個不斷發展的組織將有越來越多樣化的需求。例如，當谷歌在年推出谷歌計算引擎（“虛擬機即服務”公共雲產品）時，這些虛擬機與谷歌的大多數其他產品一樣，都是設計的。這意味着每個虛擬機都在控制的單獨容器中運行。然而，任務管理的“牛”方法並不適合雲的工作負載，因爲每個特定容器實際上是某個特定用戶正在運行的，而云的用戶通常不會將視爲牛。

’’’

調和這種差異需要雙方做大量的工作。雲計算組織確保支持虛擬機的實時遷移；也就是說，能夠在一臺機器上運行一個虛擬機，在另一臺機器上啓動該虛擬機的副本，使該副本成爲一個完美的鏡像，並最終將所有流量重定向到該副本，而不會造成明顯的服務不可用時間段。另一方面，必須進行調整，以避免隨意殺死包含虛擬機的容器（以提供時間將虛擬機的內容遷移到新機器上），同時，鑑於整個遷移過程更加耗時，的調度算法被調整爲優化，以減少需要重新調度的風險。當然，這些修改只針對運行雲工作負載的機器，導致了谷歌內部計算產品的分化（很小，但仍然很明顯）。

>>>我的郵件服務器不能與圖形渲染作業互換，即使這兩個任務都以相同的形式運行。>>“”>>這不是讓用戶虛擬機能夠實時遷移的唯一動機；它還提供了大量面向用戶的好處，因爲這意味着可以修補主機操作系統並更新主機硬件，而不會中斷。另一種選擇（其他主要雲供應商使用）是提供“維護事件通知”，這意味着雲提供商可以重新啓動或停止，然後再啓動。>>>>考慮到並非所有客戶虛擬機都選擇實時遷移，這一點尤其重要；對於某些工作負載，即使在遷移過程中出現短期性能下降也是不可接受的。這些客戶將收到維護事件通知，除非嚴格必要，否則將避免驅逐帶有這些的容器。

’

另一個不同的例子但也導致了分化來自於搜索。年左右，一個爲谷歌搜索網絡流量服務的複製容器在本地磁盤上建立了一個巨大的索引，存儲了谷歌網絡索引中不常被訪問的部分（更常見的查詢由其他容器的內存緩存提供）。在一臺特定的機器上建立這個索引需要多個硬盤的容量，並且需要幾個小時來填入數據。然而，在當時，認爲，如果某個特定容器上有數據的任何磁盤壞了，該容器將無法繼續運行，需要重新調度到另一臺機器上。這種組合（與其他硬件相比，旋轉磁盤的故障率相對較高）造成了嚴重的可用性問題；容器總是被關閉，然後又要花很長時間才能重新啓動。爲了解決這個問題，必須增加容器自己處理磁盤故障的能力，選擇不使用的默認處理方式；而搜索團隊必須調整流程，在部分數據丟失的情況下繼續運行。

“”

其他多個分化，涵蓋了文件系統形狀、文件系統訪問、內存控制、分配和訪問、內存定位、特殊硬件、特殊調度約束等領域，導致的體量變得龐大而笨重，各種行爲的交叉點變得難以預測，甚至更難測試。沒有人真正知道，如果一個容器同時請求特殊的雲處理（用於驅逐）和自定義的磁盤故障搜索處理（在許多情況下，“預期”的含義甚至不明顯），預期的事情是否會發生。

年後，團隊花了大量時間來清理的。它發現提供的一些功能已不再使用。令人關注的功能組是多個容器使用的功能組，但目前尚不清楚，在項目之間複製配置文件的過程是否有意導致原本只針對超級用戶的功能的使用激增。某些功能被引入了白名單，以限制它們的傳播，並明確地將它們標記爲僅適用於特權用戶。然而，清理工作仍在進行，一些變化（如使用標籤來識別容器組）仍未完全完成。

像通常情況下的權衡一樣，儘管有一些方法可以投入精力並從定製中獲得一些好處，同時又不會遭受嚴重的負面影響（如前面提到的特權白名單），但最終還是要做出艱難的選擇。這些選擇通常以多個小問題的形式出現：我們是否接受擴展顯式（或更糟的是，隱式）表面以適應我們基礎設施的特定用戶，或者我們是否顯著地給該用戶帶來不便，但主要是保持更高的一致性？

>>>這是一個很好的提醒，隨着時間的推移，監視和跟蹤功能的使用是很有價值的。>>>>這意味着從清理的經驗中獲益，但從一開始就沒有受到廣泛的現有用戶基礎的阻礙，從一開始就在很多方面（如標籤的處理）明顯更加現代化。也就是說，現在也遇到了一些相同的問題，因爲它在各種類型的應用程序中得到了廣泛的採用。

抽象級別：無服務器

’

谷歌對馴服計算環境的描述很容易被理解爲一個增加和改進抽象層的故事更高級的版本承擔了更多的管理責任，並將容器與底層環境更多地隔離。這很容易讓人覺得這是一個簡單的故事：更多的抽象是好的；更少的抽象是差的。

“”

當然，事情沒有那麼簡單。這裏的情況很複雜，有多種產品。在第頁的馴服計算環境中，我們討論了從處理在裸機上運行的寵物（無論是你的組織擁有的還是從主機託管中心租用的）到管理容器的進展情況。在這兩者之間，作爲一個替代路徑，是基於虛擬機的產品，其中虛擬機可以從更靈活地替代裸機（在基礎設施即服務產品中，如谷歌計算引擎或亞馬遜）發展到更重地替代容器（具有自動伸縮、權限調整和其他管理工具）。

’’

根據谷歌的經驗，選擇管理牛（而不是寵物）是規模管理的解決方案。重申一下，如果你的每個團隊在每個數據中心只需要一臺寵物機，那麼你的管理成本將隨着你的組織的增長而呈超線性上升（因爲團隊的數量和一個團隊所佔用的數據中心的數量都可能增長）。而在選擇了管理牛之後，容器是管理的自然選擇；它們的重量更輕（意味着更小的資源開銷和啓動時間），而且可配置，如果你需要爲特定類型的工作負載提供專門的硬件訪問，你可以（如果你選擇的話）允許輕鬆透傳通過。

虛擬機作爲牛的優勢主要在於能夠帶來我們自己的操作系統，如果你的工作環境需要一組不同的操作系統來運行，這一點很重要。多個組織在管理虛擬機、基於虛擬機的現有配置和工作負載方面也有經驗，因此可能會選擇使用虛擬機而不是容器來降低遷移成本。

什麼是無服務器？

“”“”

更高層次的抽象是無服務器產品。假設一個組織正在爲網絡內容提供服務，並且正在使用（或願意採用）一個通用的服務器框架來處理請求和提供響應。框架的關鍵定義特徵是控制權的倒置因此，用戶只負責編寫某種“”或“”所選語言中的函數，接收請求參數並返回響應。

在的世界裏，你運行這段代碼的方式是，你建立一個副本的容器，每個副本包含一個由框架代碼和你的功能組成的服務器。如果流量增加，你將通過擴大規模來處理（增加副本或擴展到新的數據中心）。如果流量減少，你將縮小規模。請注意，需要一個最小的存在（谷歌通常假設服務器運行的每個數據中心至少有三個副本）。

“”

但是，如果多個不同的團隊使用同一個框架，就可以採用不同的方法：除了使機器支持多租戶外，我們還可以使框架服務器本身支持多租戶。在這種方法中，我們最終會運行更多的框架服務器，根據需要在不同的服務器上動態加載卸載動作代碼，並將請求動態地引導到那些加載了相關動作代碼的服務器。各個團隊不再運行服務器，因此無服務器。

“”“”

大多數關於無服務器框架的討論都將其與虛擬機作爲寵物的模式相比較。在這種情況下，無服務器概念是一場真正的革命，因爲它帶來了牛羣管理的所有好處自動擴展、較低的開銷、缺乏明確的服務器配置。然而，正如前文所述，對於計劃擴展的組織來說，轉向共享、多租戶、基於牛的模式應該已經是一個目標；因此，無服務器架構的自然比較點應該是持久性容器架構，如、或。

>>>（功能即服務）和（平臺即服務）是與無服務器相關的術語。這三個術語之間有區別，但更多的是相似之處，而且邊界有些模糊不清。

利與弊

’’

首先要注意的是，無服務器架構要求你的代碼必須是真正的無狀態；我們不太可能在無服務器架構內運行你用戶的虛擬機或實現。我們之前談到的所有管理本地狀態的方法（除了不使用它）都不適用。在容器化的世界裏，你可能會在啓動時花幾秒鐘或幾分鐘的時間來設置與其他服務的連接，從冷數據中填充緩存，等等，你期望在典型情況下，在終止前會有一個寬限期。在無服務器模型中，不存在真正跨請求持久化的本地狀態；所有你想使用的東西，你都應該在請求範圍內設置。

’

在實踐中，大多數組織的需求都無法由真正的無狀態工作負載來滿足。這可能會導致依賴特定的解決方案（無論是本地的還是第三方的）來解決特定的問題（比如管理數據庫的解決方案，這是公有云無服務器產品的常見配套），或者擁有兩個解決方案：一個基於容器的解決方案和一個無服務器的解決方案。值得一提的是，許多或大多數無服務器框架是建立在其他計算層之上的。運行在上，運行在上，運行在上。

管理無服務器模式對於資源成本的適應性擴展很有吸引力，特別是在低流量的一端。在中，你的容器不能縮容到零容器（因爲假設在請求服務時間內，同時啓動容器和節點的速度太慢）。這意味着，在持久化集羣模型中，僅僅擁有一個應用程序是有最低成本的。另一方面，無服務器應用程序可以很容易地縮容到零；因此，僅僅擁有它的成本隨着流量的增加而增加。

在非常高的流量端，無論採用何種計算解決方案，你都必須受到底層基礎設施的限制。如果你的應用程序需要使用個核心來服務於它的流量，那麼在你所使用的基礎設施的任何物理設備中需要有個物理核心可用。在較低端的情況下，如果你的應用有足夠的流量讓多個服務器忙碌，但又不足以給基礎設施提供商帶來問題，那麼持久化容器解決方案和無服務器解決方案都可以擴展來處理，儘管無服務器解決方案的擴展將比持久化容器解決方案更具有高響應和細粒度。

’

最後，採用無服務器解決方案意味着在一定程度上失去了對環境的控制。在某種程度上，這是一件好事：擁有控制權意味着必須行使它，而這意味着管理開銷。但當然，這也意味着，如果你需要一些你所使用的框架中沒有的額外功能，這將成爲你的一個問題。

’

舉個具體的例子，谷歌團隊（爲數千名參賽者舉辦的編程比賽，其前端運行在谷歌上）有一個定製的腳本，在比賽開始前幾分鐘給比賽網頁帶來了人爲的流量高峯，以便爲應用程序的足夠實例預熱，爲比賽開始時的實際流量提供服務。這很有效，但這是人們希望通過選擇無服務器解決方案來擺脫的那種手工調整（也是黑客科技）。

權衡

’’’’“”

谷歌在這種權衡的選擇是不對無服務器解決方案進行大量投資。谷歌的持久化容器解決方案足夠先進，可以提供大部分無服務器的好處（比如自動伸縮、針對不同類型應用的各種框架、部署工具、統一的日誌和監控工具等等）。缺少的是更積極的擴展（特別是將規模縮小到零的能力），但谷歌的絕大部分資源足跡來自高流量服務，因此過度供應小服務的成本相對較低。同時，谷歌運行的多個應用程序在“真正無狀態”的世界中不起作用，從，到自制的數據庫系統，如或，再到需要長時間填充緩存的服務器，如上述的長尾搜索服務工作。因此，對所有這些事情采用一個共同的統一架構的好處超過了對一部分工作負載採用單獨的無服務器方向的潛在收益。

’

然而，谷歌的選擇並不一定是每個組織的正確選擇：其他組織已經成功地建立了混合容器無服務器架構，或在純粹的無服務器架構上利用第三方解決方案進行存儲。

’

然而，無服務器的主要吸引力並不是來自於一個大型組織的選擇，而是來自於一個較小的組織或團隊；在這種情況下，這種比較本身就是不公平的。無服務器模式雖然限制更大，但允許基礎設施供應商承擔更大的總體管理開銷，從而減少用戶的管理開銷。在共享的無服務器體系結構（如或的）上運行一個團隊的代碼，要比在多個團隊之間不共享集羣的情況下，在或等託管容器服務上設置集羣來運行代碼要簡單得多（而且更便宜）。如果你的團隊希望從託管計算產品中獲益，但你的公司不願意或無法轉向基於持久容器的解決方案，那麼由一家公共雲提供商提供的無服務器產品可能會對你有吸引力，因爲成本（資源和成本）很高只有當集羣真正共享（在組織中的多個團隊之間）時，共享集羣的管理才能很好地攤銷。

’

但是，請注意，隨着組織的發展和託管技術的普及，你很可能會超越純無服務器解決方案的限制。這使得存在突破路徑的解決方案（如從到）具有吸引力，因爲如果你的組織決定走這條路，它們提供了一條通向像這樣的統一計算體系結構的自然路徑。

公有與私有

當谷歌剛剛起步時，產品主要是本土產品；如果你想要一個，你就建造它。在公共空間和私有空間中，你唯一的選擇是擁有機器和租用機器，但你的集羣的所有管理都取決於你。

在公有云時代，有更便宜的選擇，但也有更多的選擇，組織必須做出選擇。

使用公共雲的機構實際上是將管理費用（部分）外包給公共雲供應商。對於許多組織來說，這是一個有吸引力的提議他們可以專注於在其特定的專業領域提供價值，而不需要增加重要的基礎架構專業知識。雖然雲供應商（當然）收取的費用超過了裸機的最低成本，以收回管理費用，但他們已經建立了專業知識，並在多個客戶之間共享。

此外，公共雲是一種更容易擴展基礎設施的方式。隨着抽象水平的提高從主機託管，到購買虛擬機時間，再到管理容器和無服務器產品擴展的難度也在增加從必須簽署主機託管空間的租賃協議，到需要運行來獲得更多的虛擬機，再到自動擴展工具，你的資源足跡隨着你收到的流量自動變化。特別是對於年輕的組織或產品，預測資源需求是具有挑戰性的，因此，不必預先配置資源的優勢是非常顯著的。

’

在選擇雲計算供應商時，一個重要的顧慮是擔心被鎖定供應商可能會突然漲價，或者直接倒閉，讓企業陷入非常困難的境地。最早的無服務器提供商之一，一個運行的平臺即服務環境，在年關閉，只提前三個月通知。

’’

對此的部分緩解措施是使用使用開源架構（如）運行的公共雲解決方案。這是爲了確保存在一個遷移路徑，即使特定的基礎設施供應商由於某種原因變得不可接受。雖然這減輕了很大一部分風險，但這並不是一個完美的策略。由於海勒姆定律，很難保證不使用特定供應商的特定部分。

這一戰略有兩種可能的擴展。一種是使用較低級別的公有云解決方案（如亞馬遜），並在其上運行較高級別的開源解決方案（如或）。這試圖確保如果你想遷移出去，你可以帶着你對高級解決方案所做的任何調整，你在它上面建立的工具，以及你擁有的隱性依賴。另一種是運行多雲；也就是說，使用基於兩個或多個不同的雲供應商的相同開源解決方案的管理服務（例如，的和）。這爲遷移出其中一個提供了更容易的路徑，同時也使你更難依賴其中一個的具體實施細節。

還有一個相關的策略不是爲了管理鎖定，而是爲了管理遷移是在混合雲中運行；也就是說，在你的私有基礎設施上有一部分整體工作負載，而在公共雲供應商上運行一部分。其中一種方法是使用公共雲來處理多出的資源需求。一個組織可以在私有云上運行其大部分典型的工作負載，但在資源短缺的情況下，將一些工作負載擴展到公共雲上。同樣，爲了使其有效運作，需要在兩個空間使用相同的開源計算基礎設施解決方案。

多雲和混合雲戰略都需要將多個環境很好地連接起來，通過不同環境中的機器之間的直接網絡連接和兩個環境中都有的通用。

總結

在構建、完善和運行計算基礎設施的過程中，谷歌認識到了設計良好的通用計算基礎設施的價值。爲整個組織提供單一的基礎設施（例如，每個區域一個或少數共享集羣）可以顯著提高管理效率和資源成本，並允許在基礎設施之上開發共享工具。在構建這樣一個體繫結構時，容器是一個關鍵工具，它允許在不同的任務之間共享物理（或虛擬）機器（從而提高資源效率），並在應用程序和操作系統之間提供一個抽象層，隨着時間的推移提供彈性。

“”

充分利用基於容器的體系結構需要設計使用“牛”模型的應用程序：將應用程序設計爲由可以輕鬆自動替換的節點組成，從而可以擴展到數千個實例。編寫與該模型兼容的軟件需要不同的思維模式；例如，將所有本地存儲（包括磁盤）視爲短暫的，並避免硬編碼主機名。

“”“”“”

這就是說，儘管谷歌總體上對其架構的選擇感到滿意並取得了成功，但其他組織將從一系列計算服務中進行選擇，從手工管理的虛擬機或機器的“寵物”模型，通過“牛”複製容器，到抽象的“無服務器”模型，所有版本都有託管和開源版本；你的選擇是許多因素的複雜權衡。

內容提要

規模化需要一個通用的基礎設施來運行生產中的工作負載。一個計算解決方案可以爲軟件提供一個標準化的、穩定的抽象和環境。軟件需要適應一個分佈式的、可管理的計算環境。組織的計算解決方案應經過深思熟慮的選擇，以提供適當的抽象級別。