第十八章構建系統，構建理念

如果你問谷歌的工程師，他們最喜歡在谷歌工作的原因（除了免費的食物和黑科技產品），你還會聽到一些令人驚訝的事情：工程師們喜歡構建系統。谷歌一直在花費了巨大的努力，從零開始創建自己的構建系統，目的是確保工程師們能夠快速、可靠地構建代碼。這一努力是成功的，構建系統的主要組件，已經被已離開公司的前谷歌員工重新實現了好幾次。年，谷歌終於公開了的一個實現，名爲。

>>>在一項內部調查中，的谷歌用戶表示對構建系統感到滿意，這使它成爲項調查中第四個最令人滿意的工具。平均工具的滿意度爲。>>>>查閱

構建系統的目的

從根上說，所有的構建系統都有一個簡單的目的：它們將工程師編寫的源代碼轉化爲機器可以讀取的可執行二進制文件。一個好的構建系統通常會試圖優化兩個重要的屬性：

快開發人員應該能夠輸入簡單的命令來運行構建並返回生成的二進制文件，而且只需幾秒鐘正確任何開發人員在任何機器上運行構建，他們都應該得到相同的結果（假設源文件和其他輸入是相同的）。

’’

許多較老的構建系統嘗試在速度和正確性之間做出權衡，採取了一些可能導致不一致的構建的捷徑。的主要目標是避免在速度和正確性之間做出選擇，提供一個結構化的構建系統，以確保總是可以高效和一致地構建代碼。

’’

’

構建系統不僅僅是爲人類服務的；它們也允許機器自動創建構建，無論是用於測試還是用於發佈到生產環境。事實上，谷歌的大部分構建都是自動觸發的，而不是由工程師點擊觸發的。我們幾乎所有的開發工具都以某種方式與構建系統相結合，爲每個在我們的代碼庫上工作的人提供了巨大的價值。以下是利用我們的自動構建系統的一小部分工作流示例：

代碼自動構建、測試並推送到生產環境，無需任何人工干預。不同的團隊以不同的頻率做這件事：有些團隊每週推送一次，有些團隊每天推送一次，有些團隊則以系統能夠創建和驗證新構建的速度推送。見第章）。開發人員的更改在發送給代碼審查時自動進行測試（參見第章），以便作者和審查人員都可以立即看到更改引起的任何構建或測試問題。。在將修改合併到主幹中之前，會立即對其進行測試，這使得提交破壞性修改變得更加困難。基礎庫的作者能夠在整個代碼庫中測試他們的修改，確保他們的修改在數百萬的測試和二進制文件中是安全的。工程師們能夠創建大規模的變更（），同時觸及數以萬計的源文件（例如，重命名公共符號），同時仍然能夠安全地提交和測試這些修改。我們將在第章中更詳細地討論。

’“”

所有這些都是由於谷歌對其構建系統的投入才得以實現。儘管谷歌的規模是獨一無二的，但任何規模的組織都可以通過正確使用現代構建系統實現類似的好處。本章介紹了認爲的現代構建系統以及如何使用這些系統。

沒有構建系統會怎樣？

’

構建系統使你的開發可擴展。正如我們將在下一節說明的那樣，我們在沒有適當的構建環境的情況下會遇到擴展問題。

但我所需要的只是一個編譯器

’

對構建系統的需求可能不是很明顯。畢竟，我們中的大多數人在最初學習編碼時可能並沒有使用構建系統我們可能一開始就直接從命令行中調用或等工具，或者在集成開發環境（）中調用相應的工具。只要我們所有的源代碼都在同一個目錄下，這樣的命令就能正常工作：

這指示編譯器把當前目錄下的每一個源文件都變成一個二進制類文件。在最簡單的情況下，這就是我們所需要的。

然而，隨着代碼的擴展，事情很快就會變得更加複雜。非常聰明，可以在我們當前目錄的子目錄中尋找我們導入的代碼。但它沒有辦法找到存儲在文件系統其他地方的代碼（也許是我們幾個項目共享的庫）。顯然，它只知道如何構建代碼。大型系統通常涉及到用各種編程語言編寫的不同部分，這些部分之間存在着依賴關係，這意味着沒有一個單一語言的編譯器可以構建整個系統。

一旦我們不得不處理來自多種語言或多個編譯單元的代碼，構建代碼就不再是一步到位的過程。我們現在需要考慮我們的代碼依賴於什麼，並以適當的順序構建這些部分，可能爲每個部分使用一套不同的工具。如果我們改變了任何依賴關係，我們需要重複這個過程，以避免依賴過時的二進制文件。對於一箇中等規模的代碼庫來說，這個過程很快就會變得乏味，並且容易出錯。

’’’

編譯器也不知道如何處理外部依賴關係，比如中的第三方文件。通常，在沒有構建系統的情況下，我們能做的最好的事情就是從網上下載依賴關係，把它放在硬盤上的文件夾裏，並配置編譯器從該目錄中讀取庫。隨着時間的推移，我們很容易忘記我們把哪些庫放在那裏，它們來自哪裏，以及它們是否仍在使用。而且，當庫的維護者發佈新的版本時，要想讓它們保持最新的狀態，那就得靠運氣了。

來自腳本的拯救？

’

’’’’’’’’’’’’’’

假設你的業餘項目開始時非常簡單，你可以只用一個編譯器來構建它，但你開始遇到前面描述的一些問題。也許你仍然認爲你不需要一個真正的構建系統，可以使用一些簡單的腳本來自動處理那些繁瑣的部分，這些腳本負責按照正確的順序構建東西。這會有一段時間的幫助，但很快你就會遇到更多的問題：

它變得乏味了。隨着你的系統越來越複雜，你開始花在構建腳本上的時間幾乎和真正的寫代碼一樣多。調試腳本是很痛苦的，越來越多的黑操作操作被疊加在一起。速度很慢。爲了確保你沒有意外地依賴過時的庫，你讓你的構建腳本在每次運行時按順序構建每個依賴。你可以考慮添加一些邏輯來檢測哪些部分需要重建，但這對於一個腳本來說聽起來非常複雜而且容易出錯。或者你可以考慮每次指定哪些部分需要重建，但是你又回到了原點。好消息是：現在是發佈的時候了最好弄清楚所有需要傳遞給命令以進行最終構建的參數。並記住如何上傳並推送到中央倉庫。構建並推送文檔更新，並向用戶發送通知。嗯，也許這需要另一個腳本災難硬盤崩潰了，現在需要重新創建整個系統。你很聰明，把所有的源文件都保存在版本控制中，但是你下載的那些庫呢？你能重新找到它們，並確保它們和你第一次下載它們時的版本相同嗎？你的腳本可能依賴於特定的工具被安裝在特定的地方你能恢復同樣的環境，使腳本再次工作嗎？那些你很久以前爲了讓編譯器工作得恰到好處而設置的環境變量，後來又忘記了，怎麼辦？儘管有這些問題，你的項目還是足於成功，以至於你能夠開始僱用更多的工程師。現在你意識到，不需要一場災難就會出現以前的問題每次有新的開發人員加入你的團隊，你都需要經歷同樣痛苦的啓動過程。而且，儘管你做了最大的努力，每個人的系統還是有小的差異。通常，在一個人的機器上起作用的東西在另一個人的機器上不起作用，每次調試工具路徑或庫版本都需要幾個小時才能找出差異所在。你決定需要自動化構建系統。從理論上講，這就像買一臺新的電腦並設置它每天晚上使用運行你的構建腳本一樣簡單。你仍然需要經歷痛苦的設置過程，但現在你沒有了需要調式檢測和解決小問題的好處。現在，每天早上當你進去的時候，你會看到昨晚的構建失敗了，因爲昨天一個開發者做了一個改變，這個改變在他們的系統上有效，但在自動構建系統上卻不起作用。每次都是一個簡單的修復，但它經常發生，以至於你每天都要花費大量時間來發現和應用這些簡單的修復。隨着項目的發展，構建的速度越來越慢。有一天，在等待構建完成時，你哀怨地注視着正在度假的同事的閒置桌面，希望有一種方法可以充分利用以前的計算能力。

’’’

你遇到了一個典型的規模問題。對於一個開發人員來說，一個編譯器就是你所需要的一切，他最多工作幾百行代碼，最多工作一兩週（這可能是一個剛從大學畢業的初級開發人員迄今爲止的全部經驗）。腳本可能會讓你走得更遠一些。但是一旦你需要在多個開發人員和他們的機器之間進行協作，即使是一個完美的構建腳本也是不夠的，因爲很難解釋這些機器中的細微差異。在這一點上，這個簡單的方法崩潰了，是時候開發一個真正的構建系統了。

現代化的構建系統

’

幸運的是，我們開始遇到的所有問題已經被現有的通用構建系統多次解決。從根本上說，它們與前面提到的基於腳本的方法沒有什麼不同：它們在後臺運行相同的編譯器，你需要了解這些底層工具，才能瞭解構建系統真正在做什麼。但是這些現有的系統已經經歷了多年的開發，使得它們比你自己嘗試破解的腳本更加健壯和靈活。

’一切都是關於依賴關係

’“”’“”“”

在回顧之前描述的問題時，有一個主題反覆出現：管理你自己的代碼是相當簡單的，但管理它的依賴關係要困難得多（第章專門詳細介紹了這個問題）。有各種各樣的依賴關係：有時依賴於任務（例如，“在我將發佈標記爲完成之前推送文檔”），有時依賴於構件（例如，“我需要最新版本的計算機視覺庫來構建代碼”）。有時，你對你的代碼庫的另一部分有內部依賴性，有時你對另一個團隊（在你的組織中或第三方）擁有的代碼或數據有外部依賴性。但無論如何，在我擁有這個之前，我需要那個的想法在構建系統的設計中反覆出現，而管理依賴性也許是構建系統最基本的工作。

基於任務的構建系統

我們在上一節開始開發的腳本是一個原始的基於任務的構建系統的示例。在基於任務的構建系統中，工作的基本單位是任務。每個任務都是某種類型的腳本，可以執行任何類型的邏輯，任務將其他任務指定爲必須在它們之前運行的依賴項。目前使用的大多數主要構建系統，如、、、和，都是基於任務的。

大多數現代構建系統要求工程師創建描述如何執行構建的構建文件，而不是腳本。以手冊中的這個例子爲例：

<><><><><><><>

<><><><><><>

<><><><>

<><><>

<><><>

<><><><><><>

<>

構建文件是用編寫的，定義了一些關於構建的簡單元數據以及任務列表（中的<>標籤）。每個任務都執行定義的一系列可能的命令，其中包括創建和刪除目錄、運行和創建文件。這組命令可以由用戶提供的插件擴展，以涵蓋任何類型的邏輯。每個任務還可以通過依賴屬性定義它所依賴的任務。這些依賴關係形成一個無環圖（見圖）。

顯示依賴關係的無環圖

’

’’

用戶通過向的命令行工具提供任務來執行構建。例如，當用戶輸入時，會採取以下步驟

在當前目錄下加載一個名爲的文件，並對其進行解析以創建圖所示的圖結構。尋找命令行上提供的名爲的任務，並發現它與名爲的任務有依賴關係。尋找名爲的任務，發現它與名爲的任務有依賴關係。查找名爲的任務並確認它沒有依賴項。執行任務中定義的命令。執行編譯任務中定義的命令，前提是該任務的所有依賴項都已運行。執行任務中定義的命令，前提是該任務的所有依賴項都已運行。

最後，在運行任務時執行的代碼相當於以下腳本：

’’

去掉語法後，構建文件和構建腳本實際上沒有太大區別。但我們這樣做已經有了很大的收穫。我們可以在其他目錄中創建新的構建文件並將它們鏈接在一起。我們可以以任意和複雜的方式輕鬆添加依賴於現有任務的新任務。我們只需要將單個任務的名稱傳遞給命令行工具，它將負責確定需要運行的所有內容。

“”

是一個非常古老的軟件，最初發佈於年而不是很多人今天會考慮的“現代”構建系統！其他工具，如和，在這幾年中對進行了改進，基本上取代了它，添加諸如自動管理外部依賴項和不使用任何的更乾淨語法等功能。但這些新系統的本質仍然是一樣的：它們允許工程師以有原則的模塊化方式編寫構建腳本作爲任務，並提供工具來執行這些任務和管理它們之間的依賴關係。

>“”“”“”“”>>用目標這個詞來表示我們在本章中所說的任務，它用任務這個詞來指代我們所說的命令。

基於任務的構建系統的缺陷

’

因爲這些工具本質上允許工程師將任何腳本定義爲一項任務，所以它們非常強大，允許你用它們做幾乎任何你能想象到的事情。但是，這種能力也有缺點，基於任務的構建系統會隨着構建腳本的日益複雜而變得難以使用。這類系統的問題是，它們實際上最終把過多的權力給工程師，而沒有把足夠的權力給系統。因爲系統不知道腳本在做什麼，性能受到影響，因爲它在調度和執行構建步驟時必須非常保守。而且，系統無法確認每個腳本都在做它應該做的事情，因此腳本往往會變得越來越複雜，最終成爲另一件需要調試的事情。

’’

並行化構建步驟的難點。現代開發工作站通常非常強大，有多個內核，理論上應該能夠並行執行幾個構建步驟。但是，基於任務的系統往往無法將任務執行並行化，即使是在看起來應該能夠做到的時候。假設任務依賴於任務和。因爲任務和彼此不依賴，所以同時運行它們是否安全，以便系統可以更快地到達任務？也許吧，如果它們不接觸任何相同的資源。但也許不是也許它們都使用同一個文件來跟蹤它們的狀態，同時運行它們會導致衝突。一般來說，系統無法知道，所以要麼它不得不冒着這些衝突的風險（導致罕見但非常難以調試的構建問題），要麼它必須限制整個構建在單個進程的單個線程上運行。這可能是對強大的開發者機器的巨大浪費，而且它完全排除了在多臺機器上分佈構建的可能性。

’’’’’’

難以執行增量構建。一個好的構建系統將允許工程師執行可靠的增量構建，這樣，一個小的變更就不需要從頭開始重建整個代碼庫了。如果構建系統由於上述原因，速度很慢，無法並行化構建步驟，那麼這一點就尤爲重要。但不幸的是，基於任務的構建系統在這裏也很困難。因爲任務可以做任何事情，一般來說，沒有辦法檢查它們是否已經完成。許多任務只是接收一組源文件並運行一個編譯器來創建一組二進制文件；因此，如果底層源文件沒有更改，則不需要重新運行。但是，如果沒有額外的信息，系統就不能確定這一點可能是任務下載了一個可能已更改的文件，或者它在每次運行時寫入了一個可能不同的時間戳。爲了保證正確性，系統通常必須在每次構建期間重新運行每個任務。

’’’

一些構建系統試圖通過讓工程師指定需要重新運行任務的條件來啓用增量構建。有時這是可行的，但通常這是一個比看起來更棘手的問題。例如，在像這樣允許文件直接被其他文件包含的語言中，如果不解析輸入源，就不可能確定必須關注的整個文件集的變化。工程師們最終往往會走捷徑，而這些捷徑會導致罕見的、令人沮喪的問題，即一個任務結果被重複使用，即使它不應該被使用。當這種情況經常發生時，工程師們就會養成習慣，在每次構建前運行，以獲得一個全新的狀態，這就完全違背了一開始就有增量構建的目的。弄清楚什麼時候需要重新運行一個任務是非常微妙的，而且是一個最好由機器而不是人處理的工作。

’’’’’’’

難以維護和調試腳本。最後，基於任務的構建系統所強加的構建腳本往往就是難以使用。儘管構建腳本通常很少受到審查，但它們與正在構建的系統一樣，都是代碼，很容易隱藏。以下是使用基於任務的構建系統時常見的一些錯誤示例：

任務依賴於任務來產生一個特定的文件作爲輸出。任務的所有者沒有意識到其他任務依賴於它，所以他們改變了它，在不同的位置產生輸出。直到有人試圖運行任務，發現它失敗了，這才被發現。任務依賴於任務，而任務依賴於任務，而任務正在產生一個任務需要的特定文件作爲輸出。任務的所有者決定它不需要再依賴於任務，這導致任務失敗，儘管任務根本不關心任務一個新任務的開發者不小心對運行該任務的機器做了一個設置，比如一個工具的位置或特定環境變量的值。該任務在他們的機器上可以運行，但只要其他開發者嘗試，就會失敗。任務包含不確定組件，例如從下載文件或向生成添加時間戳。現在，人們每次運行構建時都會得到可能不同的結果，這意味着工程師不可能總是能夠重現和修復彼此的故障或自動構建系統上發生的故障。有多個依賴關係的任務會產生競賽條件。如果任務同時依賴於任務和任務，而任務和任務同時修改同一個文件，那麼任務會得到不同的結果，這取決於任務和任務中哪一個先完成。

’’

在這裏列出的基於任務的框架中，沒有通用的方法來解決這些性能、正確性或可維護性問題。只要工程師能夠編寫在構建過程中運行的任意代碼，系統就不可能擁有足夠的信息來始終能夠快速、正確地運行構建。我們需要從工程師手中奪走一些權力，把它放回系統的手中，並重新認識到系統的作用不是作爲運行任務，而是作爲生產組件。這就是谷歌對和採取的方法，將在下一節進行描述。

基於構件的構建系統

’

爲了設計一個更好的構建系統，我們需要後退一步。早期系統的問題在於，它們讓工程師定義自己的任務，從而給了他們太多的權力。也許，我們可以不讓工程師定義任務，而是由系統定義少量的任務，讓工程師以有限的方式進行配置。我們也許可以從本章的名稱中推斷出最重要的任務的名稱：構建系統的主要任務應該是構建代碼。工程師們仍然需要告訴系統要構建什麼，但如何構建的問題將留給系統。

’“”“”

這正是和它衍生的其他基於構件的構建系統（包括、和）所採用的方法。與基於任務的構建系統一樣，我們仍然有構建文件，但這些構建文件的內容卻非常不同。在中，構建文件不是圖靈完備的腳本語言中描述如何產生輸出的命令集，而是聲明性的清單，描述一組要構建的構件、它們的依賴關係，以及影響它們如何構建的有限選項集。當工程師在命令行上運行時，他們指定一組要構建的目標（），而負責配置、運行和調度編譯步驟（）。由於構建系統現在可以完全控制什麼工具在什麼時候運行，它可以做出更有力的保證，使其在保證正確性的同時，效率也大大提高。

功能視角

’

在基於構件的構建系統和函數式編程之間做個類比是很容易的。傳統的命令式編程語言（如、和）指定了一個又一個要執行的語句列表，就像基於任務的構建系統讓程序員定義一系列的執行步驟一樣。相比之下，函數式編程語言（如和）的結構更像是一系列的數學方程。在函數式語言中，程序員描述了一個要執行的計算，但把何時以及如何執行該計算的細節留給了編譯器。這就相當於在基於構件的構建系統中聲明一個清單，並讓系統找出如何執行構建的思路。

’’

許多問題無法用函數式編程便捷表達，但那些確實從中受益匪淺的問題：函數式語言通常能夠簡單地並行這些程序，並對它們的正確性做出強有力的保證，而這在命令式語言中是不可能的。使用函數編程最容易表達的問題是使用一系列規則或函數將一段數據轉換爲另一段數據的問題。而這正是構建系統的特點：整個系統實際上是一個數學函數，它將源文件（和編譯器等工具）作爲輸入，併產生二進制文件作爲輸出。因此，圍繞函數式編程的原則建立一個構建系統並不令人驚訝。

’’

用來實現具體化。是谷歌內部構建工具的開源版本，是基於構件的構建系統的一個好例子。下面是中構建文件（通常名爲）的內容：

’’’

在中，文件定義了目標這裏的兩類目標是和。每個目標都對應於系統可以創建的構件：二進制目標產生可以直接執行的二進制文件，而庫目標產生可以被二進制文件或其他庫使用的庫。每個目標都有一個名字（它定義了它在命令行和其他目標中的引用方式）、（它定義了必須被編譯以創建目標的組件的源文件）和（它定義了必須在這個目標之前構建並鏈接到它的其他目標）。依賴關係可以是在同一個包內（例如，對的依賴），也可以是在同一個源層次結構中的不同包上（例如，對的依賴），或者是在源層次結構之外的第三方構件上（例如，對的依賴）。每個源層次結構被稱爲工作區，並通過在根部存在一個特殊的文件來識別。

’

’’’’

和一樣，用戶使用的命令行工具進行構建。爲了構建目標，用戶可以運行。在一個乾淨的版本庫中第一次輸入該命令時，會做以下工作。

解析工作區中的每個文件，以創建構件之間的依賴關係圖。使用該圖來確定的橫向依賴關係；也就是說，所依賴的每個目標以及這些目標所依賴的每個目標都是遞歸的。生成（或下載外部依賴項）每個依賴項按順序排列。首先構建沒有其他依賴項的每個目標，並跟蹤每個目標仍需要構建哪些依賴項。一旦構建了目標的所有依賴項，就會開始構建該目標。此過程一直持續到的每個可傳遞依賴項已經建成。構建，產生一個最終的可執行二進制文件，該文件鏈接了在步驟中構建的所有依賴項。

’’’

從根本上說，這裏發生的事情似乎與使用基於任務的構建系統時發生的事情沒有太大的不同。事實上，最終結果是相同的二進制文件，生成它的過程包括分析一系列步驟以找到它們之間的依賴關係，然後按順序運行這些步驟。但是有一些關鍵的區別。第一個出現在第步：因爲知道每個目標只會生成一個庫，所以它知道它所要做的就是運行編譯器，而不是任意的用戶定義腳本，所以它知道運行它是安全的。這些步驟是並行的。與在多核機器上一次構建一個目標相比，這可以產生一個數量級的性能改進，並且這是唯一可能的，因爲基於構件的方法讓構建系統負責自己的執行策略，以便它能夠對並行性做出更有力的保證。

從構件而不是任務的角度來重構構建過程是微妙而強大的。通過減少暴露在程序員面前的靈活性，構建系統可以知道更多關於在構建的每一步正在做什麼。它可以利用這些知識，通過並行化構建過程和重用其輸出，使構建的效率大大提升。但這實際上只是第一步，這些並行和重用的構件將構成分佈式和高度可擴展的構建系統的基礎，這將在後面討論。

其他有趣的技巧

’

基於構件的構建系統從根本上解決了基於任務的構建系統所固有的並行性和重用問題。但仍有一些問題在前面出現過，我們還沒有解決。有解決這些問題的聰明方法，我們應該在繼續之前討論它們。

’

工具作爲依賴項。我們之前遇到的一個問題是，構建取決於我們機器上安裝的工具，由於工具版本或位置不同，跨系統複製構建可能會很困難。當你的項目使用的語言需要根據它們在哪個平臺上構建或編譯的不同工具時（例如，與），這個問題就變得更加困難，而每個平臺都需要一套稍微不同的工具來完成同樣的工作。

解決了這個問題的第一部分，把工具當作對每個目標的依賴。工作區中的每一個都隱含地依賴於一個編譯器，它默認爲一個知名的編譯器，但可以在工作區層面進行全局配置。每當構建一個時，它都會檢查以確保指定的編譯器在已知的位置上是可用的，如果不可用，就下載它。就像其他依賴關係一樣，如果編譯器改變了，每個依賴它的構件都需要重建。在中定義的每一種類型的目標都使用這種相同的策略來聲明它需要運行的工具，確保能夠啓動它們，無論它運行的系統上存在什麼。

通過使用工具鏈解決了問題的第二部分，即平臺獨立性。與其讓目標直接依賴於它們的工具，不如說它們實際上依賴於工具鏈的類型。工具鏈包含一組工具和其他屬性，定義瞭如何在特定平臺上構建目標類型。工作區可以定義基於主機和目標平臺，爲工具鏈類型使用特定的工具鏈。有關更多詳細信息，請參閱手冊。

擴展構建系統。爲幾種流行的編程語言提供了開箱即用的能力，但工程師們總是想做得更多基於任務的系統的部分好處是它們在支持任何類型的構建過程中的靈活性，在基於構件的構建系統中最好也可以支持這一點。幸運的是，允許其支持通過添加自定義規則擴展的目標類型。

要在中定義規則，規則作者要聲明該規則需要的輸入（以文件中傳遞的屬性形式）和該規則產生的固定輸出集。作者還定義了將由該規則生成的操作。每個操作都聲明其輸入和輸出，運行特定的可執行文件或將特定字符串寫入文件，並可以通過其輸入和輸出連接到其他操作。這意味着操作是構建系統中最底層的可組合單元一個操作可以做任何它想做的事情，只要它只使用它所聲明的輸入和輸出，將負責調度動作並適當地緩存其結果。

’’’

這個系統並不是萬無一失的，因爲沒有辦法阻止操作開發者做一些事情，比如在他們的操作中引入一個不確定的過程。但這種情況在實踐中並不經常發生，而且將濫用的可能性一直推到操作層面，大大減少了錯誤的機會。支持許多常用語言和工具的規則在網上廣泛提供，大多數項目都不需要定義自己的規則。即使是那些需要定義規則的項目，規則定義也只需要在存儲庫中的一箇中心位置定義，這意味着大多數工程師將能夠使用這些規則，而不必擔心它們的實現。

’’’’

隔離環境。行動聽起來可能會遇到與其他系統中的任務相同的問題難道沒有可能寫入同時寫入同一文件並最終相互衝突的操作嗎？實際上，通過使用沙箱使這些衝突變得不可能。在支持的系統上，每個操作都通過文件系統沙盒與其他動作隔離開來。實際上，每個操作只能看到文件系統的一個有限視圖，包括它所聲明的輸入和它生成的任何輸出。這是由上的等系統強制執行的，背後的技術也是如此。這意味着操作之間不可能發生衝突，因爲它們無法讀取它們沒有聲明的任何文件，並且他們編寫但未聲明的文件將在操作完成時被丟棄。還使用沙盒來限制行動通過網絡進行通信。

’

使外部依賴性具有確定性。還有一個問題：構建系統經常需要從外部下載依賴項（無論是工具還是庫），而不是直接構建它們。這可以通過依賴項在示例中看到，該依賴項從下載文件。

’

依靠當前工作區以外的文件是有風險的。這些文件可能隨時更改，這可能需要生成系統不斷檢查它們是否是最新的。如果一個遠程文件發生了變化，而工作區的源代碼卻沒有相應的變化，這也會導致構建的不可重複性由於一個未被注意到的依賴性變化，構建可能在某一天成功，而在第二天卻沒有明顯的原因而失敗。最後，當外部依賴項屬於第三方時，可能會帶來巨大的安全風險：如果攻擊者能夠滲透到第三方服務器，他們可以用自己設計的內容替換依賴項文件，從而有可能讓他們完全控制服務器構建環境及其輸出。

“”

根本的問題是，我們希望構建系統知道這些文件，而不必將它們放入源代碼管理。更新一個依賴關係應該是一個有意識的選擇，但這個選擇應該在一箇中心位置做出，而不是由個別工程師管理或由系統自動管理。這是因爲即使是模式，我們仍然希望構建是確定性的，這意味着如果你檢查出上週的提交，你應該看到你的依賴關係是當時的，而不是現在的。

’

和其他一些構建系統通過要求一個工作區範圍的清單文件來解決這個問題，該文件列出了工作區中每個外部依賴項的加密哈希。每當從工作區引用一個新的外部依賴關係時，該依賴關係的哈希值就會被手動或自動添加到清單中。運行構建時，會將其緩存的依賴關係的實際哈希值與清單中定義的預期哈希值進行對比，只有在哈希值不同時纔會重新下載文件。

>>>這種“軟件供應鏈”攻擊越來越普遍。>>>>最近增加了對使用完全相同系統的模塊的初步支持。

’’

如果我們下載的構件與清單中聲明的哈希值不同，除非更新清單中的哈希值，否則構建將失敗。這可以自動完成，但在構建接受新的依賴關係之前，這一變化必須得到批准並檢查到源代碼控制中。這意味着總是有依賴關係更新的記錄，如果工作區源代碼沒有相應的變化，外部依賴關係就不會改變。這也意味着，當簽出一箇舊版本的源代碼時，構建保證使用與簽入該版本時相同的依賴關係（否則，如果這些依賴關係不再可用，它將失敗）。

’’

當然，如果一個遠程服務器變得不可用或開始提供損壞的數據，這仍然是一個問題如果沒有該依賴項的另一個副本可用，這可能會導致所有構建開始失敗。爲了避免這個問題，我們建議，對於任何不重要的項目，你應該把所有的依賴關係鏡像到你信任和控制的服務器或服務上。否否則，構建系統的可用性將始終取決於第三方，即使簽入哈希保證了其安全性。

分佈式構建

’’’’’’

谷歌的代碼庫非常龐大有超過億行的代碼，依賴關係鏈可以變得非常深。在谷歌，即使是簡單的二進制文件也常常依賴於成千上萬個構建目標。在這種規模下，要在一臺機器上以合理的時間完成構建是根本不可能的：任何構建系統都無法繞過強加給機器硬件的基本物理定律。唯一的辦法是使用支持分佈式構建的構建系統，其中系統所完成的工作單元分佈在任意數量且可擴展的機器上。假設我們把系統的工作分解成足夠小的單位（後面會有更多介紹），這將使我們能夠以我們可以根據支付的費用來獲得想要的速度完成任何規模的構建。

’

通過定義基於構件的構建系統，這種可伸縮性是我們一直致力於實現的法寶。

遠程緩存

最簡單的分佈式構建類型是隻利用遠程緩存的構建，如圖所示。

’

每個執行構建的系統，包括開發人員工作站和連續集成系統，都共享對公共遠程緩存服務的引用。這個服務可能是一個高速的本地短期存儲系統，如，或一個雲服務，如谷歌雲存儲。每當用戶需要構建一個構件時，無論是直接構建還是作爲一個依賴，系統首先檢查遠程緩存，看該構件是否已經存在。如果存在，它可以下載該構件而不是構建它。如果沒有，系統會自己構建構件，並將結果上傳到緩存中。這意味着不經常更改的低級依賴項可以構建一次並在用戶之間共享，而不必由每個用戶重新構建。在谷歌，許多構件是從緩存中提供的，而不是從頭開始構建的，這大大降低了我們運行構建系統的成本。

爲了使遠程緩存系統發揮作用，構建系統必須保證構建是完全可重複的。也就是說，對於任何構建目標，必須能夠確定該目標的輸入集，以便相同的輸入集在任何機器上產生完全相同的輸出。這是確保下載構件的結果與自己構建構件的結果相同的唯一方法。幸運的是，提供了這種保證，因此支持遠程緩存。請注意，這要求緩存中的每個構件都以其目標和輸入的哈希值爲關鍵這樣，不同的工程師可以在同一時間對同一目標進行不同的修改，而遠程緩存將存儲所有結果的構件，並適當地爲它們提供服務，而不會產生衝突。

’

當然，要想從遠程緩存中獲得任何好處，下載構件的速度必須比構建它的速度快。但情況並非總是如此，尤其是當緩存服務器遠離進行構建的機器時。谷歌的網絡和構建系統是經過精心調整的，能夠快速分享構建結果。在組織中配置遠程緩存時，請注意考慮網絡延遲，並進行實驗以確保緩存實際上正在提高性能

遠程構建

’

遠程緩存不是真正的分佈式構建。如果緩存丟失或者進行了需要重建所有內容的低級更改，那麼仍然需要在計算機上本地執行整個構建。遠程緩存並不是一個真正的分佈式構建。如果緩存丟失了，或者如果你做了一個低級別的改變，需要重建所有的東西，你仍然需要在你的機器上執行整個構建。真正的目標是支持遠程執行，在這種情況下，進行構建的實際工作可以分散到任何數量的機器上。圖（）描述了一個遠程執行系統。

’

在每個用戶的機器上運行的構建工具（用戶可以是工程師，也可以是自動構建系統）向中央構建主控器發送請求。構建主機將請求分解爲組件操作，並在可擴展的機器資源池上安排這些操作的執行。每個機器根據用戶指定的輸入執行所要求的操作，並寫出結果的構件。這些構件在執行需要它們的操作的其他機器之間共享，直到可以生成最終輸出併發送給用戶。

’’’’

實現這樣一個系統最棘手的部分是管理員、主站和用戶的本地機器之間的通信。某臺構建機器可能依賴於其他機器產生的中間構件，而最終輸出需要發送回用戶的本地機器。要做到這一點，我們可以建立在前面描述的分佈式緩存之上，讓每個構建機器將其結果寫入緩存並從緩存中讀取其依賴項。主模塊阻止構建程序繼續工作，直到它所依賴的一切完成，在這種情況下，它將能夠從緩存中讀取它的輸入。最終的產品也被緩存起來，允許本地機器下載它。請注意，我們還需要一種單獨的方法來導出用戶源樹中的本地更改，以便構建機器可以在構建之前應用這些更改。

要做到這一點，前面描述的基於構件的構建系統的所有部分都需要結合起來。構建環境必須是完全自描述的，這樣我們就可以在沒有人爲干預的情況下提高構建的速度。構建過程本身必須是完全自包含的，因爲每個步驟可能在不同的機器上執行。輸出必須是完全確定的，這樣每個構建機器就可以相信它從其他構建機器那裏得到的結果。樣的保證對於基於任務的系統來說是非常困難的，這使得在一個系統之上構建一個可靠的遠程執行系統幾乎是不可能的。

谷歌的分佈式構建。自年以來，谷歌一直在使用分佈式構建系統，該系統同時採用了遠程緩存和遠程執行，如圖（）所示。

’

’’’

谷歌的遠程緩存被稱爲。它包括一個將構建輸出存儲在的後端，分佈在我們的生產機羣中，以及一個運行在每個開發人員機器上的名爲的前端守護程序。守護進程允許工程師瀏覽構建輸出，就像它們是存儲在工作站上的普通文件一樣，但文件內容僅針對用戶直接請求的少數文件按需下載。按需提供文件內容大大減少了網絡和磁盤的使用，系統的構建速度是將所有構建輸出存儲在開發人員的本地磁盤上時的兩倍。

’

谷歌的遠程執行系統被稱爲。在中，一個名爲的客戶端將每個操作的請求發送到數據中心中名爲調度器。調度器維護操作結果的緩存，允許它在操作已經由系統的任何其他用戶創建時立即返回響應。如果沒有，它就把操作放到一個隊列中。大量執行器作業從該隊列中連續讀取操作，執行它們，並將結果直接存儲在中。這些結果可供執行者用於將來的操作，或由最終用戶通過下載。

’

最終的結果是一個可擴展的系統，能夠有效地支持在谷歌執行的所有構建。谷歌構建的規模確實是巨大的：谷歌每天運行數以百萬計的構建，執行數以百萬計的測試用例，並從數十億行源代碼中產生數的構建輸出。這樣一個系統不僅讓我們的工程師快速構建複雜的代碼庫，還讓我們能夠實現大量依賴我們構建的自動化工具和系統。我們爲開發這個系統付出了多年的努力，但現在開源工具已經很容易獲得，這樣任何組織都可以實現類似的系統。雖然部署這樣一個構建系統可能需要時間和精力，但最終的結果對工程師來說確實是神奇的，而且通常是值得付出努力的。

時間、規模、權衡

’

構建系統都是爲了使代碼更易於大規模和長期使用。就像軟件工程一樣，在選擇使用哪種構建系統時也存在權衡。使用腳本或直接調用工具的方法只適用於不需要長時間處理代碼更改的最小項目，或者適用於具有內置構建系統的等語言。

’

選擇基於任務的構建系統而不是依賴腳本可以極大地提高項目的可擴展性，允許你自動完成複雜的構建，並更容易在不同的機器上覆制這些構建。權衡之下，你需要真正開始考慮構建是如何構造的，並處理編寫構建文件的開銷（儘管自動化工具通常可以幫助解決這個問題）。對於大多數項目來說，這種權衡是值得的，但對於特別瑣碎的項目（例如，那些包含在單一源文件中的項目），開銷可能不會給你帶來太多好處。

’’

隨着項目規模的進一步擴大，基於任務的構建系統開始遇到一些基本問題，而這些問題可以通過使用基於構件的構建系統來彌補。這樣的構建系統開啓了一個全新的規模，因爲巨大的構建現在可以分佈在許多機器上，成千上萬的工程師可以更確定他們的構建是一致的和可重複的。就像本書中的許多其他主題一樣，這裏的權衡是缺乏靈活性：基於構件的系統不允許你用真正的編程語言編寫通用任務，而要求你在系統的約束範圍內工作。對於那些從一開始就被設計爲與基於構件的系統一起工作的項目來說，這通常不是一個問題，但是從現有的基於任務的系統遷移可能是困難的，而且如果構建在速度或正確性方面還沒有出現問題的話，這並不總是值得的。

’

對一個項目的構建系統進行修改代價耿是昂貴的，而且隨着項目的擴大，成本也會增加。這就是爲什麼谷歌認爲，幾乎每一個新項目從一開始就可以從這樣的基於構件的構建系統中獲益。在谷歌內部，從微小的實驗性項目到谷歌搜索，基本上所有的代碼都是用構建的。

處理模塊和依賴關係

像這樣使用基於構件的構建系統的項目被分解成一系列模塊，模塊之間通過文件表達彼此的依賴關係。適當地組織這些模塊和依賴關係，對構建系統的性能和維護的工作量都有很大的影響。

使用細粒度模塊和規則

“”’

構建基於構件的構建時出現的第一個問題是決定單個模塊應該包含多少功能。在中，一個是由一個指定可構建單元的目標表示的，如或。在一個極端，整個項目可以包含在一個單一的中，方法是把一個文件放在根部，然後遞歸地把該項目所有的源文件放在一起。在另一個極端，幾乎每一個源文件都可以成爲自己的模塊，有效地要求每個文件在文件中列出它所依賴的每個其他文件。

’’

大多數項目都介於這兩個極端之間，這種選擇涉及到性能和可維護性之間的權衡。在整個項目使用一個模塊可能意味着除了添加外部依賴項時，你永遠不需要更改構建文件，但這意味着構建系統將始終需要一次構建整個項目。這意味着它將無法並行化或分發構建的一部分，也無法緩存已經構建的部分。每個文件一個模塊的情況正好相反：構建系統在緩存和安排構建步驟方面有最大的靈活性，但工程師需要花費更多的精力來維護依賴關係的列表，無論何時他們改變哪個文件引用哪個文件。

雖然精確的顆粒度因語言而異（甚至在語言內部也是如此），但谷歌傾向於使用比通常在基於任務的構建系統中編寫的模塊小得多的模塊。在谷歌，一個典型的生產二進制文件可能會依賴於數以萬計的目標構件，甚至一箇中等規模的團隊也可能在其代碼庫中擁有數百個目標。對於像這樣有強大的內置打包概念的語言，每個目錄通常包含一個單獨的包、目標和文件（另一個基於的構建系統稱之爲規則）。封裝約定較弱的語言通常會爲每個構建文件定義多個目標。

’

較小的構建目標的好處真正開始在規模上表現出來，因爲它們可以支持更快的分佈式構建和更少的重建目標的需要。當測試進入畫面後，這些優勢變得更加引人注目，因爲更細粒度的目標意味着構建系統可以更智能地只運行可能受任何給定更改影響的有限測試子集。由於谷歌相信使用較小目標的系統性好處，我們通過開發自動管理構建文件的工具，在減輕不利影響方面取得了一些進展，以避免打擾開發人員。其中許多工具現在都是開源的。

最小化模塊可見性

和其他構建系統允許每個目標指定可見性：一個屬性，指定哪些其他目標可能依賴它。目標可以是公共的，在這種情況下，它們可以被工作區中的任何其他目標引用；，在這種情況下，它們只能從同一構建文件中引用；或僅對明確定義的其他目標列表可見。可見性本質上與依賴性相反：如果目標想要依賴於目標，目標必須使自己對目標可見。

’’’

就像在大多數編程語言中，通常最好方法是儘可能地減少可見性。一般來說，谷歌的團隊只有在這些目標代表了谷歌任何團隊都可以使用的廣泛使用的庫時，纔會將目標公開。要求其他人在使用代碼之前與他們協調的團隊將保留一份客戶目標白名單，作爲其目標的可見性。每個團隊的內部實施目標將被限制在該團隊所擁有的目錄中，而且大多數文件將只有一個非私有的目標。

管理依賴關係

模塊需要能夠相互引用。將代碼庫分解爲細粒度模塊的缺點是需要管理這些模塊之間的依賴關係（儘管工具可以幫助實現自動化）。表達這些依賴關係通常會成爲文件中的大部分內容。

內部依賴關係

’“”

在細分爲細粒度模塊的大型項目中，大多數依賴關係可能是內部的；也就是說，在同一源存儲庫中定義和構建的另一個目標上。內部依賴項與外部依賴項的不同之處在於，它們是從源代碼構建的，而不是在運行構建時作爲預構建構件下載的。這也意味着內部依賴項沒有“版本”的概念目標及其所有內部依賴項始終在存儲庫中的同一提交修訂中構建。

關於內部依賴關係，應該小心處理的一個問題是如何處理可傳遞依賴關係（圖）。假設目標依賴於目標，而目標依賴於一個共同的庫目標，那麼目標是否應該使用目標中定義的類？

’’’

就底層工具而言，這沒有問題；和在構建目標時都會鏈接到目標中，因此中定義的任何符號都會被知道。允許這一點很多年了，但隨着谷歌的發展，我們開始發現問題。假設被重構，不再需要依賴。如果對的依賴關係被刪除，和通過對的依賴關係使用的任何其他目標都將中斷。實際上，一個目標的依賴關係成爲其公共契約的一部分，永遠無法安全地更改。這意味着依賴性會隨着時間的推移而積累，谷歌的構建速度開始變慢。

“”’’

谷歌最終解決了這個問題，在中引入了一個嚴格傳遞依賴模式。在這種模式下，檢測目標是否嘗試引用符號而不直接依賴它，如果是，則失敗，並顯示錯誤和可用於自動插入依賴項的命令。在谷歌的整個代碼庫中推廣這一變化，並重構我們數百萬個構建目標中的每一個，以以明確列出它們的依賴關係，這是一項多年的努力，但這是非常值得的。現在我們的構建速度快多了，因爲目標的不必要的依賴性減少了，工程師有權刪除他們不需要的依賴關係，而不用擔心破壞依賴它們的目標。

’’

像往常一樣，強制執行嚴格的可傳遞依賴關係需要權衡。它使構建文件更加冗長，因爲現在需要在許多地方明確列出常用的庫，而不是附帶地將其拉入，而且工程師需要花更多的精力將依賴關係添加到文件中。我們後來開發了一些工具，通過自動檢測許多缺失的依賴關係並將其添加到文件中，而不需要任何開發人員的干預，從而減少了這項工作。但即使沒有這樣的工具，我們也發現，隨着代碼庫的擴展，這樣的權衡是非常值得的：明確地在文件中添加一個依賴關係是一次性的成本，但是隻要構建目標存在，處理隱式傳遞依賴項就可能導致持續的問題。對代碼強制執行嚴格的可傳遞依賴項。

>>>當然，實際上刪除這些依賴項是一個完全獨立的過程。但要求每個目標明確聲明它使用了什麼是關鍵的第一步。請參閱第章，瞭解更多關於谷歌如何做出如此大規模改變的信息。

外部依賴

’’

如果一個依賴性不是內部的，它一定是外部的。外部依賴關係是指在構建系統之外構建和存儲的構件上的依賴關係。依賴關係直接從構件庫（通常通過互聯網訪問）導入，並按原樣使用，而不是從源代碼構建。外部依賴和內部依賴的最大區別之一是，外部依賴有版本，這些版本獨立於項目的源代碼而存在。

“”“”

自動與手動依賴管理。構建系統可以允許手動或自動管理外部依賴的版本。當手動管理時，構建文件明確列出它要從構件庫中下載的版本，通常使用語義版本字符串，如。當自動管理時，源文件指定了一個可接受的版本範圍，並且構建系統總是下載最新的版本。例如，允許將依賴版本聲明爲，以指定只要主要版本是，那麼依賴的任何次要或補丁版本都是可以接受的。

’’’’

自動管理的依賴關係對於小項目來說是很方便的，但對於規模不小的項目或由多名工程師負責的項目來說，它們通常是帶來災難。自動管理的依賴關係的問題是，你無法控制版本的更新時間。沒有辦法保證外部各方不會進行破壞性的更新（即使他們聲稱使用了語義版本管理），所以前一天還能正常工作的構建，第二天就可能被破壞，而且沒有便捷的方法來檢測什麼變化或將其恢復到工作狀態。即使構建沒有被破壞，也可能有一些細微的行爲或性能變化，而這些變化是無法追蹤的。

’

相比之下，由於手動管理的依賴關係需要改變源碼控制，它們可以很容易地被發現和回滾，而且有可能檢查出較早版本的存儲庫，用較早的依賴關係進行構建。要求手動指定所有依賴關係的版本。即使是中等規模，手動版本管理的開銷對於它提供的穩定性來說也是非常值得的。

’’

一個版本的規則。一個庫的不同版本通常由不同的構件來代表，所以在理論上，沒有理由不能在構建系統中以不同的名稱聲明相同外部依賴的不同版本。這樣，每個目標都可以選擇要使用哪個版本的依賴項。谷歌發現這在實踐中會造成很多問題，因此我們在內部代碼庫中對所有第三方依賴項實施嚴格的一個版本規則。

’’

允許多版本的最大問題是鑽石依賴性問題。假設目標依賴於目標和外部庫的。如果以後對目標進行重構以添加對同一外部庫的的依賴，則目標將中斷，因爲它現在隱式地依賴於同一庫的兩個不同版本。實際上，將新的依賴項從目標添加到任何具有多個版本的第三方庫永遠都不安全，因爲該目標的任何用戶都可能已經依賴於不同的版本。遵循“一個版本”規則使此衝突不可能發生如果目標在第三方庫上添加依賴項，則任何現有依賴項都將在同一版本上，因此它們可以愉快地共存。

’

我們將在第章中結合大型單體的情況進一步研究這個問題。

可傳遞的外部依賴。處理外部依賴的可傳遞依賴可能特別困難。許多構件庫（如）允許構件指定對倉庫中其他構件的特定版本的依賴性。像或這樣的構建工具通常會默認遞歸地下載每個橫向依賴，這意味着在你的項目中添加一個依賴可能會導致總共下載幾十個構件。

’’’’

這非常方便：在新庫上添加依賴項時，必須跟蹤該庫的每個可傳遞依賴項並手動添加它們，這將是一個很大的麻煩。但也有一個巨大的缺點：因爲不同的庫可能依賴於同一第三方庫的不同版本，所以這種策略必然違反一個版本規則，並導致鑽石依賴問題。如果你的目標依賴於使用同一依賴項的不同版本的兩個外部庫，則無法確定你將獲得哪一個。這也意味着，如果新版本開始引入其某些依賴項的衝突版本，更新外部依賴項可能會導致整個代碼庫中看似無關的故障。

’’’

因此，不會自動下載可傳遞依賴項。。而且，不幸的是，沒有銀彈的替代方案是需要一個全局文件，列出版本庫的每一個外部依賴，以及整個版本庫中用於該依賴的明確版本。幸運的是，提供的工具能夠自動生成這樣一個文件，其中包含一組構件的可傳遞依賴項。該工具可以運行一次，爲項目生成初始文件，然後可以手動更新該文件，以調整每個依賴的版本。

然而，這裏的權衡是在便捷性和可擴展性之間。小型項目可能更願意不必擔心管理可傳遞依賴本身，並且可能可以不使用自動可傳遞依賴。隨着組織和代碼庫的增長，這種策略越來越沒有吸引力，衝突和意外結果也越來越頻繁。在更大的範圍內，手動管理依賴關係的成本遠遠低於處理自動依賴關係管理所引起的問題的成本。

使用外部依賴性緩存構建結果。外部依賴最常由發佈穩定版本庫的第三方提供，可能沒有提供源代碼。一些組織可能也會選擇將他們自己的一些代碼作爲構件來提供，允許其他代碼作爲第三方依賴它們，而不是內部依賴。如果構件的構建速度慢但下載速度快，理論上這可以加快構建速度。

然而，這也帶來了很多開銷和複雜性：需要有人負責構建每一個構件，並將它們上傳到構件庫，而客戶需要確保它們保持最新的版本。調試也變得更加困難，因爲系統的不同部分將從存儲庫中的不同點構建，並且不再有源代碼樹的一致視圖。

解決構建構建時間過長問題的更好方法是使用支持遠程緩存的構建系統，如前所述。這樣的構建系統將把每次構建產生的構件保存到工程師共享的位置，所以如果一個開發者依賴於最近由其他人構建的構件，構建系統將自動下載它而不是構建它。這提供了直接依賴構件的所有性能優勢，同時確保構建的一致性，就像它們總是從同一個源構建一樣。這是谷歌內部使用的策略，可以配置爲使用遠程緩存。

’’’

外部依賴的安全性和可靠性。依賴第三方來源的構件本身是有風險的。如果第三方來源（例如估計庫）發生故障，就會有可用性風險，因爲如果你無法下載外部依賴，整個構建可能會停止。還有一個安全風險：如果第三方系統被攻擊者破壞了，攻擊者可以用他們自己設計的構件來替換引用的構件，允許他們在你的構建中注入任意代碼。

這兩個問題都可以通過將你依賴的構件鏡像到你控制的服務器上，並阻止你的構建系統訪問第三方構件庫（如）來緩解。權衡之下，這些鏡像需要花費精力和資源來維護，所以是否使用這些鏡像往往取決於項目的規模。安全問題也可以通過要求在源碼庫中指定每個第三方構件的哈希值來完全避免，如果構件被篡改，則會導致構建失敗。

’’’’’

另一個完全避開這個問題的辦法是你項目的依賴關係。當項目提供其依賴項時，它會將它們與項目源代碼一起作爲源代碼或二進制文件檢查到源代碼管理中。這實際上意味着該項目所有的外部依賴被轉換爲內部依賴。谷歌在內部使用這種方法，將整個谷歌引用的每一個第三方庫檢查到谷歌源碼樹根部的第三方目錄中。然而，這在谷歌是可行的，因爲谷歌的源碼控制系統是定製的，可以處理一個非常大的，所以對於其他組織來說，可能不是一個選項。

總結

’

構建系統是一個工程組織中最重要的部分之一。每個開發人員每天可能要與它互動幾十次或幾百次，在許多情況下，它可能是決定他們生產率的限制性步驟。這意味着，值得花時間和精力把事情做好。

’’“”

正如本章所討論的，谷歌學到的一個更令人驚訝的教訓是，限制工程師的權力和靈活性可以提高他們的生產力。我們能夠開發出一個滿足我們需求的構建系統，並不是通過讓工程師自由決定如何進行構建，而是通過開發一個高度結構化的框架，限制個人的選擇，並將最有趣的決策留給自動化工具。不管你怎麼想，工程師們對此並不反感：喜歡這個系統主要靠自己工作，讓他們專注於編寫應用程序的有趣部分，而不是糾結於構建邏輯。能夠信任構建是一個強大的增量構建，而且幾乎不需要清除構建緩存或運行“清理”步驟。

’

我們接受了這一觀點，並利用它創建了一種全新的基於構件的構建系統，與傳統的構建系統形成對比。這種以構件爲中心而不是以任務爲中心的構建重構，使我們的構建能夠擴展到一個與谷歌規模相當的組織。在極端情況下，它允許一個分佈式構建系統，能夠利用整個計算集羣的資源來加速工程師的生產力。雖然你的組織可能還沒有大到可以從這樣的投資中獲益，但我們相信，基於構件的構建系統會隨着規模的擴大而縮小：即使對於小型項目，像這樣的構建系統也可以在速度和正確性方面帶來顯著的好處。

’

本章的其餘部分探討了如何在一個基於構件的系統中管理依賴關係。我們得出的結論是：細粒度的模塊比粗粒度的模塊更容易擴展。我們還討論了管理依賴版本的困難，描述了一個版本規則，以及所有的依賴都應該手動和明確的版本的觀點。這樣的做法可以避免像鑽石依賴問題這樣的常見陷阱，並允許代碼庫在一個具有統一構建系統的單一存儲庫中實現谷歌數萬億行代碼的規模。

內容提要

一個功能齊全的構建系統對於保持開發人員在組織規模擴大時的生產力是必要的。權力和靈活性是有代價的。適當地限制構建系統可以使開發人員更容易地使用它。