第十二章單元測試

’

上一章介紹了谷歌對測試進行分類的兩個主要軸線：大小和範圍。簡而言之，大小是指測試所消耗的資源和允許做的事情，範圍是指測試要驗證多少代碼。雖然谷歌對測試規模有明確的定義，但範圍往往是比較模糊的。我們使用術語單元測試指的是範圍相對較窄的測試，如單個類或方法的測試。單元測試通常是小規模的，但並不總是如此。

’

’’’’’

在實現防止之後，測試最重要的目的是提高工程師的生產效率。與範圍更廣的測試相比，單元測試有許多特性，使其成爲優化生產效率的絕佳方式

根據谷歌對測試規模的定義，它們往往是小型的。小型測試是快速和確定的，允許開發人員頻繁地運行它們，作爲他們工作流程的一部分，並獲得即時反饋。單元測試往往很容易與正在測試的代碼同時編寫，允許工程師將他們的測試集中在他們正在工作的代碼上，而不需要建立和理解一個更大的系統。單元測試促進高水平的測試覆蓋率，因爲它們快速且易於編寫。高測試覆蓋率使工程師能夠滿懷信心地進行更改，確保他們不會破壞任何東西。由於每個單元測試在概念上都很簡單，並且都集中在系統的特定部分，因此，它們往往會使人們很容易理解失敗時的錯誤。它們可以作爲文檔和例子，向工程師展示如何使用被測試的系統部分，以及該系統的預期工作方式。

’

由於單元測試有很多優點，在谷歌寫的大多數測試都是單元測試，作爲經驗法則，我們鼓勵工程師把的單元測試和的範圍更廣的測試混合起來。這個建議，再加上編寫單元測試的簡易性和運行速度，意味着工程師要運行多個單元測試一個工程師在平均工作日中執行數千個單元測試（直接或間接）是很正常的。

’“”’

因爲測試在工程師的生活中佔了很大一部分，所以谷歌非常重視測試的可維護性。可維護的測試是那些正常工作的測試：在寫完測試後，工程師不需要再考慮它們，直到它們失敗，而這些失敗表明有明確原因的真正錯誤。本章的主要內容是探討可維護性的概念和實現它的技術。

可維護性的重要性

’

想象一下這個場景：希望向產品添加一個簡單的新功能，並且能夠快速實現它，可能只需要幾十行代碼。但是，當她去檢查她的改動，她從自動測試系統那裏得到了滿屏的錯誤。她花了一天的時間來逐一檢查這些錯誤。在每種情況下，更改都沒有引入實際的，但打破了測試對代碼內部結構的一些設定，需要更新這些測試。通常情況下，她很難弄清楚這些測試一開始要做什麼，而她爲修復它們而添加的黑操作使得這些測試在以後更難理解。最終，本來應該是一份快速的工作，結果卻要花上幾個小時甚至幾天的時間忙碌，扼殺了的工作效率，消磨了她的士氣。

’

在這裏，測試產生了與預期相反的效果，它消耗了生產力，而不是提高生產效率，同時沒有顯著提高被測試代碼的質量。這種情況太普遍了，谷歌工程師每天都在與之鬥爭。沒有什麼靈丹妙藥，但谷歌的許多工程師一直在努力開發一套模式和實踐來緩解這些問題，我們鼓勵公司的其他人效仿。

’

遇到的問題不是她的錯，而且她也沒有辦法避免這些問題：糟糕的測試必須在出現之前被修復，以免它們給未來的工程師帶來阻力。概括地說，她遇到的問題分爲兩類。首先，她所使用的測試是很脆弱的：它們在應對一個無害的、不相關的變化時，沒有引入真正的而損壞。第二，測試不明確：在測試失敗後，很難確定哪裏出了問題，如何修復它，以及這些測試最初應該做什麼。

預防脆性測試

’“”

正如剛纔所定義的，脆性測試是指在面對不相關的程序代碼變化時失敗的測試，這些變化不會引入任何真正的錯誤。在只有幾個工程師的小型代碼庫中，每次修改都要調整一些測試，這可能不是一個大問題。但是，如果一個團隊經常寫脆弱測試，測試維護將不可避免地消耗團隊越來越多的時間，因爲他們不得不在不斷增長的測試套件中梳理越來越多的失敗。如果一套測試需要工程師爲每一個變化進行手動調整，稱其爲自動化測試套件就有點牽強了！

’’

脆弱測試在任何規模的代碼庫中都會造成痛苦，但在谷歌的規模中，它們變得尤爲嚴重。一個單獨的工程師在工作過程中，可能在一天內就會輕易地運行數千個測試，而一個大規模的變化（見第章）可能會引發數十萬個測試。在這種規模下，即使是影響一小部分測試的誤報故障也會浪費大量的工程時間。谷歌的團隊在測試套件的脆弱性方面存在很大差異，但我們已經確定了一些實踐和模式，這些實踐和模式傾向於使測試變得更健壯，更易於更改。

>>注意，這與不穩定測試略有不同，不穩定測試是在不改變生產代碼的情況下非確定性地失敗。

力求穩定的測試

’’

在討論避免脆性測試的模式之前，我們需要回答一個問題：編寫測試後，我們應該多久更改一次測試？任何花在更新舊測試上的時間都不能花在更有價值的工作上。因此，理想的測試是不變的：在編寫之後，它永遠不需要更改，除非被測系統的需求發生變化。

’’’’’’’

’’

’

’’’’’

這在實踐中是什麼樣子的呢？我們需要考慮工程師對生產代碼所做的各種修改，以及我們應該如何期望測試對這些修改做出反應。從根本上說，有四種更改：

純粹的重構當工程師在不修改系統接口的情況下重構系統內部時，無論是出於性能、清晰度還是任何其他原因，系統的測試都不需要更改。在這種情況下，測試的作用是確保重構沒有改變系統的行爲。在重構過程中需要改變的測試表明，要麼變化影響了系統的行爲，不是純粹的重構，要麼測試沒有寫在適當的抽象水平上。依靠大規模的變化（在第章中描述）來做這樣的重構，使得這種情況對我們特別重要。

新功能當工程師向現有系統添加新的功能或行爲時，系統的現有行爲應該不受影響。工程師必須編寫新的測試來覆蓋新的行爲，但他們不應該需要改變任何現有的測試。與重構一樣，在添加新功能時，對現有測試的改變表明該功能的非預期後果或不適當的測試。

修復修復與添加新功能很相似：的存在表明初始測試套件中缺少一個案例，修復應該包括缺少的測試案例。同樣，錯誤修復通常不需要對現有的測試進行更新。

行爲改變當我們期望必須對系統的現有測試進行更新時，更改系統的現有行爲就是一種情況。請注意，這種變化往往比其他三種類型的測試代價要高得多。系統的用戶可能依賴於其當前行爲，而對該行爲的更改需要與這些用戶進行協調，以避免混淆或中斷。在這種情況下改變測試表明我們正在破壞系統的一個明確的契約，而在前面的情況下改變則表明我們正在破壞一個非預期的契約。基礎類庫往往會投入大量的精力來避免需要進行行爲的改變，以免破壞他們的用戶。

’’’’

啓示是，在編寫測試之後，在重構系統、修復或添加新功能時，不需要再次接觸該測試。這種理解使大規模使用系統成爲可能：擴展系統只需要寫少量的與你所做的改變有關的新測試，而不是可能要觸動所有針對該系統寫過的測試。只有對系統行爲的破壞性更改才需要返回以更改其測試，在這種情況下，更新這些測試的成本相對於更新所有系統用戶的成本往往很小。

通過公共進行測試

’’’

現在我們瞭解了我們的目標，讓我們看看一些做法，以確保測試不需要改變，除非被測試系統的需求改變。到目前爲止，確保這一點的最重要的方法是編寫測試，以與用戶相同的方式調用正在測試的系統；也就是說，針對其公共而不是其實現細節進行調用。如果測試的工作方式與系統的用戶相同，根據定義，破壞測試的變化也可能破壞用戶。作爲一個額外的好處，這樣的測試可以作爲用戶的有用的例子和文檔。

考慮例，它驗證了一個事務並將其保存到數據庫中。

實例事務

<

“”

測試這段代碼的一個誘人的方法是去掉私有可見修飾符，直接測試實現邏輯，如例所示。

’例事務實現的簡單測試

’’’’

此測試與事務處理器的交互方式與其實際用戶的交互方式大不相同：它窺視系統的內部狀態並調用系統中未公開的方法。因此，測試是脆弱的，幾乎任何對被測系統的重構（例如重命名其方法、將其分解爲輔助類或更改序列化格式）都會導致測試中斷，即使此類更改對類的實際用戶是不可見的。

’

相反，同樣的測試覆蓋率可以通過只測試類的公共來實現，如例所示。

例測試公共

’

根據定義，僅使用公共的測試是以與用戶相同的方式訪問被測系統。這樣的測試更現實，也不那麼脆弱，因爲它們形成了明確的契約：如果這樣的測試失敗，它意味着系統的現有用戶也將失敗。只測試這些契約意味着你可以自由地對系統進行任何內部重構，而不必擔心對測試進行繁瑣的更改。

>”>>這有時被稱爲“使用前門優先原則”

’“”“”“”’’“”

什麼是公共並不總是很清楚，這個問題實際上涉及到單元測試中的單元的核心。單元可以小到一個單獨的函數，也可以大到由幾個相關的包模塊組成的集合。當我們在這裏說公共時，我們實際上是在談論該單元暴露給擁有該代碼的團隊之外的第三方的。這並不總是與某些編程語言提供的可見性概念一致；例如，中的類可能將自己定義爲公共，以便被同一單元中的其他包所訪問，但並不打算供該單元之外的其他方使用。有些語言，如，沒有內置的可見性概念（通常依靠慣例，如在私有方法名稱前加上下劃線），而像這樣的構建系統可以進一步限制誰可以依賴編程語言所聲明的公共。

“”’“”’’

爲一個單元定義一個合適的範圍，因此應該將其視爲公共，這與其說是科學，不如說是藝術，但這裏有一些經驗法則：

如果一個方法或類的存在只是爲了支持一兩個其他的類（即，它是一個輔助類），它可能不應該被認爲是自己的單元，它的功能測試應該通過這些類進行，而不是直接測試它。

如果一個包或類被設計成任何人都可以訪問，而不需要諮詢其所有者，那麼它幾乎肯定構成了一個應該直接測試的單元，它的測試以用戶的方式訪問該單元。

如果一個包或類只能由擁有它的人訪問，但它的設計目的是提供在各種上下文中有用的通用功能（即，它是一個“支持庫”），也應將其視爲一個單元並直接進行測試。這通常會在測試中產生一些冗餘，因爲支持庫的代碼會被它自己的測試和用戶的測試所覆蓋。然而，這種冗餘可能是有價值的：如果沒有它，如果庫的一個用戶（和它的測試）被刪除，測試覆蓋率就會出現缺口。

’’’’

在谷歌，我們發現工程師有時需要被說服，通過公共進行測試比針對實現細節進行測試要好。這種不情願的態度是可以理解的，因爲寫測試的重點往往是你剛剛寫的那段代碼，而不是弄清楚這段代碼是如何影響整個系統的。然而，我們發現鼓勵這種做法是很有價值的，因爲額外的前期努力在減少維護負擔方面得到了許多倍的回報。針對公共的測試並不能完全防止脆弱性，但這是你能做的最重要的事情，以確保你的測試只在系統發生有意義的變化時才失敗。

測試狀態，而不是交互

測試通常依賴於實現細節的另一種方法不是測試調用系統的哪些方法，而是如何驗證這些調用的結果。通常，有兩種方法可以驗證被測系統是否按預期運行。通過狀態測試，你觀察系統本身，看它在調用後是什麼樣子。通過交互測試，你要檢查系統是否對其合作者採取了預期的行動序列以響應調用它。許多測試將執行狀態和交互驗證的組合。

’

交互測試往往比狀態測試更脆弱，測試一個私有方法比測試一個公共方法更脆的原因相同：交互測試檢查系統是如何得到結果的，而通常你只應該關心結果是什麼。例展示了一個測試，它使用一個測試替換（在第章中進一步解釋）來驗證一個系統如何與數據庫交互。

例脆弱性相互作用測試

該測試驗證了對數據庫的特定調用，但有兩種不同的方法可能會出錯：

如果被測系統中的錯誤導致記錄在寫入後不久從數據庫中刪除，那麼即使我們希望它失敗，測試也會通過。如果對被測系統進行重構，以調用稍有不同的來編寫等效記錄，那麼即使我們希望測試通過，測試也會失敗。

’

如例所示，直接對系統的狀態進行測試就不那麼脆弱了。

例針對狀態的測試

這種測試更準確地表達了我們所關心的：被測系統與之交互後的狀態。

交互測試出現問題的最常見原因是過度依賴框架。這些框架可以很容易地創建測試替換，記錄並驗證針對它們的每個調用，並在測試中使用這些替換來代替真實對象。這種策略直接導致了脆弱的交互測試，因此我們傾向於使用真實對象而不是模擬對象，只要真實對象是快速和確定的。

編寫清晰的測試

’

’

總有一天，即使我們已經完全避免了脆弱性，我們的測試也會失敗。失敗是一件好事測試失敗爲工程師提供了有用的信號，也是單元測試提供價值的主要方式之一。測試失敗有兩個原因：

被測系統有問題或不完整。這個結果正是測試的設計目的：提醒你注意，以便你能修復它們。測試本身是有缺陷的。在這種情況下，被測系統沒有任何問題，但測試的指定是不正確的。如果這是一個現有的測試，而不是你剛寫的測試，這意味着測試是脆弱的。上一節討論瞭如何避免脆性測試，但很少有可能完全消除它們。

’’’’

當測試失敗時，工程師的首要工作是確定失敗屬於哪種情況，然後診斷出實際問題。工程師定位問題的速度取決於測試的清晰程度。清晰的測試是指工程師在診斷故障時，立即明確其存在目的和故障原因的測試。如果測試失敗的原因不明顯，或者很難弄清楚最初寫這些測試的原因，那麼測試就無法達到清晰的效果。清晰的測試還能帶來其他的好處，比如記錄被測系統，更容易作爲新測試的基礎。

’’

隨着時間的推移，測試的清晰度變得非常重要。測試往往比編寫測試的工程師的時間更長，而且隨着時間的推移，對系統的要求和理解會發生微妙的變化。一個失敗的測試完全有可能是多年前由一個已經不在團隊中的工程師寫的，沒有辦法弄清楚其目的或如何修復它。這與不明確的生產代碼形成了鮮明的對比，你通常可以通過查看調用代碼的內容和刪除代碼後的故障來確定其目的。對於一個不明確的測試，你可能永遠不會明白它的目的，因爲刪除該測試除了（潛在地）在測試覆蓋率中引入一個細微的漏洞之外沒有任何影響。

’

在最壞的情況下，這些晦澀難懂的測試最終會被刪除，因爲工程師不知道如何修復它們。刪除這些測試不僅會在測試覆蓋率上帶來漏洞，而且還表明該測試在其存在的整個期間（可能是多年）一直提供零價值。

’

爲了使測試套件能夠隨時間擴展並變得有用，套件中的每個測試都儘可能清晰是很重要的。本節探討了爲實現清晰性而考慮測試的技術和方法。

>“”>>這也是測試可能“不穩定”的兩個原因。要麼被測系統存在不確定性故障，要麼測試存在缺陷，以至於在通過測試時有時會失敗。

確保你的測試完整和簡明

幫助測試實現清晰的兩個高級屬性是完整性和簡潔性。一個測試是完整的，當它的主體包含讀者需要的所有信息，以瞭解它是如何得出結果的。當一個測試不包含其他分散注意力的或不相關的信息時，它就是簡潔的。例顯示了一個既不完整也不簡潔的測試：

例一個不完整且雜亂的測試

測試將大量不相關的信息傳遞給構造函數，測試的實際重要部分隱藏在輔助方法中。通過澄清輔助方法的輸入，可以使測試更加完整，通過使用另一個輔助隱藏構建計算器的無關細節，可以使測試更加簡潔，如示例所示。

實例完整且簡潔的測驗

’’

我們稍後討論的觀點，特別是圍繞代碼共享，將與完整性和簡潔性掛鉤。需要注意的是，如果能使測試更清晰，違反（不要重複自己）原則通常是值得的。記住：一個測試的主體應該包含理解它所需要的所有信息，而不包含任何無關或分散的信息。

測試行爲，而不是方法

許多工程師的第一直覺是試圖將他們的測試結構與他們的代碼結構相匹配，這樣每個產品方法都有一個相應的測試方法。這種模式一開始很方便，但隨着時間的推移，它會導致問題：隨着被測試的方法越來越複雜，它的測試也越來越複雜，變得越來越難以理解。例如，考慮例中的代碼片段，它顯示了一個事務的結果。

例一個事務片段

<’

如例所示，一個測試涵蓋了該方法可能顯示的兩個信息，這並不罕見。

例方法驅動的測試

’

對於這樣的測試，很可能一開始測試只包括第一個方法。後來，當第二條信息被添加進來時，工程師擴展了測試（違反了我們前面討論的穩定的測試理念）。這種修改開創了一個不好的先例：隨着被測方法變得越來越複雜，實現的功能越來越多，其單元測試也會變得越來越複雜，越來越難以使用。

’“”“”“”“”

問題是，圍繞方法測試框架自然會鼓勵不清晰測試，因爲單個方法經常在背後下做一些不同的事情，可能有幾個棘手的邊緣和角落的情況。有一個更好的方法：與其爲每個方法寫一個測試，不如爲每個行爲寫一個測試。行爲是一個系統對它在特定狀態下如何響應一系列輸入的任何保障。鑑於一個銀行賬戶是空的，當試圖從該賬戶中取錢時，該交易被拒絕。方法和行爲之間的映射是多對多的：大多數不重要的方法實現了多個行爲，一些行爲依賴於多個方法的交互。前面的例子可以用行爲驅動的測試來重寫，如例所介紹。

例行爲驅動的測試

拆分單個測試所需的額外模板文件非常值得，並且最終的測試比原來測試更清晰。行爲驅動測試往往比面向方法的測試更清晰，原因有幾個。首先，它們閱讀起來更像自然語言，讓人們自然地理解它們，而不需要語言繁瑣的心理分析。其次，它們更清楚地表達了因果關係，因爲每個測試的範圍都更有限。最後，每個測試都很短且描述性強，這一事實使我們更容易看到已經測試了哪些功能，並鼓勵工程師添加新的簡潔測試方法，而不是堆積在現有方法上。

>>>見和。>>>>此外，一個特徵（在這個詞的產品意義上）可以被表達爲一組行爲。

強調行爲的結構測試

“”“”“”

將測試視爲與行爲而非方法相耦合會顯著影響測試的結構。請記住，每個行爲都有三個部分：一個是定義系統如何設置的組件，一個是定義對系統採取的行動的組件，以及一個驗證結果的組件。當此結構是顯式的時，測試是最清晰的。一些框架（如和）直接加入了的功能支持。其他語言可以使用空格和可選註釋使結構突出，如示例所示。

例一個結構良好的測試

’’

’

這種程度的描述在瑣碎的測試中並不總是必要的，通常省略註釋並依靠空白來使各部分清晰。然而，明確的註釋可以使更復雜的測試更容易理解。這種模式使我們有可能在三個層次的粒度上閱讀測試

讀者可以從測試方法的名稱開始（下面討論），以獲得對被測試行爲的粗略描述。如果這還不夠，讀者可以查看註釋，以獲得行爲的正式描述。最後，讀者可以查看實際代碼，以準確地看到該行爲是如何表達的。

“”“”“”“”

最常見的違反模式是在對被測系統的多個調用之間穿插斷言（即，組合“”和“”塊）。以這種方式合併和塊會使測試不那麼清晰，因爲它使人們難以區分正在執行的操作和預期結果。

’“”

當一個測試確實想驗證一個多步驟過程中的每個步驟時，定義塊的交替序列是可以接受的。長的區塊也可以用字來分割，使其更具描述性。例顯示了一個相對複雜的、行爲驅動的測試是什麼樣子的。

例在一個測試中交替使用塊

’“”“”

在編寫這種測試時，要注意確保你不會無意中同時測試多個行爲。每個測試應該只覆蓋一個行爲，絕大多數的單元測試只需要一個和一個塊。

>“”“”“”>>這些組成部分有時被稱爲安排、行動和斷言。

以被測試的行爲命名測試

’’’

面向方法的測試通常以被測試的方法命名（例如，對方法的測試通常稱爲）。對於更加集中的行爲驅動的測試，我們有更多的靈活性，並有機會在測試的名稱中傳達有用的信息。測試名稱非常重要：它通常是失敗報告中第一個或唯一一個可見的標記，所以當測試中斷時，它是你溝通問題的最好機會。它也是表達測試意圖的最直接的方式。

’

測試的名字應該概括它所測試的行爲。一個好的名字既能描述在系統上採取的行動，又能描述預期的結果。測試名稱有時會包括額外的信息，如系統或其環境的狀態。一些語言和框架允許測試相互嵌套，並使用字符串命名，例如例，其中使用了，這樣做比其他語言和框架更容易。

例一些嵌套命名模式的例子

其他語言要求我們在方法名中編碼所有這些信息，導致方法的命名模式如例所示。

例一些示例方法的命名模式

’

像這樣的名字比我們通常爲產品代碼中的方法所寫的要囉嗦得多，但使用情況不同：我們從來不需要寫代碼來調用這些方法，而且它們的名字經常需要由人類在報告中閱讀。因此，額外的言辭是有必要的。

’’“”“”“”’’

許多不同的命名策略是可以接受的，只要它們在一個測試類中使用一致。如果你陷入困境，一個好的技巧是嘗試用應當這個詞來開始測試名稱。當與被測類的名稱一起使用時，這種命名方案允許將測試名稱作爲一個句子來閱讀。例如，一個名爲的類的測試可以被理解爲不應該允許在餘額爲空時提款。通過閱讀套件中所有測試方法的名稱，你應該對被測系統實現的行爲有一個很好的瞭解。這樣的名字也有助於確保測試集中在單個行爲上：如果你需要在測試名稱中使用這個詞，很有可能你實際上是在測試多個行爲，應該寫多個測試

’不要把邏輯放進測試中

’’

清晰的測試在檢查時通常是正確的；也就是說，很明顯，只要看一眼，測試就做了正確的事情。這在測試代碼中是可能的，因爲每個測試只需要處理一組特定的輸入，而產品代碼必須被泛化以處理任何輸入。對於產品代碼，我們能夠編寫測試，確保複雜的邏輯是正確的。但測試代碼沒有那麼奢侈如果你覺得你需要寫一個測試來驗證你的測試，那就說明出了問題！這是不可能的。

’

複雜性最常以邏輯的形式引入。邏輯是通過編程語言的指令部分來定義的，如運算符、循環和條件。當一段代碼包含邏輯時，你需要做一些心理預期來確定其結果，而不是僅僅從屏幕上讀出來。不需要太多的邏輯就可以使一個測試變得更難理解。例如，例中的測試在你看來是否正確？

例掩蓋的邏輯

’

這裏沒有什麼邏輯：實際上只是一個字符串連接。但是，如果我們通過刪除這一點邏輯來簡化測試，一個錯誤就會立即變得清晰，如例所示。

例沒有邏輯的測試揭示了

’

當寫出整個字符串時，我們可以立即看到，我們期望中有兩個斜槓，而不是一個。如果產品代碼犯了類似的錯誤，此測試將無法檢測到錯誤。重複基本是爲了使測試更具描述性和意義而付出的小代價（見本章後面關於與測試的討論）。

’’

如果人類不善於發現來自字符串連接的錯誤，那麼我們更不善於發現來自更復雜的編程結構的錯誤，如循環和條件。這個教訓很清晰：在測試代碼中，堅持使用直線代碼而不是複雜的邏輯，並在測試更具描述性的時候考慮容忍一些重複。我們將在本章後面討論關於重複和代碼共享的想法。

給出清晰的失敗信息

’

清晰度的最後一個方面與測試的編寫方式無關，而是與工程師在測試失敗時看到的信息有關。在一個理想的世界裏，工程師可以通過閱讀日誌或報告中的失敗信息來診斷一個問題，而不需要看測試本身。一個好的故障信息包含與測試名稱相同的信息：它應該清楚地表達預期結果、實際結果和任何相關的參數。

’

下面是一個糟糕失敗消息的示例：

’

測試失敗是因爲帳戶已關閉，還是因爲帳戶預期將關閉，而測試失敗是因爲帳戶未關閉？一條更好的失敗消息清楚地將預期狀態與實際狀態區分開來，並提供有關結果的更多上下文：

<

好的庫可以幫助我們更容易寫出有用的失敗信息。考慮一下例中測試中的斷言，第一個斷言使用了經典的斷言，第二個斷言使用了，一個由開發的斷言庫：

例使用庫的斷言

<>

“”’<>”

因爲第一個斷言只接收一個布爾值，所以它只能給出一個通用的錯誤信息，如預期，但得到的是，這在失敗的測試輸出中不是很有意義。因爲第二個斷言明確地接收斷言的主題，它能夠給出一個更有用的錯誤信息。<>應該包含。

並非所有的語言都有這樣的輔助工具，但總是可以手動指定失敗信息中的重要信息。例如，中的測試斷言通常看起來像例。

例中的測試斷言

測試和代碼共享：，而不是

“’”

編寫清晰的測試和避免脆弱性的最後一個方面與代碼共享有關。大多數軟件都試圖實現一個稱爲的原則“不要重複你自己。”指出，如果每個概念都在一個地方被規範地表示，並且代碼重複保持在最低限度，那麼軟件就更容易維護。這種方法在簡化更改方面尤其有用，因爲工程師只需要更新一段代碼，而不需要跟蹤多個引用。。這種合併的缺點是，它可能會使代碼變得不清楚，需要讀者跟隨引用鏈來理解代碼在做什麼。

’’’

在通常的產品代碼中，爲了使代碼更容易修改和使用，這種缺點通常是一個很小的代價。但是這種成本效益分析在測試代碼的背景下有一點不同。好的測試被設計成穩定的，事實上，當被測試的系統發生變化時，你通常希望它們會被破壞。因此，當涉及到測試代碼時，並沒有那麼多的好處。同時，對於測試來說，複雜性的成本更高：產品代碼具有測試套件的優勢，可以確保它在變得複雜時繼續工作，而測試必須獨立進行，如果它們不明顯正確，則可能出現錯誤。如前所述，如果測試變得足夠複雜，以至於感覺需要自己的測試來確保它們正常工作，那麼就會出現問題。

“”

與其說是完全的，不如說測試代碼應該經常努力做到也就是提倡描述性和有意義的短語。在測試中，一點點的重複是可以的，只要這種重複能使測試更簡單、更清晰。爲了說明這一點，例介紹了一些過於的測試。

例一個過於的測試

<>

<>

<><><>

<>

<>

’’

基於前面對清晰度的討論，這段代碼中的問題應該是顯而易見的。首先，儘管測試主體非常簡潔，但它們並不完整：重要的細節被隱藏在輔助方法中，讀者如果不滾動到文件的完全不同部分就看不到這些方法。那些輔助方法也充滿了邏輯，使它們更難以一目瞭然地驗證（你發現了這個錯誤嗎？）當它被改寫成使用時，測試就變得清晰多了，如例所示。

例測試應該是

’

這些測試有更多的重複，測試體也有點長，但額外的言辭是值得的。每個單獨的測試都更有意義，不離開測試主體就可以完全理解。這些測試的讀者可以確信，這些測試做了他們聲稱要做的事情，並且沒有隱藏任何。

’

不是的替代品；它是對的補充。輔助方法和測試基礎設施仍然可以幫助使測試更清晰，使其更簡潔，剔除重複的步驟，其細節與被測試的特定行爲不相關。重要的一點是，這樣的重構應該着眼於使測試更有描述性和意義，而不是僅僅以減少重複的名義進行。本節的其餘部分將探討跨測試共享代碼的常見模式。

共享值

許多測試的結構是通過定義一組測試使用的共享值，然後通過定義測試來涵蓋這些值如何交互的各種情況。例說明了此類測試的模樣。

例名稱不明確的共享值

’

此策略可以使測試非常簡潔，但隨着測試套件的增長，它會導致問題。首先，很難理解爲什麼選擇某個特定值進行測試。在示例中，幸運的是，測試名稱澄清了正在測試的場景，但你仍然需要向上滾動到定義，以確認和適用於這些場景。更具描述性的常量名稱（例如，和）有一些幫助，但它們仍然使查看被測試值的確切細節變得更加困難，並且重用這些值的方便性可以鼓勵工程師這樣做，即使名稱不能準確描述測試需要什麼。

工程師通常傾向於使用共享常量，因爲在每個測試中構造單獨的值可能會很冗長。實現此目標的更好方法是使用輔助方法（參見示例）構造數據，該方法要求測試作者僅指定他們關心的值，併爲所有其他值設置合理的默認值。在支持命名參數的語言中，這種構造非常簡單，但是沒有命名參數的語言可以使用構建器模式等構造來模擬它們（通常需要等工具的幫助）：

例使用輔助方法的共享值

’

使用輔助方法來構建這些值，允許每個測試創建它所需要的精確值，而不必擔心指定不相關的信息或與其他測試衝突。

>’’>>在許多情況下，甚至可以對未顯式設置的字段返回的默認值進行輕微的隨機化。這有助於確保兩個不同的實例不會意外地比較爲相等，並使工程師更難硬編碼對默認值的依賴關係。

共享設置

’

測試共享代碼的相關方法是通過設置初始化邏輯。許多測試框架允許工程師在運行套件中的每個測試之前定義要執行的方法。如果使用得當，這些方法可以避免重複繁瑣和不相關的初始化邏輯，從而使測試更清晰、更簡潔。如果使用不當，這些方法會在單獨的初始化方法中隱藏重要細節，從而損害測試的完整性。

’

設置方法的最佳用例是構造被測試對象及其合作者們。當大多數測試不關心用於構造這些對象的特定參數，並且可以讓它們保持默認狀態時，這非常有用。同樣的想法也適用於測試替換的打樁返回值，這是一個我們在第章中詳細探討的概念。

“”

使用設置方法的一個風險是，如果這些測試開始依賴於設置中使用的特定值，它們可能導致測試不明確。例如，例中的測試似乎不完整，因爲測試的讀者需要去尋找字符串“”的來源。

例設置方法中對數值的依賴性

像這樣明確關心特定值的測試應該直接說明這些值，如果需要的話，可以覆蓋方法中定義的默認值。如例所示，所產生的測試包含了稍多的重複，但其結果是更有描述性和意義的。

例重寫設置方法中的值

共享輔助和驗證

“”

最後一種在測試中共享代碼的常見方式是通過從測試方法主體中調用輔助方法。我們已經討論了輔助方法如何成爲簡明地構建測試值的有用方法這種用法是有必要的，但其他類型的輔助方法可能是危險的。

一種常見的輔助工具是對被測系統執行一套共同的斷言的方法。極端的例子是在每個測試方法的末尾調用一個驗證方法，它對被測系統執行一組固定的檢查。這樣的驗證策略可能是一個不好的習慣，因爲使用這種方法的測試是較少的行爲驅動。有了這樣的測試，就更難確定任何特定測試的意圖，也更難推斷出作者在編寫測試時到底想到了什麼情況。當被引入時，這種策略也會使它們更難被定位，因爲它們會經常導致大量的測試開始失敗。

然而，更有針對性的驗證方法仍然是有用的。最好的驗證輔助方法只斷言其輸入的一個概念性事實，與涵蓋一系列條件的通用驗證方法相反。當他們驗證的條件在概念上很簡單，但需要循環或條件邏輯來實現，如果將其包含在測試方法的主體中，就會降低清晰度，這樣的方法特別有用。例如，例中的輔助方法在測試中可能很有用，它涵蓋了圍繞賬戶訪問的幾種不同情況。

例概念上簡單的測試

界定測試基礎框架

’

到目前爲止，我們討論的技術包括在單個測試類或測試套件中跨方法共享代碼。有時，跨多個測試套件共享代碼也很有價值。我們將這種代碼稱爲測試基礎框架。儘管它通常在集成或端到端測試中更有價值，但精心設計的測試基礎框架可以使單元測試在某些情況下更易於編寫。

’

自定義測試基礎框架必須比在單個測試套件中發生的代碼共享更謹慎地對待。在許多方面，測試基礎框架的代碼比其他測試代碼更類似於產品代碼，因爲它可能有許多依賴它的調用者，並且在不引入破壞的情況下很難改變。大多數工程師不應該在測試他們自己的功能時對通用測試基礎框架進行修改。測試基礎框架需要被當作自己獨立的產品，相應地，測試基礎框架必須始終有自己的測試。

’

當然，大多數工程師使用的測試基礎框架都是以知名的第三方庫的形式出現的，如。有大量這樣的庫可以使用，在一個組織內對它們進行標準化應該儘可能早地和普遍地發生。例如，多年前規定是新的測試中唯一應該使用的模擬框架，並禁止新的測試使用其他模擬框架。這一規定在當時引起了一些對其他框架感到滿意的人的不滿，但今天，人們普遍認爲這是一個好的舉措，使我們的測試更容易理解和使用。

單元測試是我們作爲軟件工程師所擁有的最強大的工具之一，它可以確保我們的系統在面對意料之外的變化時仍能正常工作。但是，強大的力量伴隨着巨大的責任，不小心使用單元測試會導致系統需要更多的努力來維護，需要更多的努力來更改，不然不會真正提高我們對所述系統的信心。

’’’

谷歌的單元測試遠非完美，但我們發現遵循本章所述做法的測試比那些不遵循的測試要有價值得多。我們希望它們能幫助你提高你自己的測試的質量。

內容提要

’

努力實現穩定的測試。

通過公共進行測試。

測試狀態，而不是交互。

使你的測試完整和簡明。

測試行爲，而不是方法。

強調行爲的結構測試。

使用被測試的行爲來命名測試。

不要把邏輯放在測試中。

編寫清晰的失敗信息。

在共享測試的代碼時，遵循而不是。