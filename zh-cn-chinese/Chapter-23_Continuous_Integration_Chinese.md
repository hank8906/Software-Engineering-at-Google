第二十三章持續集成

“”

持續集成，或，通常被定義爲一種軟件開發實踐，團隊成員經常集成他們的工作每個集成都由自動構建（包括測試）來驗證，以儘快發現集成錯誤。簡單地說，的基本目標是儘可能早地自動捕獲有問題的變化。

“”’’

在實踐中，頻繁地集成工作對於現代的、分佈式的應用程序意味着什麼？今天的系統除了存儲庫中最新版本的代碼外，還有許多可變動的部分。事實上，隨着近來的微服務趨勢，破壞應用程序的變化不太可能存在於項目的即時代碼庫中，而更可能存在於網絡調用的另一端的鬆散耦合的微服務中。傳統的持續構建是測試二進制文件的變更，而其延伸則是測試上游微服務的變化。依賴關係只是從你的函數調用棧轉移到請求或遠程過程調用（）。

“”

甚至在代碼依賴關係之外，應用程序可能會定期接收數據或更新機器學習模型。它可能在不斷發展的操作系統、運行時、雲託管服務和設備上執行。它可能是位於不斷變化的平臺之上的功能，也可能是必須適應不斷變化的功能基礎的平臺。所有這些都應該被視爲依賴關係，我們也應該致力於“持續集成”它們的變化。更復雜的是，這些變化的組件通常由我們團隊、組織或公司之外的開發人員擁有，並按照他們自己的時間表部署。

>

’

因此，在當今世界，特別是在大規模開發時，對更好的定義也許是以下幾點：

持續集成：對我們整個複雜和快速發展的生態系統進行持續的組裝和測試。

’’

從測試的角度對進行思考是很自然的，因爲兩者緊密結合，我們將在本章中這樣做。在前面的章節中，我們討論了一系列全面的測試，從單元到集成，再到更大範圍的系統。

從測試的角度來看，是一種範式，可以告知以下內容：

在開發發佈工作流程中，由於代碼（和其他）變化不斷地被集成到其中，在什麼時候運行哪些測試。如何在每個點上組成被測系統（），平衡仿真度和設置成本等問題。

例如，我們在預提交上運行哪些測試，在提交後保存哪些測試，哪些甚至要保存到我們的臨時部署？因此，我們如何在這些點上表示？正如你所想象的，預提交的需求可能與測試中的部署環境的需求有很大的不同。例如，從預提交的待審代碼構建的應用程序與真正的生產後端對話可能是危險的（考慮安全和配額漏洞），而這對於臨時環境來說通常是可以接受的。

“”“”’

爲什麼我們要嘗試用來優化在正確的時間測試正確的事情的這種往往很微妙的平衡？這些結果是由一個強有力的保證所驅動的：可驗證的、及時的、可證明應用程序可以進入下一階段的證明。我們不需要僅僅希望所有的貢獻者都非常謹慎、負責和閉環；相反，我們可以保證我們的應用程序在從構建到發佈的各個階段的工作狀態，從而提高對我們產品的信心和質量以及我們團隊的生產力。

’’

在本章的其餘部分中，我們將介紹一些關鍵概念、最佳實踐和挑戰，然後介紹我們如何在管理，並介紹我們的持續構建工具，以及對某個應用程序的轉換的深入研究。

>>>，等人（年）。加速：精益軟件科學和：建立和擴展高性能技術組織。這是一場革命。

概念

’

首先，讓我們先看看的一些核心概念。

快速反饋迴路

正如第章所討論的，一個被捕獲的時間越晚，其成本幾乎呈指數增長。圖顯示了有問題的代碼更改在其生命週期中可能出現的所有位置。

“”

一般來說，隨着問題向我們圖中的右側發展，它們的成本會變得更高，原因如下：

它們必須由可能不熟悉問題代碼更改的工程師來處理。這些問題需要代碼修改者做更多的工作來回憶和調查這些修改。它們會對其他人產生負面影響，無論是工作中的工程師還是最終的終端用戶。

爲了使的代價最小化，鼓勵我們使用快速反饋環。每次我們將代碼（或其他）變化集成到測試場景中並觀察結果時，我們就會得到一個新的反饋迴路。反饋可以有很多形式；下面是一些常見的形式（按從快到慢的順序）

本地開發的編輯編譯調試迴路在提交前向代碼修改者提供自動測試結果兩個項目變更之間的集成錯誤，在兩個項目一起提交和測試後檢測（即提交後）。當上遊服務部署其最新變化時，我們的項目和上游微服務的依賴關係之間的不兼容，由我們臨時環境中的測試員發現。在外部用戶之前使用功能的內部用戶的錯誤報告外部用戶或媒體的錯誤或故障報告

>“”>>這有時也被稱爲測試左移。

金絲雀或者先部署到一小部分生產，可以有助於最小化降低進入生產的問題，在所有生產之前先部署一部分生產初始反饋迴路。但是，金絲雀部署也會導致新的問題，尤其是在同時部署多個版本時，部署之間的兼容性問題。這有時被稱爲版本傾斜，分佈式系統的一種狀態，其中包含多個不兼容的代碼、數據和或配置版本。就像我們在本書中看到的許多問題一樣，版本傾斜是另一個在嘗試開發和管理軟件時可能出現的具有挑戰性的問題的例子。

實驗特性標誌是非常強大的反饋迴路。它們通過隔離模塊化組件中可以在生產中動態切換的更改來降低部署風險。嚴重依賴功能標誌保護是持續交付的常見範例，我們將在第章中進一步探討。

可獲取和可操作的反饋

’’

同樣重要的是，來自的反饋可以被廣泛獲取。除了我們圍繞代碼可見性的開放文化之外，我們對我們的測試報告也有類似的方式。我們有一個統一的測試報告系統，任何人都可以很容易地查看構建或測試運行，包括所有的日誌（不包括用戶的個人身份信息），無論是個人工程師的本地運行還是自動化開發或分段構建。

’’

除了日誌，我們的測試報告系統還提供了構建或測試目標開始失敗的詳細歷史記錄，包括每次運行時在何處剪切構建、在何處運行以及由誰執行的審計日誌。我們還有一個鬆散分類系統，該系統使用統計數據在谷歌範圍內對薄片進行分類，因此工程師不需要自己來確定他們的更改是否破壞了另一個項目的測試（如果測試是鬆散：可能不是）。

對測試歷史的可視性使工程師能夠就反饋進行共享和協作，這是不同團隊診斷和學習系統間集成故障的基本要求。類似地，谷歌的（如罰單或問題）是開放的，有完整的評論歷史供所有人查看和學習（客戶除外）。

’

最後，來自測試的任何反饋不僅應該是可訪問的，而且應該是可操作的易於用來發現和修復問題。我們將在本章後面的案例研究中看一個改進用戶不友好反饋的例子。通過改善測試輸出的可讀性，你可以自動理解反饋。

自動化

’

衆所周知，從長遠來看，開發相關任務的自動化可以節省工程資源。直觀地說，因爲我們通過將流程定義爲代碼來實現自動化，所以在修改時的同行評審將減少錯誤的概率。當然，自動化流程，像其他軟件一樣，會有錯誤；但如果有效地實施，它們仍然比工程師手動嘗試更快，更容易，更可靠。

’

特別是，它使構建和發佈過程自動化，有持續構建和持續交付。持續測試貫穿始終，我們將在下一節中介紹。

連續構建

“”“”

持續構建（）集成了最新的代碼修改，並運行自動構建和測試。因爲在運行測試的同時也在構建代碼，破壞構建或構建失敗包括破壞測試和破壞編譯。

“”’

提交變更後，應運行所有相關測試。如果更改通過了所有測試，會將其標記爲通過或綠色，因爲它通常顯示在用戶界面（）中。該流程有效地在報告中引入了兩種不同版本的：真實或已提交的最新變更，以及綠色或已驗證的最新變更。工程師可以在本地開發中同步到任一版本。在編寫變更代碼時，通常會與綠色同步，以便在穩定的環境中工作，並經驗證，但有一個流程要求在提交變更之前將變更同步到真實。

連續交付

持續交付（；在第章中詳細討論）的第一步是發佈自動化，它不斷地將最新的代碼和配置從組裝成候選發佈版本。在谷歌，大多數團隊都是在綠色（而不是真正的）進行切割。

候選版本（）由自動化流程創建的內聚、可部署單元，由通過持續構建的代碼、配置和其他依賴關係組成。

’

請注意，我們在候選版本中包含了配置這一點極爲重要，儘管在候選版本的推廣過程中，不同環境下的配置會略有不同。我們不一定提倡你把配置編譯到你的二進制文件中事實上，我們建議在許多情況下使用動態配置，如實驗或特徵標誌。

“”’

相反，我們的意思是，你所擁有的任何靜態配置都應該作爲候選版本的一部分進行升級，以便它可以與其對應的代碼一起接受測試。記住，很大比例的生產錯誤是由愚蠢的配置問題引起的，所以測試你的配置和測試你的代碼一樣重要（而且要和將要使用它的相同代碼一起測試）。在這個發佈候選推廣的過程中，經常會出現版本傾斜。當然，這是假設你的靜態配置是在版本控制中的在谷歌，靜態配置是和代碼一起在版本控制中的，因此要經過同樣的代碼審查過程。

那麼我們對的定義如下

持續交付（）：持續集合候選版本，然後在一系列環境中推廣和測試這些候選版本有時達到生產階段，有時不達到生產階段。

’

升級和部署過程通常取決於團隊。我們將展示我們的案例研究如何引導這一過程。

’

對於谷歌的團隊來說，他們希望從生產中的新變化（例如，持續部署）中獲得持續的反饋，通常不可能持續地將整個二進制文件（通常相當大）推到綠色上。因此，通過實驗或特性標誌進行選擇性連續部署是一種常見的策略。

當一個在各種環境中發展，它的構建（如二進制文件、容器）最好不要被重新編譯或重建。使用像這樣的容器有助於在不同的環境中強制執行的一致性，從本地開發開始。同樣，使用像這樣的協調工具（或者在我們的例子中，通常是），有助於強制執行部署之間的一致性。通過強制執行在不同環境間的發佈和部署的一致性，我們實現了更高的保真度、更早的測試和更少的生產意外。

>>>是我們中最新版本的代碼。在其他工作流程中，這也被稱爲主幹、主線或主幹。相應地，在集成也被稱爲基於主幹的開發。>>’’’>>在谷歌，發佈自動化是由一個獨立於的系統管理的。我們不會專注於發佈自動化是如何組裝的，但如果你有興趣，我們會向你推薦《網站可靠性工程》（），其中詳細討論了我們的發佈自動化技術（一個叫做的系統）。>>>>第章進一步討論了帶有實驗和特徵標誌的。>>“”>>我們稱這些爲空中碰撞，因爲它發生的概率極低；然而，當這種情況發生時，其結果可能是相當令人驚訝的。

持續測試

’

讓我們來看看，當我們將持續測試（）應用於代碼變更的整個生命週期時，和是如何配合的，如圖所示。

’’

向右箭頭顯示單個代碼更改從本地開發到生產的過程。同樣，我我們在中的一個關鍵目標是確定在這個過程中什麼時候測試什麼。在本章後面，我們將介紹不同的測試階段，並就提交前與提交後以及和其他階段測試內容的注意事項。我們將展示，當我們向右移動時，代碼更改將受到範圍越來越大的自動化測試的影響。

’爲什麼僅靠預提交還不夠的

爲了儘快發現有問題的更改，並且能夠在預提交上運行自動測試，你可能會想：爲什麼不在預提交時運行所有測試？

’

主要原因是它成本太高了。工程師的工作效率是非常寶貴的，在提交代碼期間等待很長時間運行每個測試可能會嚴重降低生產力。此外，通過取消對預提交的限制，如果測試通過的頻率遠遠高於失敗的頻率，就可以獲得大量的效率提升。例如，運行的測試可以限制在特定範圍內，或者根據預測其檢測故障可能性的模型進行選擇。

’

同樣，如果工程師在提交前被與他們的代碼修改無關的不穩定或鬆散性引起的故障所阻擋，代價也很高。

另一個原因是，在我們運行預提交測試以確認更改是安全的過程中，底層存儲庫可能以與正在測試的更改不兼容的方式進行了更改。也就是說，兩個涉及完全不同文件的更改可能會導致測試失敗。我們稱這種情況爲空中碰撞，雖然一般來說很少發生，但大多數情況下都會發生在我們的掌控範圍內。用於較小存儲庫或項目的系統可以通過序列化提交來避免此問題，以便在即將輸入的內容和剛剛輸入的內容之間沒有區別。

預提交與提交後

那麼，哪些測試應該在預提交時運行？我們的一般經驗法則是：只有快速、可靠的測試。你可以接受在預提交時有一些覆蓋面的損失，但這意味着你需要在提交後抓住任何漏掉的問題，並接受一定的回滾的次數。在提交後，你可以接受更長的時間和一些不穩定性，只要你有適當的機制來處理它。

’’

我們不想因爲等待太長時間的緩慢測試或太多測試而浪費寶貴的工程師生產力我們通常將預提交的測試限制在發生變化的項目上。我們還同時運行測試，所以也要考慮資源決定。最後，我們不希望在預提交時運行不可靠的測試，因爲讓許多工程師受其影響，調試與他們的代碼變更無關的同一個問題的成本太高。

谷歌的大多數團隊都在預提交上運行他們的小型測試（如單元測試）這些是明顯要運行的，因爲它們往往是最快和最可靠的。是否以及如何在提交前運行更大範圍的測試是個更有趣的問題，這因團隊而異。對於想要運行這些測試的團隊來說，封閉測試是一種行之有效的方法來減少其固有的不穩定性。另一個選擇是允許大範圍的測試在預提交時不可靠，但當它們開始失敗時，要主動禁用它們。

>’’>>谷歌的每個團隊都將其項目的測試的一個子集配置爲在預提交運行（相對於提交後）。實際上，我們的持續構建實際上在幕後優化了一些預提交的測試，以保存到提交後。我們將在本章的後面進一步討論這個問題。

候選版本測試

在代碼修改通過（如果有失敗的話，這可能需要多個週期）後，它很快再進行，並被納入待發布的候選版本。

’

在構建的過程中，它將針對整個候選版本運行更大範圍測試。我們通過一系列的測試環境來測試候選發佈版，並在每次部署時對其進行測試。這可能包括沙盒、臨時環境和共享測試環境的組合，如開發或臨時。通常也包括在共享環境中對的一些手動測試。

’

’’

有幾個原因可以說明爲什麼對運行一個全面的、自動化的測試套件很重要，即使它是在提交後對代碼運行的同一個套件（假設是綠色的）

作爲理性的檢查我們仔細檢查，當代碼在中被切割和重新編譯時，確保沒有任何奇怪的事情發生。

爲了便於審計如果工程師想檢查的測試結果，他們很容易得到，並與相關聯，所以他們不需要在日誌中尋找它們。

允許偷樑換柱如果你對一個應用了偷樑換柱式的修復，你的源代碼現在已經與測試的最新版本相去甚遠。

用於緊急推送在這種情況下，可以從真正的切分，並運行必要的最小的測試集，對緊急推送感到有信心，而不等待完整的通過。

生產測試

我們的持續、自動化測試過程一直持續到最後的部署環境：生產環境。我們應該對生產環境運行相同的測試套件（有時稱爲），就像我們早期對候選發佈版所做的那樣，以驗證：）根據我們的測試，生產環境的工作狀態；）根據生產環境，我們測試的相關性。

’“”’’

在應用程序進展的每一步進行持續測試，每一步都有其自身的權衡，這提醒了深度防禦方法在捕捉錯誤方面的價值我們依靠的不僅僅是一種技術或策略來保證質量和穩定性，還有多種測試方法的結合。

正在告警

與負責任地運行生產系統一樣，可持續地維護軟件系統也需要持續的自動監控。正如我們使用監控和告警系統來了解生產系統對變化的反應一樣，揭示了我們的軟件是如何對其環境的變化做出反應的。生產監控依賴於運行系統的被動告警和主動探測，而則使用單元和集成測試來檢測軟件在部署前的變化。在這兩個領域之間進行比較，可以讓我們把一個領域的知識應用到另一個領域。

“”

和告警在開發者工作流程中的總體目的是一樣的儘可能快地發現問題。強調開發者工作流程的早期階段，並通過顯示測試失敗來捕獲問題。告警側重於同一工作流程的後期，通過監測指標並在指標超過某個閾值時報告來捕捉問題。兩者都是自動、儘快地識別問題的形式。

’’’’

一個管理良好的告警系統有助於確保你的服務水平目標（）得到滿足。一個高效的系統有助於確保你的構建處於良好狀態代碼編譯，測試通過，如果需要的話，你可以部署一個新版本。這兩個領域的最佳實踐策略都非常注重仿真度和可操作的告警機制：測試應該只在重要的基礎不變因素被違反時才失敗，而不是因爲測試很脆弱或不穩定。就像一個虛假的警報每隔幾分鐘就會響起，併爲值班人員生成一個頁面一樣，一個脆弱的測試每次運行都會失敗，這是一個問題。如果它不具有可操作性，就不應該發出警報。如果它實際上沒有違反的不變性，就不應該是測試失敗。

’

和告警共享一個基本的概念框架。例如，在局部信號（單元測試、獨立統計監測基於原因的警報）和交叉依賴信號（集成和發佈測試、黑盒探測）之間存在類似的關係。雖然端到端的信號是衡量整個系統是否正常工作的最高仿真度指標，但我們要爲這種仿真度付出代價，如鬆散性、不斷增加的資源成本和調試根源的難度。。

’’“’”

同樣，我們在這兩個領域的故障模式中看到了一種潛在的聯繫。脆弱的基於原因的告警基於超過任意閾值（例如，過去一小時內的重試）而啓動，而該閾值與終端用戶看到的系統健康狀況之間不一定有根本聯繫。當一個任意的測試要求或不變量被違反時，脆性測試就會失敗，而不一定在該變量和被測軟件的正確性之間有根本的聯繫。在大多數情況下，這些測試很容易寫，並有可能有助於調試更大的問題。在這兩種情況下，它們都是整體健康正確性的粗略代理，無法捕獲整體行爲。如果你沒有一個簡單的端到端探針，但你確實可以輕鬆地收集一些聚合統計信息，那麼團隊將基於任意統計信息編寫閾值警報。如果你沒有一個高層次的方法判斷：如果解碼後的圖像與這個原圖像不大致相同，則測試失敗，團隊就會建立測試，斷言字節流是相同的。

’“’”“’’”

基於原因的告警和脆性測試仍然有價值；它們只是在告警場景中不是識別潛在問題的理想方式。在實際發生故障的情況下，有更多的調試細節可以使用。當正在調試故障時，有這樣的信息是很有用的：一小時前，用戶開始遇到更多的失敗請求。大約在同一時間，重試的數量開始上升。讓我們開始調查。同樣地，脆弱的測試仍然可以提供額外的調試信息。圖像渲染管道開始吐出亂數據。其中一個單元測試表明，我們從壓縮器那裏得到了不同的字節。讓我們開始調查吧。

“”“”

’“”“’”

儘管監控和告警被認爲是生產管理領域的一部分，其中錯誤成本的洞察力被很好地理解，來自一個仍然傾向於關注絕對性的視角。將定義爲告警的左移，開始建議如何推理這些策略並提出更好的最佳實踐：

在上實現的綠色率，就像在生產服務中實現的正常運行時間一樣，是非常昂貴的。如果這確實是你的目標，那麼最大的問題之一就是測試和提交之間的競爭條件。把每個告警都當作一個相同原因來處理，一般來說不是正確的方法。如果一個告警在生產中被觸發，但服務實際上並沒有受到影響，讓告警沉默是正確的選擇。對於測試失敗也是如此：在我們的系統學會如何說“已知此測試因無關原因而失敗”之前，我們可能應該更自由地接受禁用失敗測試的更改。並非所有測試失敗都表明即將出現生產問題。那些說如果我們最新的結果不是綠色的，任何人都不能提交的策略可能是錯誤的。如果報告了一個問題，在讓人們提交或使問題複雜化之前，肯定要對這種失敗進行調查。但如果根本原因已被充分理解，並且顯然不會影響生產，那麼阻止提交是不合理的。

“”’’

這種就是警報的見解是新穎的，我們仍在摸索如何充分地得出相似之處。鑑於所涉及的風險較高，對圍繞監控和警報的最佳實踐進行了大量的思考，而則被視爲一種奢侈的功能，這一點並不奇怪。在未來幾年，軟件工程的任務將是看看現有的實踐可以在背景下重新概念化，以幫助重新制定測試和景觀，也許測試的最佳實踐可以幫助澄清監控和警報的目標和策略。

>“”’>>以的正常運行時間爲目標是錯誤的。選擇像或這樣的目標作爲業務或產品的權衡，定義並監控你的實際正常運行時間，並使用該成本預算作爲你願意多積極地推動風險發佈的輸入。>>>>我們相信實際上對軟件工程生態系統至關重要：它是必需品，而不是奢侈品。但這一點尚未得到普遍理解。

’

’

“”’’’’

我們已經討論了的一些已確認的最佳實踐，並介紹了其中的一些挑戰，例如不穩定的、緩慢的、衝突的或僅僅是在預提交時太多的測試對工程師生產力的潛在干擾。實施時，一些常見的額外挑戰包括以下內容：

提交前優化包括考慮到我們已經描述過的潛在問題，在提交前運行哪些測試，以及如何運行它們。

找出罪魁禍首和故障隔離哪段代碼或其他變化導致了問題，它發生在哪個系統中？整合上游微服務是分佈式架構中故障隔離的一種方法，當你想弄清楚問題是源於你自己的服務器還是後端。在這種方法中，你把你的穩定服務器與上游微服務的新服務器組合在一起。（因此，你將微服務的最新變化整合到你的測試中）。由於版本偏差，這種方法可能特別具有挑戰性：不僅這些環境經常不兼容，而且你還可能遇到假陽性在某個特定的階段性組合中出現的問題，實際上在生產中不會被發現。

資源限制測試需要資源來運行，而大型測試可能非常昂貴。此外，在整個過程中插入自動化測試的基礎設施的成本可能是相當大的。

’’“”

還有一個挑戰是失敗管理當測試失敗時該怎麼做。儘管較小的問題通常可以很快得到解決，但我們的許多團隊發現，當涉及到大型的端到端測試時，要有一個持續的綠色測試套件是非常困難的。它們本來就會出現故障或不穩定，而且難以調試；需要有一種機制來暫時禁用並跟蹤它們，以便發佈工作能夠繼續進行。在谷歌，一種常見的技術是使用由值班或發佈工程師提交的熱名單，並將其分發給相應的團隊。如果這些能夠自動生成並歸檔，那就更好了我們的一些大型產品，如谷歌網絡服務器（）和谷歌助手，就能做到這一點。應對這些熱名單進行整理，以確保立即修復所有阻止發佈的。非發佈障礙也應該被修復；它們不那麼緊急，但也應該被優先處理，這樣測試套件纔會保持有用，而不僅僅是一堆越來越多的失效的舊測試。通常，由端到端測試失敗引起的問題實際上是測試問題，而不是代碼問題。

’

不穩定測試給這個過程帶來了另一個問題。它們會侵蝕信心，就像一次失敗的測試一樣，但找到一個可以回滾的變化往往更困難，因爲失敗不會一直髮生。一些團隊依靠一種工具，在調查和修復不穩定的測試時，暫時從預提交中刪除這種不穩定測試。這樣可以保持較高的信心，同時允許有更多的時間來修復這個問題。

’

測試的不穩定性是另一個重大挑戰，我們已經在預提交的背景下看過了。處理這個問題的一個策略是允許測試的多次嘗試運行。這是團隊使用的常見測試配置設置。另外，在測試代碼中，可以在不同的特定點引入重試。

’

另一種有助於解決測試不穩定性（和其他挑戰）的方法是封閉測試，我們將在下一節中討論。

封閉測試

因爲與實時後端交互是不可靠的，我們經常使用封閉後端進行較大範圍的測試。當我們想在提交前運行這些測試時，這是特別有用的，因爲此時穩定性是最重要的。在第章中，我們介紹了封閉測試的概念。

封閉測試：針對測試環境（即應用服務器和資源）運行的測試，是完全自成一體的（即沒有像生產後端那樣的外部依賴）。

’’

封閉測試有兩個重要的特性：更高的確定性（即穩定性）和隔離性。封閉式服務器仍然容易受到一些非確定性來源的影響，如系統時間、隨機數生成和競態條件。但是，進入測試的內容不會因爲外部的依賴關係而改變，所以當你用相同的應用程序和測試代碼運行兩次測試時，你應該得到相同的結果。如果一個封閉測試失敗了，你就知道是由於你的應用程序代碼或測試的變化造成的（有一個小的注意事項：它們也可能由於你的封閉測試環境的重組而失敗，但這不應該經常更變）。出於這個原因，當系統在幾小時或幾天後重新運行測試以提供額外的信號時，封閉性使測試失敗更容易縮小範圍。

’

另一個重要特性，隔離性，意味着生產環境中的問題不應該影響這些測試。我們通常也在同一臺機器上運行這些測試，因此我們不必擔心網絡連接問題。反之亦然：運行封閉測試引起的問題不應影響生產環境。

封閉測試的成功不應取決於運行測試的用戶。這允許人們複製系統運行的測試，並允許人們（例如，庫的開發者）運行其他團隊擁有的測試。

一種封閉式的後端是模擬的。正如在第章中所討論的，這些可能比運行一個真正的後端更廉價，但它們需要花費精力去維護，而且仿真度有限。

實現具有預提交價值的集成測試的最乾淨的選擇是使用一個完全精細的設置即啓動整個堆棧沙盒谷歌爲流行組件（如數據庫）提供開箱即用的沙盒配置，以使其更簡單。這對於組件較少的小型應用程序更爲可行，但谷歌也有例外，即使是一個（由提供）在每次提交前以及提交後從零開始啓動大約臺服務器的應用程序。但是，自創建該系統以來，錄製重播已成爲大型系統的一種更受歡迎的範例，並且往往比啓動大型沙盒堆棧更便宜。

’

’

’

記錄重放（見第章）系統記錄實時的後端響應，緩存它們，並在一個封閉的測試環境中重放它們。記錄重放是一個強大的工具，可以減少測試的不穩定性，但一個缺點是它會導致測試變脆弱：很難在以下方面取得平衡：

假陽性測試在不應該通過的情況下通過了，因爲我們對緩存的訪問太多，並且遺漏了捕獲新響應時可能出現的問題。

錯誤的否定測試在不應該通過的情況下失敗了，因爲我們對緩衝區的命中太少。這需要更新響應，這可能需要很長時間，並導致必須修復的測試失敗，其中許多可能不是實際問題。這個過程通常是提交阻塞，這並不理想。

理想情況下，記錄重放系統應該只檢測有問題的更改，並且只有在請求以有意義的方式更改時才檢測緩存未命中。如果該更改導致問題，代碼修改者會用更新的響應重新運行測試，查看測試是否仍然失敗，並因此收到問題警報。在實踐中，在一個大型且不斷變化的系統中，知道請求何時以有意義的方式發生了更改可能非常困難。

>’>>在實踐中，通常很難做出一個完全沙盒化的測試環境，但可以通過儘量減少外部的依賴性來實現所需的穩定性。

隱祕的谷歌助手

谷歌助手爲工程師提供了一個運行端到端測試的框架，包括一個具有設置查詢功能的測試套件，指定是否在手機或智能家居設備上進行模擬，並在與谷歌助手的整個交互中驗證響應。

其最大的成功故事之一是使其測試套件在提交前完全密封。當該團隊以前在提交前運行非封閉測試時，測試經常會失敗。在某些時間裏，團隊會看到超過個代碼更改繞過並忽略測試結果。在將預提交轉爲封閉的過程中，該團隊將運行時間縮短了倍，而且幾乎沒有任何閃失。它仍然會出現故障，但這些故障往往是相當容易發現和回滾的。

’’

現在，非封閉測試已經被推到提交後，結果反而導致失敗在那裏累積。調試失敗的端到端測試仍然很困難，一些團隊甚至沒有時間嘗試，所以他們只是禁用它們。這比讓它停止所有人的開發要好，但它可能導致生產失敗。

’

該團隊目前的挑戰之一是繼續微調其緩存機制，以便預提交可以捕捉到更多過去只在提交後發現的問題類型，同時不引入過多的脆弱性。

另一個問題是，鑑於組件正在轉移到自己的微服務中，如何爲分散的助手做預提交測試。因爲助手有一個龐大而複雜的堆棧，在預提交上運行一個封閉的堆棧，在工程工作、協調和資源方面的成本會非常高。

“”“”

最後，該團隊正在利用這種分散的優勢，採取一種巧妙的新的提交後故障隔離策略。對於助手中的個微服務中的每一個，團隊將運行一個提交後的環境，其中包含在頭部構建的微服務，以及其他個服務的生產（或接近生產）版本，以將問題隔離到新構建的服務器。這種設置通常是的成本，但該團隊利用了一個很酷的功能，稱爲熱交換，將這一成本削減到。從本質上講，熱交換允許一個請求指示服務器交換一個後端地址來調用，而不是通常的一個。因此，只需要運行個服務器，每個微服務都有一個，而且它們可以重複使用同一組被交換到這個環境中的生產環境後端。

’

正如我們在本節中所看到的，封閉測試既可以減少大範圍測試中的不穩定性，也可以幫助隔離故障，解決我們在上一節中確定的兩個重大挑戰。然而，封閉式後端也可能更昂貴，因爲它們使用更多的資源，並且設置速度較慢。許多團隊在他們的測試環境中使用密封和活動後端的組合。

谷歌的

’’’

現在讓我們更詳細地看看在谷歌是如何實施的。首先，我們將瞭解谷歌絕大多數團隊使用的全球持續構建，以及它是如何實現一些實踐和解決我們在上一節中看到的一些挑戰的。我們還將介紹一個應用程序，以及轉換如何幫助其作爲平臺和服務進行擴展。

’谷歌的全球持續構建

亞當本德

我們在整個代碼庫中運行一個大規模的持續構建，稱爲測試自動化平臺（）。它負責運行我們大部分的自動化測試。由於我們使用的是，是谷歌幾乎所有變化的門戶。每天，它負責處理超過個獨特的變化，運行超過億個獨立的測試用例。

’

是谷歌發展基礎設施的核心。從概念上講，這個過程非常簡單。當工程師試圖提交代碼時，將運行相關測試並報告成功或失敗。如果測試通過，則允許更改進入代碼庫。

預提交優化

爲了快速和持續地發現問題，必須確保對每一個變化都進行測試。如果沒有，運行測試通常是由個別工程師決定的，這往往會導致一些有積極性的工程師試圖運行所有的測試並跟進故障。

’’

如前所述，等待很長時間來運行預提交的每個測試可能會造成嚴重破壞，在某些情況下需要等待數小時。爲了最大限度地減少等待時間，谷歌的方法允許潛在的破壞性更改提交到存儲庫中（請記住，這些更改會立即被公司其他人看到！）。我們只要求每個團隊創建一個快速的測試子集，通常是一個項目的單元測試，可以在提交更改之前（通常是在發送更改進行代碼審查之前）運行這些測試。根據經驗，通過預提交的變更通過其餘測試的可能性非常高（），我們樂觀地允許將其集成，以便其他工程師可以開始使用它。

提交更改後，我們使用異步運行所有可能受影響的測試，包括較大和較慢的測試。

’

當變更導致測試失敗時，必須迅速修復變更，以防止阻塞其他工程師。我們已經建立了一種文化規範，強烈反對在已知失敗測試的基礎上進行任何新的工作，儘管不穩定測試會讓這變得困難。因此，當提交的變更打破了團隊的內置時，該變更可能會阻止團隊向前推進或構建新版本。因此，快速處理故障勢在必行。

“”’

爲了處理這種破壞，每個團隊都有一個。的責任是保持他們特定項目的所有測試通過，無論誰破壞了它們。當被告知他們的項目中有一個失敗的測試時，他們會放下手中的工作，修復構建。這通常是通過識別違規的變化，並確定它是否需要回滾（首選解決方案）或可以繼續修復（風險較大）。

在實踐中，允許在驗證所有測試之前提交更改的折衷方案已經真正得到了回報；提交更改的平均等待時間約爲分鐘，通常在後臺運行。再加上的原則，我們能夠以最小的中斷量有效地檢測和解決運行時間較長的測試檢測到的故障。

發現罪魁禍首

’

谷歌大型測試套件面臨的一個問題是找到破壞測試的具體變化。從概念上講，這應該很容易：抓取一個變更，運行測試，如果任何測試失敗，將變更標記爲壞的。不幸的是，由於片斷的流行以及測試基礎設施本身偶爾出現的問題，要確信失敗是真實的並不容易。更加複雜的是，必須每天評估如此多的變化（一秒鐘超過一個），以至於它不能再對每個變化運行每個測試。取而代之的是，它退回到批處理相關的更改，這減少了要運行的獨特測試的總數。儘管這種方法可以加快運行測試的速度，但它可以掩蓋批處理中導致測試中斷的更改。

爲了加快故障識別，我們使用了兩種不同的方法。首先，自動將失敗的批次拆分爲單獨的更改，並針對每個更改單獨重新運行測試。這個過程有時需要一段時間才能收斂到失敗，因此，我們還創建了罪魁禍首查找工具，每個開發人員可以使用這些工具通過一批更改進行二進制搜索，並確定哪一個是可能的罪魁禍首。

故障管理

在隔離破壞性變更後，儘快修復該變更非常重要。失敗測試的存在可能會很快開始侵蝕測試套件的信心。如前所述，修復損壞的構建是的責任。最有效的工具是回滾。

回滾更改通常是修復生成的最快和最安全的方法，因爲它可以快速將系統恢復到已知的良好狀態。事實上，最近已升級爲自動回滾更改，當它高度確信更改是罪魁禍首時。

’’

快速回滾與測試套件攜手並進，以確保持續的生產力。測試給了我們改變的信心，回滾給了我們撤銷的信心。沒有測試，回滾就不能安全進行。沒有回滾，破損的測試就不能被快速修復，從而降低了對系統的信心。

>’>>對谷歌代碼庫的任何改動都可以通過兩次點擊來回滾。

資源限制

雖然工程師可以在本地運行測試，但大多數測試的執行是在一個叫做的分佈式構建和測試系統中進行。允許工程師在我們的數據中心運行他們的構建和測試，這最大限度地提高了並行性。在我們的規模下，運行所有由工程師按需執行的測試以及作爲流程一部分運行的所有測試所需的資源是巨大的。即使考慮到我們擁有的計算資源量，像和這樣的系統也受到資源限制。爲了解決這些限制，在上工作的工程師想出了一些聰明的方法來確定哪些測試應該在什麼時候運行，以確保花費最少的資源來驗證一個特定的變化。

’

確定需要運行哪些測試的主要機制是分析每個更改的下游依賴關係圖。谷歌的分佈式構建工具和維護了一個近乎實時的全球依賴關係圖版本，並可供用戶使用。因此，可以快速確定任何更改的下游測試，並運行最小集以確保更改是安全的。

影響使用的另一個因素是測試運行的速度。通常能夠以更少的測試比更多測試更快地運行更改。這種情況鼓勵工程師編寫小而集中的更改。在繁忙的一天中，觸發個測試的更改和觸發個測試的更改之間的等待時間差異可能是幾十分鐘。希望花更少時間等待的工程師最終會做出更小的、有針對性的修改，這對所有人來說都是一種勝利。

案例研究：

“”’’’

年，開始作爲一種數據備份和下載產品。其創始人率先提出了“數據解放”的理念，即用戶無論走到哪裏，都應該能夠輕鬆地以可用的格式攜帶數據。他們首先將與少量谷歌產品整合在一起，製作用戶照片、聯繫人列表等檔案，以便在他們的要求下載。然而，並沒有在很長一段時間內保持規模，它不僅是一個平臺，而且是一項針對各種谷歌產品的服務。正如我們將看到的，有效的對於保持任何大型項目的健康至關重要，但在應用程序快速增長時尤爲關鍵。

情景：持續中斷的開發部署

問題隨着作爲功能強大的範圍內的數據獲取、歸檔和下載工具而聲名鵲起，該公司的其他團隊開始轉向它，請求以便他們自己的應用程序也可以提供備份和下載功能，包括（文件夾下載由提供）和（用於文件預覽）總之，從最初的產品的後端發展到爲至少種其他產品提供，提供廣泛的功能。

團隊決定將每個新的部署爲一個定製的實例，使用相同的原始二進制文件，但將它們配置成有點不同的工作方式。例如，用於批量下載的環境擁有最大的集羣，爲從獲取文件保留了最多的配額，以及一些自定義的認證邏輯，允許未登錄的用戶下載公共文件夾。

“”

不久，就面臨“標誌問題”。爲其中一個實例添加的標誌將破壞其他實例，當服務器由於配置不兼容而無法啓動時，它們的部署將中斷。除了功能配置之外，還有安全性和配置。例如，消費者驅動器下載服務不應訪問加密企業導出的密鑰。配置很快變得複雜，幾乎每晚都會發生故障。

’’’

我們做了一些努力來分解和模塊化配置，但這暴露出的更大的問題是，當工程師想要修改代碼時，手動測試每臺服務器是否在每種配置下啓動是不切實際的。他們在第二天的部署中才發現配置失敗的情況。有一些單元測試是在提交前和提交後運行的（通過），但這些測試不足以捕獲此類問題。

團隊所做的。團隊爲每個實例創建了臨時的、沙盒式的迷你環境，在預提交時運行，並測試所有服務器在啓動時是否健康。在提交前運行臨時環境可以防止的服務器因配置不當而損壞，並將夜間部署失敗率降低了。

’’

儘管這些新的沙盒式預提交測試大大減少了部署失敗，但它們並沒有完全消除它們。特別是，的端到端測試仍然經常中斷部署，而且這些測試很難在預提交中運行（因爲它們使用的是測試賬戶，在某些方面仍然與真實賬戶一樣，並受到同樣的安全和隱私保護）。重新設計它們以使其對預提交友好，將是一項巨大的工程。

’’’

如果團隊不能在預提交中運行端到端測試，那麼它什麼時候可以運行？它想比第二天的開發部署更快得到端到端的測試結果，並決定每兩小時一次是一個好的起點。但團隊並不想這麼頻繁地進行全面的開發部署這將產生開銷，並擾亂工程師在開發中測試的長期運行的流程。爲這些測試建立一個新的共享測試環境，似乎也需要太多的開銷來提供資源，再加上查找問題（即找到導致失敗的部署）可能涉及一些不可預知的手動工作。

因此，該團隊重新使用了預提交的沙盒環境，輕鬆地將它們擴展到新的後提交環境。與預提交不同，後提交符合安全保障措施，可以使用測試賬戶（其一，因爲代碼已經被批准），所以端到端的測試可以在那裏運行。提交後的每兩小時運行一次，從綠頭抓取最新的代碼和配置，創建一個，並針對它運行已經在開發中運行的相同的端到端測試套件。

“”’“”“”“”

經驗教訓。更快的反饋循環防止了開發部署中的問題：

將不同產品的測試從夜間部署後轉移到預提交，可以防止的服務器因配置不良而損壞，並將夜間部署的失敗率降低。儘管端到端測試不能全部轉移到預提交，但它們仍然從夜間部署後轉移到兩小時內提交後。這有效地將罪魁禍首減少了倍。

場景：無法識別的測試日誌

’“”

問題：隨着整合了更多的谷歌產品，它已經發展成爲一個成熟的平臺，允許產品團隊直接在的二進制文件中插入插件，其中包含產品特定的數據獲取代碼。例如，谷歌照片插件知道如何獲取照片、相冊元數據等。從最初的少數產品擴展到現在與超過個的產品集成。

’’

的端到端測試將其故障轉儲到日誌中，這種方法不能擴展到個產品插件。隨着更多產品的集成，更多的故障被引入。儘管團隊在提交後的中更早更頻繁地運行測試，但多個故障還是會堆積在裏面，很容易被忽略。翻閱這些日誌成了一個令人沮喪的時間消耗，而且測試幾乎總是失敗。

’’

團隊所做的。團隊將測試重構爲一個動態的、基於配置的套件（使用一個參數化的測試運行器），在一個更友好的用戶界面中報告結果，清楚地顯示單個測試結果爲綠色或紅色：不再翻閱日誌。他們還使失敗變得更容易調試，最明顯的是，在錯誤信息中直接顯示失敗信息，並提供日誌鏈接。例如，如果從獲取文件失敗，測試將動態地構建一個鏈接，在日誌中搜索該文件的，並將其包含在測試失敗信息中。如圖所示，這使產品插件工程師的大部分調試過程自動化，並在向他們發送日誌時不再需要團隊的協助。

’

’

經驗教訓。來自的可訪問、可操作的反饋減少了測試失敗，提高了生產力。這些舉措使團隊參與調試客戶（產品插件）測試失敗的情況減少了。

“”情景：調試所有谷歌

“”’

問題：的一個有趣的副作用是團隊沒有預料到的，因爲它以歸檔的形式驗證了多個面向最終用戶的產品的輸出，他們基本上是在測試所有的產品，捕捉與無關的問題。這是一件好事能夠幫助提高谷歌產品的整體質量。然而，這給他們的流程帶來了一個問題：他們需要更好的故障隔離，以便他們能夠確定哪些問題是在他們的構建中（哪些是少數），哪些是在他們調用的產品背後鬆散耦合的微服務中。

’“”

團隊所做的。該團隊的解決方案是針對生產持續運行完全相同的測試套件，正如它在提交後中所做的那樣。這樣做的成本很低，並允許團隊隔離哪些故障是在其構建中出現的，哪些是在生產中出現的；例如，微服務發佈的結果“在谷歌的其他地方”。

經驗教訓。對生產環境和提交後的運行相同的測試套件（使用新構建的二進制文件，但相同的實時後端）是隔離故障的廉價方法。

“”’

仍然存在的挑戰。展望未來，隨着與更多的產品整合，以及這些產品變得更加複雜，測試所有谷歌（顯然，這是一個誇張的說法，因爲大多數產品問題都是由他們各自的團隊發現的）的負擔越來越重。在這個和之間進行手動比較是對時間的昂貴使用。

’’

場景：保持綠色

問題：隨着平臺支持更多的產品插件，每個插件都包括端到端的測試，這些測試會失敗，端到端的測試套件幾乎總是被破壞。這些故障不可能都被立即修復。許多故障是由於產品插件二進制文件中的錯誤，團隊無法控制這些錯誤。有些故障比其他故障更重要低優先級的和測試代碼中的不需要阻止發佈，而高優先級的需要阻止。團隊可以很容易地通過註釋它們來禁用測試，但這將使失敗者很容易忘記。

一個常見的失敗原因是：當產品插件推出一個功能時，測試會中斷。例如，插件的播放列表獲取功能可能在開發階段啓用了幾個月的測試，然後纔在生產階段啓用。測試只知道要檢查一個結果，所以這往往導致測試需要在特定的環境中被禁用，並在功能推出時被手動修復。

’

團隊所做的。該團隊提出了一種禁用失敗測試的戰略方法，方法是使用相關錯誤標記失敗測試，並將其提交給負責的團隊（通常是產品插件團隊）。當失敗的測試被標記爲錯誤時，團隊的測試框架將抑制其失敗。這允許測試套件保持綠色，並且仍然提供信心，證明除已知問題外的所有其他問題都通過了，如圖所示。

通過（責任人）測試禁用來實現綠色

對於推廣問題，團隊增加了插件工程師指定功能標誌名稱或代碼更改的功能，該功能使特定功能和輸出能夠同時使用和不使用該功能。測試配備了查詢測試環境的功能，以確定給定的功能是否在那裏啓用，並相應地驗證預期輸出。

’’’“”

當被禁用的測試的標籤開始積累並且不被更新時，該團隊將其清理自動化。測試現在會通過查詢我們的錯誤系統的來檢查一個錯誤是否被關閉。如果一個被標記爲失敗的測試實際通過了，並且通過的時間超過了配置的時間限制，測試就會提示清理標籤（如果還沒有被修復的話，就標記爲修復）。這個策略有一個例外：不穩定的測試。對於這些，團隊將允許測試被標記爲不穩定，如果測試通過了，系統不會提示清理標記的不穩定故障。

‘

’這些變化使得測試套件大多是自我維護的，如圖所示。

提交修復程序後關閉的平均時間

’’’

經驗教訓。禁用無法立即修復的失敗測試是保持套件綠色的一種切實可行的方法，這使人相信你知道所有的測試失敗。另外，自動化測試套件的維護，包括推出管理和更新跟蹤固定測試的，保持套件的清潔，防止技術債務。用的說法，我們可以把圖中的指標稱爲：平均清理時間。

未來的改進。自動歸檔和標記將是一個有用的下一步。這仍然是一個手動和繁重的過程。正如前面提到的，我們的一些大型團隊已經這樣做了。

’“”’“”’“”

進一步的挑戰。我們所描述的場景遠不是所面臨的唯一的挑戰，還有更多問題需要解決。例如，我們在第頁的挑戰中提到了從上游服務隔離故障的困難。這是仍然面臨的一個問題，即源於上游服務的罕見故障，例如的“驅動器文件夾下載”使用的流式基礎結構中的安全更新在部署到生產環境時破壞了存檔解密。上游服務都是經過階段性測試的，但沒有簡單的方法在它們投入生產後用自動檢查它們是否與兼容。最初的解決方案是創建一個上游臨時的環境，根據上游依賴的暫存版本測試的生產二進制文件。然而，這被證明是很難維護的，在臨時版本和生產版本之間存在着額外的兼容性問題。

’但我用不起費用

’’

你可能會想，這一切都很好，但你既沒有時間也沒有錢來建立這些。我們當然承認，谷歌可能比一般的創業公司擁有更多的資源來實施。然而，我們的許多產品成長得如此之快，以至於他們也沒有時間去開發一個系統（至少不是一個合適的系統）。

’“”

在你自己的產品和組織中，試着想想你已經爲在生產中發現和處理的問題支付了多少成本。這些問題當然會對最終用戶或客戶產生負面影響，但它們也會影響到團隊。頻繁的生產救火是一種壓力和士氣的體現。儘管建立系統是昂貴的，但它不一定是一個新的成本，而是將成本轉移到一個更早的、更可取的階段，減少問題的發生率，從而減少成本，因爲問題發生在右邊。帶來了更穩定的產品和更快樂的開發運營文化，在這種文化中，工程師更相信“系統”會發現問題，他們可以更多地關注功能，而不是修復問題。

總結

’’’’

儘管我們已經描述了我們的流程和一些自動化的方法，但這並不是說我們已經開發了完美的系統。畢竟，系統本身只是一個軟件，永遠不會完整，應該進行調整以滿足應用程序和工程師不斷變化的需求。我們試圖用的的演變和我們指出的未來改進領域來說明這一點。

內容提要

系統決定使用什麼測試以及何時使用。隨着代碼庫的老化和規模的擴大，系統變得越來越有必要。應該在提交前優化更快、更可靠的測試，在提交後優化更慢、更不確定的測試。可訪問、可操作的反饋使系統變得更加有效。