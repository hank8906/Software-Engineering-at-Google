第二十一章依賴管理

’

依賴管理管理我們無法控制的庫、包和依賴關係的網絡是軟件工程中最不爲人理解和最有挑戰性的問題之一。依賴管理關注的問題包括：我們如何更新外部依賴的版本？爲此，我們如何描述版本？在我們的依賴關係中，哪些類型的變化是允許的或預期的？我們如何決定何時依賴其他組織生產的代碼是明智的？

“’”

作爲比較，與依賴管理最密切相關的主題是源碼控制。這兩個領域都描述了我們如何處理源代碼。源碼控制涵蓋了比較容易的部分：我們在哪裏檢查源碼？我們如何將源碼放入構建中？在我們接受了基於主幹的開發的價值之後，對於一個組織來說，大多數日常的源碼控制問題都是相當平常的：我有一個新的東西，我應該把它添加到什麼目錄？

’’’’

依賴管理在時間和規模上都增加了額外的複雜性。在一個基於主幹的源碼控制問題中，當你做一個改變時，你需要運行測試並且不破壞現有的代碼，這是相當清楚的。這是基於這樣的想法：你在一個共享的代碼庫中工作，能夠了解事物的使用方式，並且能夠觸發構建和運行測試的想法。依賴管理關注的是在你的組織之外進行改變時出現的問題，沒有完全的訪問權限或可見性。因爲你的上游依賴不能與你的私有代碼協調，它們更有可能破壞你的構建，導致你的測試失敗。我們如何管理這個問題？我們不應該接受外部依賴嗎？我們是否應該要求外部依賴的版本之間更加一致？我們什麼時候更新到一個新的版本？

’’’’

規模使所有這些問題變得更加複雜，因爲我們意識到我們實際上並不是在討論單個依賴項導入，而且在一般情況下，我們依賴於整個外部依賴網絡。當我們開始處理網絡時，很容易構建這樣的場景：你的組織對兩個依賴項的使用在某個時間點變得不能滿足。通常，這是因爲一個依賴項在無法滿足某些要求停止工作，而另一個依賴項與相同的要求不兼容。關於如何管理單個外部依賴關係的簡單解決方案通常沒有考慮到管理大型網絡的現實情況。本章的大部分時間我們將討論這些相互衝突的需求問題的各種形式。

“”’“”’

源碼管理和依賴管理是由以下問題分開的相關問題：“我們的組織是否控制此子項目的開發更新管理？”例如，如果貴公司的每個團隊都有單獨的版本庫、目標和開發實踐，這些團隊產生的代碼的交互和管理將更多地涉及依賴管理，而不是源碼控制。另一方面，一個擁有（虛擬？）單個版本庫（）的大型組織可以通過源碼控制策略進一步擴展，這是的方法。獨立的開源項目當然被視爲獨立的組織：未知項目和非必要協作項目之間的相互依賴關係是一個依賴管理問題。也許我們在這個話題上最有力的建議是：在其他條件相同的情況下，我們更喜歡源碼管理問題，而不是依賴管理問題。如果你可以選擇更廣泛地重新定義“組織”（你的整個公司而不僅僅是一個團隊），這通常是一個很好的權衡。源碼管理問題比依賴管理問題更容易思考，處理成本也更低。

’’

隨着開源軟件（）模式的不斷發展和擴展到新的領域，以及許多流行項目的依賴關係隨着時間的推移不斷擴大，依賴管理也許正在成爲軟件工程策略中最重要的問題。我們開發的軟件不再是構建在之外的一層或兩層上的斷開連接的孤島。現代軟件建立在高聳的依賴性支柱之上；但僅僅因爲我們能夠建造這些支柱，並不意味着我們已經弄清楚如何讓它們長期保持穩定。

’’’’’

在本章中，我們將介紹依賴管理的特殊挑戰，探索解決方案（常見的和新穎的）及其侷限性，並介紹使用依賴關係的現實情況，包括我們在中處理事情的方式。在所有這些之前，我們必須承認：我們在這個問題上投入了大量的精力，並且在重構和維護問題上擁有豐富的經驗這表明了現有方法的實際缺陷。我們沒有第一手證據表明解決方案能夠在大規模的組織中很好地工作。在某種程度上，本章總結了我們所知道的不起作用（或者至少在更大範圍內可能不起作用）以及我們認爲有可能產生更好結果的地方。我們絕對不能聲稱這裏有所有的答案；如果可以，我們就不會把這稱爲軟件工程中最重要的問題之一。

>>>這可以是任何語言版本、較低級別庫的版本、硬件版本、操作系統、編譯器標誌、編譯器版本等。

爲什麼依賴管理如此困難？

“”’

即使是定義依賴管理問題也會帶來一些不尋常的挑戰。這個領域的許多半生不熟的解決方案都集中在一個狹義的問題上。我們如何導入一個我們本地開發的代碼可以依賴的包？這是一個必要但並不充分的表述。訣竅不只是找到一種方法來管理一個依賴關係訣竅是如何管理一個依賴關係的網絡以及它們隨時間的變化。這個網絡中的一些子集對於你的第一方代碼來說是直接必要的，其中一些只是由傳遞依賴拉進來的。在一個足夠長的時期內，這個依賴網絡中的所有節點都會有新的版本，其中一些更新會很重要。或者，具體來說，鑑於我們並不控制這些依賴關係，我們如何使其容易找到所有依賴關係的相互兼容的版本？我們如何分析我們的依賴網絡？我們如何管理這個網絡，尤其是在面對不斷增長的依賴關係的時候？

衝突的需求和菱形依賴

’“”“”’

依賴管理的核心問題強調從依賴關係網絡而不是單個依賴關係角度思考的重要性。大部分困難源於一個問題：當依賴網絡中的兩個節點有衝突的要求，而你的組織同時依賴它們時，會發生什麼？這可能有很多原因，從平臺考慮（操作系統、語言版本、編譯器版本等）到更常見的版本不兼容問題。作爲一個不可滿足的版本要求，版本不兼容的典型例子是菱形依賴問題。雖然我們通常不包括像你使用的是什麼版本的編譯器這樣的東西，但大多數這些衝突的需求問題都與在代表這個需求的依賴圖中添加一個（隱藏的）節點同構。因此，我們將主要討論菱形依賴關係方面的衝突需求，但請記住，實際上絕對可能是參與構建你的依賴關係網絡中的兩個或多個節點的任何軟件。

菱形依賴問題，以及其他形式的衝突需求，需要至少三層依賴關係，如圖所示。

菱形依賴問題

’’

在這個簡化模型中，和都使用，而和都由更高級別的組件使用。如果引入了一個不兼容的變更，那麼作爲獨立組織的產品，和可能不會同時更新。如果依賴於新的版本，而依賴於舊版本，那麼（也就是你的代碼）沒有通用的方法來組合所有內容。這個菱形依賴可以在任何規模形成：在依賴關係的整個網絡中，如果有一個低級節點需要同時處於兩個不兼容的版本中（由於從某個高級節點到這兩個版本有兩條路徑），那麼就會出現問題。

’’’’

不同的編程語言對菱形依賴問題的容忍程度不同。對於某些語言來說，可以在構建過程中嵌入一個依賴關係的多個（孤立的）版本：從調用可能與從調用調用相同的不同版本。例如，提供了相當完善的機制來重命名這種依賴關係所提供的符號。同時，對正常構建中的菱形依賴關係的容忍度幾乎爲零，由於明顯違反了的，它們非常可能引發明顯和未定義行爲（）。在動態鏈接庫（）中或者在單獨構建和鏈接的情況下，你最多可以使用與的思想來隱藏一些符號。然而，在我們所知道的所有編程語言中，這些變通方法充其量只是部分解決方案：通過調整函數的名稱，可以使嵌入的多個版本發揮作用，但如果有類型在依賴關係之間傳遞，所有的下注都會無效。例如，中定義的類型根本不可能以語義一致的方式通過一些庫傳遞給提供的。在單獨編譯的庫中隱藏或重命名實體的特定語言黑科技可以爲菱形依賴問題提供一些緩衝，但在一般情況下並不是一個解決方案。

’’

如果你遇到一個衝突的需求問題，唯一簡單的答案是向前或向後跳過這些依賴的版本，以找到兼容的版本。當這不可能時，我們必須求助於本地修補有問題的依賴關係，這特別具有挑戰性，因爲首先發現不兼容的工程師可能不知道提供者和使用者中不兼容的原因。這是固有的：的開發者還在以兼容的方式與工作，而的開發者已經升級到了。只有同時參與這兩個項目的開發人員纔有機會發現問題，當然也不能保證他們對和足夠熟悉，能夠完成升級。更簡單的答案是降級和，儘管如果升級最初是因爲安全問題而被迫進行的，那麼這不是一個選項。

“”’

依賴管理的策略和技術體系在很大程度上歸結爲一個問題：我們如何避免衝突的需求，同時仍然允許非協調組之間的變化？如果你有一個菱形依賴問題的一般形式的解決方案，允許在網絡的各個層面不斷變化的需求（包括依賴和平臺需求）的現實，你已經描述了依賴管理解決方案的有趣部分。

>>>例如，安全缺陷、棄用、處於具有安全缺陷的更高級別依賴項的依賴項集中，等等。>>>>這稱爲着色或版本控制。

導入依賴

’’’

在編程方面，重用一些現有的基礎設施顯然比自己創建它更好。這是顯而易見的，也是技術發展的一部分：如果每個新手都必須重新實現他們自己的語法分析器和正則表達式引擎，我們就永遠不會有任何進展。重用是健康的，特別是與從頭開始重新開發高質量軟件的成本相比。只要你下載的不是木馬軟件，如果你的外部依賴滿足了你的編程任務的要求，你就應該使用它。

承諾兼容性

’

當我們開始考慮時間時，情況就會出現一些複雜的權衡。僅僅因爲你可以避免開發的成本，並不意味着導入一個依賴關係是正確的選擇。在一個瞭解時間和變化的軟件工程組織中，我們還需要注意其持續的維護成本。即使我們在導入依賴關係時並不打算對其進行升級，被發現的安全漏洞、不斷變化的平臺和不斷發展的依賴關係網絡也會合力迫使我們進行升級，而不管我們的意圖如何。當這一天到來時，它將會有多高的成本？有些依賴關係比其他依賴關係更清楚地說明了僅僅使用該依賴關係的預期維護成本：假定有多少兼容性？假設有多大的演變？如何處理變化？版本支持多長時間？

我們建議，依賴提供者應該更清楚地瞭解這些問題的答案。考慮一下擁有數百萬用戶的大型基礎設施項目及其兼容性承諾所樹立的榜樣。

’’

對於標準庫來說，這種模式是一種幾乎無限期的向後兼容性的。根據標準庫的舊版本構建的二進制文件有望與較新的標準進行構建和鏈接：標準不僅提供了兼容性，還爲二進制工件提供了持續的向後兼容性，即所謂的兼容性。這一支持程度在不同的平臺是不同的。對於上的用戶來說，可能大多數代碼在大約十年的範圍內都能正常工作。該標準沒有明確指出它對兼容性的承諾在這一點上沒有面向公衆的政策文件。然而，該標準確實發佈了常設文件，其中列出了標準庫在不同版本之間可以進行的一小部分變化類型，隱含地定義了需要準備的變化類型。也是如此：語言版本之間的源代碼是兼容的，舊版本的文件很容易在新版本中運行。

並非所有的語言都優先考慮相同規格的兼容性。編程語言明確承諾大多數版本之間的源代碼兼容，但沒有二進制兼容。你不能用一個版本的語言建立一個庫，然後把這個庫鏈接到用另一個版本的語言建立的程序中。

’’’’“”’’

谷歌的項目很像，對時間有一個重要的警告。我們不願意無限期地致力於兼容性。是我們內部大多數計算量最大的服務的基礎，我們相信這些服務可能會在未來很多年內使用。這意味着我們小心翼翼地保留修改的權利，特別是在實現細節和方面，以實現更好的性能。我們已經經歷了太多的例子，一個在事後被證明是混亂和容易出錯的；在無限期的未來向成千上萬的開發者公佈這種已知的錯誤感覺是錯誤的。在內部，我們已經有大約億行的代碼依賴於這個庫，我們不會輕易改變，但它必須是可以改變的。爲此，明確地不承諾的兼容性，但確實承諾了一種稍微有限的兼容性：我們不會在不提供自動重構工具的情況下做出破壞性的改變，該工具將透明地將代碼從舊的轉換到新的。我們覺得這將意外成本的風險大大地轉移到了用戶身上：無論一個依賴關係是針對哪個版本編寫的，該依賴關係和的用戶都應該能夠使用最新的版本。最高的成本應該是運行這個工具，並推測在中層級依賴關係（或，繼續我們前面的例子）中發送產生的補丁以供審查。在實踐中，這個項目足夠新，我們沒有必要做任何重大的破壞性改變。我們不能說這對整個生態系統會有多好的效果，但在理論上，這似乎是對穩定性和易升級的一個良好平衡。

’“’”’

相比之下，庫沒有承諾不同版本的兼容性。當然，大多數代碼不會改變，但許多庫都在積極維護和改進，所以向後兼容以前的版本並不總是可能的。我們建議用戶只在項目生命週期的某個階段進行升級，因爲在這個階段，一些變化不會造成問題。的目標與標準庫或有根本的不同：是一個實驗驗證場。的某個版本可能非常穩定，適合在許多項目中使用，但是的項目目標並不優先考慮版本之間的兼容性其他長期項目可能會遇到一些與最新版本保持同步的阻力。的開發者和標準庫的開發者一樣都是專家這與技術專長無關：這純粹是一個項目是否承諾和優先考慮的問題。

’“”“”’’’

從這個討論中的庫來看，重要的是要認識到這些兼容性問題是軟件工程問題，而不是編程問題。你可以下載像這樣沒有兼容性承諾的東西，並把它深深地嵌入到你的組織中最關鍵、生命週期最長的系統中；它可以正常工作。這裏所有的擔憂都是關於這些依賴關係會隨着時間的推移而改變，跟上更新的步伐，以及讓開發者擔心維護而不是讓功能正常工作的困難。在谷歌內部，有源源不斷的指導意見指向我們的工程師，幫助他們考慮“我讓它起作用了”和“這是以一種支持的方式起作用的”之間的區別。這並不奇怪：畢竟，這是海勒姆定律的基本應用。

’’

更廣泛地說：重要的是要意識到，依賴管理在編程任務和軟件工程任務中具有完全不同的性質。如果你所處的問題空間與隨時間的維護相關，則依賴關係管理很困難。如果你只是爲今天開發一個解決方案，而不需要更新任何東西，那麼你完全可以隨心所欲地抓取許多現成的依賴關係，而不考慮如何負責任地使用它們或爲升級做計劃。通過違反中的所有規定，並依靠和的二進制兼容性，使你的程序今天就能運行只要你不升級標準庫、或，也不升級任何依賴你的東西，就可以了。

>>>在許多情況下，這些人羣中存在着明顯的重疊。

導入依賴的注意事項

’’’’

導入一個依賴項用於編程項目幾乎是免費的：假設你已經花了時間來確保它做了你需要的事情，並且沒有隱蔽的安全漏洞，那麼重用幾乎總是比重新實現功能要划算。即使該依賴項已經採取了澄清它將作出什麼兼容性承諾的步驟，只要我們不曾升級，你在該依賴項的快照之上建立的任何東西都是好的，無論你在使用該時違反了多少規則。但是，當我們從編程轉向軟件工程時，這些依賴關係的成本會變得微妙地更高，而且有一系列的隱藏成本和問題需要回答。希望你在導入之前考慮到這些成本，而且，希望你知道你什麼時候是在做一個編程項目，而不是在做一個軟件工程項目。

“”’’’

當谷歌的工程師試圖導入依賴時，我們鼓勵他們先問這個（不完整）的問題清單：

該項目是否有你可以運行的測試？這些測試是否通過？誰在提供這個依賴？即使在無擔保的開放源碼軟件項目中，也有相當大的經驗和技能範圍依賴標準庫或的庫的兼容性，與從或中隨機選擇一個項目是完全不同的事情。信譽不是一切，但它值得調研。該項目希望達到什麼樣的兼容性？該項目是否詳細說明了預計會支持什麼樣的用法？該項目有多受歡迎？我們將在多長時間內依賴這個項目？該項目多長時間做一次突破性的改變？項目多久進行一次突破性的變更？

在此基礎上，添加一些簡短的內部重點問題：在谷歌內部實現該功能會有多複雜？我們有什麼激勵措施來保持這個依賴的最新狀態？誰來執行升級？我們預計進行升級會有多大難度？

’’

我們的已經更廣泛地寫到了這一點（）。我們無法給出一個完美的公式來決定從長遠來看，什麼時候引入和重新實施更划算；我們自己在這方面經常失敗。

如何處理導入依賴

簡言之：我們可以做得更好。

’’’

在任何特定的項目中，絕大多數的依賴都是內部開發的。這意味着，我們的內部依賴管理故事中的絕大部分並不是真正的依賴管理，它只是設計上的源碼控制。正如我們所提到的，當提供者和消費者是同一組織的一部分，並且有適當的可見性和持續集成（；見第章）時，管理和控制增加依賴關係所涉及的複雜性和風險是一件容易得多的事情。當你能準確地看到你的代碼是如何被使用的，並準確地知道任何給定變化的影響時，依賴管理中的大多數問題就不再是問題了。源碼控制（當你控制有關項目時）要比依賴管理（當你不控制時）容易得多。

’

當涉及到我們對外部項目的處理時，這種易用性開始失效了。對於我們從開放源碼軟件生態系統或商業夥伴那裏導入的項目，這些依賴關係被添加到我們的一個單獨目錄中，標記爲。我們來看看一個新的項目是如何被添加到的。

’’’“’”

是谷歌的一名軟件工程師，她正在做一個項目，並意識到有一個開源的解決方案可用。她真的很想盡快完成這個項目並進行演示，希望在去度假之前把它解決掉。然後的選擇是，是從頭開始重新實現這個功能，還是下載開放源碼包，並將其添加到第三方。很可能決定更快的開發方案是有意義的：她下載了包，並按照我們的策略中的幾個步驟進行了操作。這是一個相當簡單的清單：確保它在我們的構建系統中構建，確保該軟件包沒有現有的版本，並確保至少有兩名工程師註冊爲（所有者），在有必要進行任何維護時維護該軟件包。讓她的隊友說，是的，我會幫忙。他們都不需要有維護第三方包的經驗，而且他們很方便地避免了對這個包的實施的瞭解。最多，他們對它的界面獲得了一點經驗，作爲使用它來解決預先演示問題的一部分。

’

從這時起，該軟件包通常可以供其他谷歌團隊在他們自己的項目中使用。添加額外的依賴關係的行爲對和來說是完全透明的：他們可能完全沒有意識到他們下載並承諾維護的軟件包已經變得很流行。微妙的是，即使他們在監測他們的軟件包的新的直接使用情況，他們也不一定會注意到他們的軟件包的間接使用的增長。如果他們把它用於演示，而爲我們的搜索基礎設施的內部增加了一個依賴，那麼這個包就會突然從相當無害的地方變成谷歌重要系統的關鍵基礎設施。然而，當考慮是否要添加這個依賴時，我們沒有任何特別的信號提示給他。

’’’’

現在，這種情況有可能是完美的。也許這個依賴項寫得很好，沒有安全漏洞，也沒有被其他項目所依賴。這可能是有可能的，因爲它可以在相當長的時間內不被更新。但這並不一定是明智之舉：外部的變化可能已經優化了它，或者增加了重要的新功能，或者在被發現之前清理了安全漏洞。軟件包存在的時間越長，依賴（直接和間接）就越多。軟件包越是保持穩定，我們就越有可能增加海勒姆定律對被檢查到第三方的版本的特定依賴。

’’’’’

有一天，和被告知，升級是很關鍵的。這可能是軟件包本身或依賴它的項目中的安全漏洞被披露，從而迫使他們進行升級。已經成爲管理層，並且已經有一段時間沒有碰過代碼庫了。在演示後轉到了另一個團隊，並沒有再使用這個包。沒有人改變文件。成千上萬的項目都間接地依賴於此我們不能在不破壞和其他十幾個大團隊的構建的情況下直接刪除它。沒有人對這個包的實現細節有任何經驗。所在的團隊不一定有在消除海勒姆定律隨着時間積累的微妙之處方面經驗豐富。

所有這些都是說。和這個軟件包的其他用戶將面臨一次代價高昂而困難的升級，安全團隊正在施加壓力以立即解決這個問題。在這種情況下，沒有人有執行升級的經驗，而且升級是非常困難的，因爲它涵蓋了許多較小的版本，涵蓋了從最初將軟件包引入第三方到安全披露的整個時期。

’“’’”

我們的第三方包策略不適用於這些不幸的常見情況。我們大致明白，我們需要一個更高的所有權標準，我們需要讓定期更新更容易（和更多的回報），讓第三方包更難成爲孤島，同時也更重要。困難在於，代碼庫維護者和第三方包領導很難說：不，你不能使用這個能完美解決你的開發問題的東西，因爲我們沒有資源不斷爲大家更新新版本。那些流行的、沒有兼容性承諾的項目（比如）尤其有風險：我們的開發者可能非常熟悉使用這種依賴關係來解決谷歌以外的編程問題，但允許它根植於我們的代碼庫結構中是一個很大的風險。在這一點上，我們的代碼庫有幾十年的預期壽命：上游項目如果沒有明確地優先考慮穩定性，就是一種風險。

>>>常見漏洞和暴露

理論上的依賴管理

’’“’”

在瞭解了依賴管理的困難以及它出錯的原因之後，讓我們更具體地討論我們要解決的問題以及我們如何去解決它們。在本章中，我們一直在呼籲：我們如何管理來自我們組織之外（或我們不能完全控制）的代碼：我們如何更新它，如何管理它所依賴的東西？我們需要清楚，這裏的任何好的解決方案都會避免任何形式的需求衝突，包括菱形依賴版本衝突，甚至在一個動態的生態系統中，可能會增加新的依賴或其他需求（在網絡中的任何一點）。我們還需要意識到時間的影響：所有的軟件都有，其中一些將是安全上的關鍵，因此我們的依賴中的一些部分將在足夠長的時間內可更新。

’’’

因此，一個穩定的依賴管理方案必須在時間和規模上具有靈活性：我們不能假設依賴關係中任何特定節點的無限穩定，也不能假設沒有新的依賴被添加（無論是在我們控制的代碼中還是在我們依賴的代碼中）。如果一個依賴管理的解決方案能夠防止你的依賴關係中出現衝突的需求問題，那麼它就是一個好的解決方案。如果它不需要假設依賴版本或依賴扇出的穩定性，不需要組織間的協調或可見性，也不需要大量的計算資源，那麼它就是一個很好的解決方案。

在提出依賴性管理的解決方案時，我們知道有四種常見的選擇，它們至少表現出一些適當的屬性：無任何更改、語義版本控制、捆綁你所需要的一切（不是按項目協調，而是按發行量協調），或直接使用最新版本。

沒有任何更改（也稱爲靜態依賴模型）

’’

確保穩定的依賴關係的最簡單方法是永遠不要更改它們：不要改變，不要改變行爲，什麼都不要。只有在沒有用戶代碼被破壞的情況下才允許修復錯誤。這將兼容性和穩定性置於所有其他方面之上。顯然，這樣的方案並不理想，因爲有無限期的穩定性的假設。如果以某種方式，我們遇到了一個安全問題和錯誤修復都不是問題，並且依賴關係不發生變化的世界，那麼無變化模型就非常有吸引力：如果我們從可滿足的約束開始，我們就能無限期地保持這種特性。

’’’’’

雖然從長遠來看是不可持續的，但實際上，這是每個組織的出發點：直到你證明你的項目的預期生命週期足夠長，有必要進行更改，我們真的很容易生活在一個假設沒有變化的世界裏。同樣重要的是要注意：這可能是大多數新組織的正確模式。相對來說，很少有人知道你開始的項目將運行幾十年，並且需要能夠順利地更新依賴關係。希望穩定是一個真正的選擇，並假裝依賴關係在項目的前幾年是完全穩定的，這顯然要合理得多。

’’

這種模式的缺點是，在足夠長的時間內，它是不存在，並且沒有明確的跡象表明你可以假裝它是合理的。我們沒有針對安全漏洞或其他可能迫使你升級依賴關係的關鍵問題的長期預警系統，這些問題可能會迫使你升級一個依賴由於依賴關係鏈的存在，有一個關係升級在理論上可以成爲你整個依賴關係網絡的強制更新。

在這個模型中，版本選擇很簡單：因爲沒有版本，所以不需要做出任何決定。

語義版本管理

“”

我們今天如何管理依賴關係網絡？事實上的標準是語義版本管理（）。是一種幾乎無處不在的做法，即用三個十進制分隔的整數來表示某些依賴關係（尤其是庫）的版本號，例如或。在最常見的慣例中，三個組成部分的數字代表主要、次要和補丁版本，其含義是：改變主要數字表示對現有的改變，可能會破壞現有的使用，改變次要數字表示純粹增加的功能，不應該破壞現有的使用，而改變補丁版本是保留給非影響的實施細節和被視爲特別低風險的修復。

“”’“”“”“”

由於將主要次要補丁版本分離，假設版本需求通常可以表示爲“任何更新的”，除非不兼容的更改（主版本更改）。通常，我們會看到，這個需求會與中的任何兼容，包括，以及以後的任何東西，但不包括（缺少中引入的）或（中的一些被不兼容地更改）。主要的版本變化是一種重要的不兼容：由於現有功能已更改（或已刪除），因此所有依賴項都存在潛在的不兼容性。只要一個依賴關係使用另一個依賴關係，就會存在版本要求（明確地或隱含地）：我們可能看到和。

如果我們將這些要求標準化，我們可以將依賴網絡概念化爲軟件組件（節點）和它們之間的要求（邊緣）的集合。這個網絡中的邊緣標籤作爲源節點版本的函數而變化，要麼是由於依賴關係被添加（或刪除），要麼是由於源節點的變化而更新需求（例如，要求在依賴關係中添加新的功能）。由於整個依賴網絡是隨着時間的推移而異步變化的，因此，找到一組相互兼容的依賴關係，以滿足應用程序的所有可傳遞需求的過程可能是一個具有挑戰性的過程。的版本滿足求解器非常類似於邏輯和算法研究中的求解器：給定一組約束（依賴邊的版本要求），我們能否爲有關節點找到一組滿足所有約束的版本？大多數軟件包管理生態系統都是建立在這類圖之上的，由其求解器管理。

’’

和它的求解器並不保證對一組給定的依賴性約束存在的解決方案。正如我們已經看到的，無法滿足依賴性約束的情況不斷出現：如果一個較低級別的組件（）進行了重大的數字升級，而一些（但不是全部）依賴它的庫（但不是）已經升級，我們就會遇到菱形依賴問題。

“”

對依賴管理的解決方案通常是基於求解器的。版本選擇是一個運行某種算法的問題，爲依賴網絡中的依賴關係找到一個滿足所有版本要求約束的版本分配。當不存在這種滿意的版本分配時，我們通俗稱它爲依賴地獄。

’

我們將在本章後面詳細介紹的一些限制。

>>>嚴格來說，只是指對主要次要補丁版本號應用語義的新興做法，而不是在以這種方式編號的依賴關係中應用兼容的版本要求。在不同的生態系統中，這些要求有許多細微的變化，但總的來說，這裏描述的的版本號加約束系統是對整個實踐的代表。>>>>事實上，已經證明約束應用於依賴網絡是完備。

捆綁分銷模式

’’’

作爲一個行業，幾十年來我們已經看到了一個強大的依賴管理模型的應用：一個組織收集一組依賴項，找到一組相互兼容的依賴項，並將這些依賴項作爲一個單元發佈。例如，這就是發生在發行版上的情況不能保證包含在發行版中的各個部分是在同一時間點上劃分的。事實上，更有可能的是，低級別的依賴關係比高級別的依賴關係要老一些，只是爲了考慮到集成它們所需要的時間。

“”

這一“圍繞這一切畫一個更大的盒子併發布該系列”的模式引入了全新的參與者：分銷商。儘管所有獨立依賴的維護者可能對其他依賴知之甚少或一無所知，但這些高層次分發者參與了查找、修補和測試要包含的相互兼容的版本集的過程。分銷商是工程師，負責提出一組捆綁在一起的版本，測試這些版本以發現依賴關係樹中的錯誤，並解決任何問題。

“”“”“”

對於外部用戶來說，這非常有效，只要你能正確地依賴這些捆綁的發行版中的一個。這實際上等於把一個依賴網絡變成單個聚合依賴關係併爲其提供版本號相同。與其說我在這些版本中依賴於這個庫，不如說我依賴的版本，或者我依賴於時間時圖中的片段。

在捆綁式分銷方式中，版本選擇由專門的分銷商處理。

直接使用最新版本

’“”’

我們谷歌的一些人一直在推動的模式在理論上是合理的，但給依賴網絡的參與者帶來了新的、沉重的負擔。它完全不同於今天存在於開放源碼軟件生態系統中的模式，而且不清楚作爲一個行業如何從這裏走到那裏。在像谷歌這樣的組織的範圍內，它的成本很高，但很有效，我們覺得它把大部分的成本和激勵放到了正確的地方。我們稱這種模式爲。它可以被看作是基於主幹的開發的依賴管理的延伸：基於主幹的開發討論源代碼控制策略時，我們將該模型擴展到應用於上游依賴關係。

“”

“”的前提是我們可以解除依賴關係，放棄，並依靠依賴提供者在提交之前對整個生態系統進行測試。是一個明確的嘗試，將時間和選擇權從依賴管理的問題中剝離出來：始終依賴所有內容的當前版本，遠不要以你的依賴關係難以適應的方式更改任何事情。一個（無意的）改變或行爲的變化，一般來說會被下游依賴的所捕獲，因此不應該提交。對於這種變化必須發生的情況（即出於安全原因），只有在更新了下游依賴關係或提供了自動化工具來執行更新後，才能進行這種中斷。這種工具對於封閉源碼的下游消費者來說是必不可少的：目標是允許任何用戶有能力更新對變化中的的使用，而不需要對使用或的專家知識。這一特性大大減輕了破壞性變化的大部分旁觀者的成本）。在開源生態系統中，這種責任的哲學轉變最初是很難激勵的：把測試和改變所有下游客戶的負擔放在提供者身上，是對提供者責任的重大修改。

“”’’

模型中的變化不會被簡化爲我認爲這很安全或不安全。相反，測試和系統用於針對可見的依賴進行測試，以通過實驗確定變化的安全性。因此，對於一個只改變效率或實現細節的變化，所有可見的受影響的測試都可能通過，這表明該變化沒有明顯的影響用戶的方式它是安全的提交。修改中更明顯的可觀察部分（語法上或語義上），往往會產生成百上千的測試失敗。這時就需要修改建議的作者來決定解決這些故障的工作是否值得提交修改的結果。如果做得好，作者將與他們所有的依賴者一起工作，提前解決測試失敗的問題（即解除測試中的脆性假設），並有可能創建一個工具來執行儘可能多的必要重構。

這裏的激勵結構和技術假設與其他場景有實質性的不同：我們假設存在單元測試和，我們假設提供者將受到下游依賴關係是否會被破壞的約束，我們假設使用者保持他們的測試通過並以支持的方式依賴他們的依賴關係。這在一個開源的生態系統中（可以提前發佈修復程序）比在面對隱藏閉源的依賴關係時效果要好得多。提供者在以一種可以順利遷移的方式進行更改時，會受到激勵。使用者被激勵保持他們的測試工作，以避免被標記爲低信號測試並可能被跳過，從而減少該測試所提供的保護。

“”

在方法中，通過詢問“哪個是最新的穩定版本？”來處理版本選擇。如果提供者能夠負責任地做出更改，則所有更改都將順利進行。

>>>特別是作者和其他在谷歌社區。

（語義版本管理）的侷限性

’

方法可能建立在公認的版本控制實踐（基於主幹的開發）的基礎之上，但在規模上基本沒有得到驗證。是當今依賴性管理的事實標準，但正如我們所建議的，它並非沒有侷限性。因爲這是一種非常流行的方法，所以值得更詳細地研究它，並強調我們認爲可能存在的陷阱。

’’“”’

在的定義中，有很多東西需要解讀，虛線三重版本號到底意味着什麼。這是一個承諾嗎？還是爲一個版本選擇的版本號是一種估計值？也就是說，當的維護者發佈一個新版本，並選擇這是一個大版本、小版本還是補丁版本時，他們在說什麼？是否可以證明從升級到是安全且容易的，因爲只有的增加和錯誤的修正？當然不是。在簡單的增加的情況下，的不守規矩的用戶可能會做很多事情，導致構建中斷或行爲改變。從根本上說，當只考慮源時，你不能證明任何關於兼容性的事情；你必須知道你在問哪些兼容性的問題。

“”’’’

然而，當我們談論依賴網絡和應用於這些網絡的求解器時，這種預估兼容性的想法就開始弱化了。這種表述的基本問題是傳統中的節點值和依賴關係圖中的版本值之間的區別。三種圖中的節點是真或假。依賴關係圖中的版本值（）是由維護者提供的，是對新版本的兼容程度的預估，給定使用以前版本的代碼。我們將所有的版本滿足邏輯建立在一個不穩定的基礎之上，將預估和自我證明視爲絕對。正如我們將看到的，即使這在有限的情況下是可行的，但從總體上看，它不一定有足夠的仿真度來支撐一個健康的生態系統。

如果我們承認是一個有損失的預估，並且只代表可能的變化範圍的一個子集，我們就可以開始把它看作是一個鈍器。在理論上，它作爲一種速記工具是很好的。在實踐中，尤其是當我們在它上面構建求解器時，可能（也確實）會因爲過度約束和保護不足而讓我們失敗。

>’’>>例如：一個實現不佳的，提前添加了新的，導致定義衝突。或者，使用語言反射來依賴提供的精確數量的，如果這個數量發生變化，就會引入崩潰。這些都不應該發生，而且即使是意外發生，也肯定很罕見關鍵是提供者無法證明兼容性。

可能會過度限制

’“”’

考慮一下當被認定爲不只是一個單體時會發生什麼：一個庫內幾乎都有獨立的接口。即使只有兩個函數，我們也可以看到對我們過度約束的情況。想象一下，確實只由和這兩個函數組成。我們的中層依賴關係和只使用。如果的維護者對進行了破壞性的修改，那麼在世界中，他們就有責任提升的主要版本。已知和依賴於依賴解決器不會接受這種依賴的版本。然而，在現實中，這些庫可以完美地協同工作：只有改變了，而且是未使用的。當我做了一個突破性的改變；我必須提高主要版本號的固有壓縮不適用單個原子單元的粒度時，它是有損的。雖然有些依賴關係可能足夠精細，所以這是很準確的，這不是生態系統的標準。

如果過度約束，無論是由於不必要的嚴重的版本升級，還是由於對數字的應用不夠精細，自動軟件包管理器和求解器將報告你的依賴關係不能被更新或安裝，即使忽略檢查，一切都能完美地協同工作。任何曾經在升級過程中被暴露在依賴地獄中的人都會發現這一點特別令人生氣：其中很大一部分工作完全是浪費時間。

>>>節點生態系統有值得注意的依賴關係示例，這些依賴關係只提供一個。

可能過度承諾

’“”“”’“”“”

另一方面，的應用做出了明確的假設，即提供者對兼容性的預估可以完全預測，並且更改分爲三個類：破壞（通過修改或刪除）、嚴格的添加或不影響。如果通過對語法和語義變化進行分類，完全忠實地表示了變化的風險，那麼我們如何描述爲時間敏感增加一毫秒延遲的更改？或者，更合理的說法是：我們如何描述改變日誌輸出格式的更改？或者改變了我們導入外部依賴關係的順序？或者改變了在無序流中返回結果的順序？僅僅因爲這些變更不屬於問題中的語法或契約的一部分，就認爲這些變更是“安全的”是合理的嗎？如果文檔中說這在未來可能會發生變化呢？或者被命名爲？

“”’’“”“”“”’>’

補丁版本在理論上只是改變了實現細節，是安全的更改，這種想法絕對違背了谷歌對定律的經驗只要有足夠數量的用戶，你的系統的每一個可觀察到的行爲都會被某人所依賴。改變依賴關係的導入順序，或者改變一個無序使用者的輸出順序，在規模上將不可避免地打破一些使用者（也許是錯誤地）所依賴的假設。破壞性變化這個術語本身就具有誤導性：有些更改在理論上是突破性的，但在實踐中是安全的（刪除未使用的）。也有一些變化在理論上是安全的，但在實踐中會破壞客戶端代碼（我們之前的任何一個定律的例子）。我們可以在任何依賴管理系統中看到這一點，其中的版本號要求系統允許對補丁號進行限制：如果你可以說需要>，而不是需要，這顯然是承認補丁版本中存在明顯的差異。

’“”’

孤立的變化不是破壞性的，也不是非破壞性的這種說法只能在它被使用的情況下進行評估。在這是一個破壞性的變化的概念中沒有絕對的真理；一個變化只能被看作是對（已知或未知的）現有用戶和用例的破壞。我們如何評估一個變化的現實，本質上依賴於制定的依賴管理中所沒有的信息：下游用戶是如何使用這個依賴的？

’’’

正因爲如此，約束求解器可能會報告說，你的依賴關係可以一起工作，但它們卻不能一起工作，這可能是因爲錯誤地應用了一個坑點，或者是因爲你的依賴網絡中的某些東西與不被認爲是可觀察表面的一部分的東西存在定律依賴。在這些情況下，你可能會有構建錯誤或運行時錯誤，其嚴重性在理論上沒有上限。

>’’>>值得注意的是：根據我們的經驗，這樣命名並不能完全解決用戶訪問私有的問題。首選對所有形式的的公共私人訪問有良好控制的語言。

動機

’’’

還有一種觀點認爲，並不總是鼓勵創建穩定的代碼。對於任意依賴的維護者來說，有一個可變的系統激勵機制來不做破壞性的修改和提升主要版本。一些項目非常關心兼容性，並將竭盡全力避免出現重大版本衝突。其他項目則更加積極，甚至有意在一個固定的時間表上提升主要版本。問題是，任何給定依賴項的大多數用戶都是間接用戶他們沒有任何重要的理由知道即將發生的更改。即使是最直接的用戶也不會訂閱郵件列表或其他發佈通知。

’“”

所有這些都表明，不管有多少用戶會因爲採用不兼容的而感到不便，維護者只需承擔由此帶來的版本升級的一小部分成本。對於同時也是用戶的維護者來說，也會有一個激勵機制，那就是：在沒有遺留限制的情況下，設計一個更好的接口總是更容易。這也是爲什麼我們認爲項目應該發表關於兼容性、使用和破壞性變化的明確聲明的部分原因。即使這些都是盡力而爲、不具約束力或被許多用戶忽略的，但它仍然爲我們提供了一個起點，讓我們可以在不引入這些相互衝突的激勵結構的情況下，思考突破性的更改重大版本升級是否“值得”。

’

和都很好地處理了這個問題：在他們的標準包管理生態系統中，相當於一個主要版本的升級被認爲是一個完全新的包。這有一定的正義感：如果你願意爲你的包打破向後的兼容性，爲什麼我們要假裝這是同一套？重新打包和重命名一切似乎是一個合理的工作量，期望從提供者那裏得到，以換取他們接受核選項並拋棄向後兼容性。

’’’

最後，還有過程中的人爲失誤。一般來說，版本升級應該和語法變化一樣適用於語義變化；改變的行爲和改變其結構一樣重要。雖然開發工具來評估任何特定的版本是否涉及一組公共的語法變化是可行的，但是要辨別是否存在有意義的、有意的語義變化在計算上是不可行的。實際上，即使是識別語法變化的潛在工具也是有限的。在幾乎所有的情況下，對於任何給定的變化，是否要碰撞主要版本、次要版本或補丁版本，都取決於提供者的人爲判斷。如果你只依賴少數幾個專業維護的依賴關係，那麼你對這種形式的文書錯誤的預期暴露可能很低。如果你的產品下面有成千上萬的依賴關係網絡，你應該準備好接受某種程度的混亂，僅僅是因爲人爲錯誤。

>“”“’”>>在一個無處不在的單元測試的世界裏，我們可以識別需要改變測試行爲的變化，但仍然很難在算法上將這是一個行爲上的變化與這是一個對不打算承諾的行爲的錯誤修復分開。>>>>所以，當長期重要時，選擇維護良好的依賴關係。

最小版本選擇

’’

年，作爲爲編程語言構建軟件包管理系統的系列文章的一部分，谷歌自己的描述了依賴性管理的一個有趣變化。最小版本選擇（）。當更新依賴網絡中某個節點的版本時，它的依賴關係有可能需要更新到較新的版本，以滿足更新的需求這可能會觸發進一步的變化。在大多數約束滿足版本選擇公式中，這些下游依賴關係的最新版本被選中：畢竟，你最終需要更新到這些新版本，對嗎？

’’“”’’

做出了相反的選擇：當的規範要求時，我們會直接嘗試，即使有的版本。這產生了高仿真的構建，其中用戶構建的依賴關係儘可能地接近作者開發的依賴關係。在這一點上揭示了一個極其重要的事實：當說它需要時，這幾乎肯定意味着的開發者安裝了。假設維護者在發佈之前進行了哪怕是基本的測試，我們至少有關於該版本的和版本的互操作性測試的軼事證據。這不是，也不能證明所有的東西都一起進行了單元測試，但它是有意義的。

’’“’’”

在沒有準確預測未來而產生的準確輸入約束的情況下，最好是儘可能地向前跳躍。正如將一小時的工作投入到項目中通常比一次完成一年的工作更安全一樣，依賴項更新中的小步驟也更安全。只是在每個受影響的依賴關係上向前走了一段距離，然後說：好的，我已經向前走了一段距離，足以得到你所要求的東西（而不是更遠）。你爲什麼不運行一些測試，看看情況是否良好？

’“”

在的理念中，承認較新的版本在實踐中可能會帶來不兼容，即使版本號在理論上說不兼容。這就是認識到的核心問題，無論是否使用：在將軟件更改壓縮爲版本號的過程中，仿真度有所損失。提供了一些額外的實際仿真度，試圖產生最接近那些可能已經被一起測試過的版本的選定版本。這可能是一個足夠的推動力，使更大的依賴網絡正常運作。不幸的是，我們還沒有找到一個很好的方法來經驗性地驗證這個想法。是否能在不解決該方法的基本理論和激勵問題的情況下使“足夠好”還沒有定論，但我們仍然認爲，它代表了約束應用的一個明顯改進，正如今天所使用的那樣。

>“”>>，最小的版本選擇，年月日，。>>’>>如果這個假設不成立，你真的應該停止對的依賴。

那麼，是否有效？

’

在有限的範圍內運行良好。然而，認識到它實際上在做什麼，以及它不能做什麼，是非常重要的。將工作得很好，前提是

你的依賴關係提供者準確且負責（以避免衝突中的人爲錯誤）你的依賴關係是細粒度的（以避免在更新依賴關係中未使用不相關的時錯誤地過度約束，以及不可滿足需求的相關風險）。所有的所有使用都在預期的使用範圍內（以避免被一個假定的兼容變化以令人驚訝的方式破壞，無論是直接的還是在你過渡依賴的代碼中）。

當你的依賴關係中只有少數精心選擇和維護良好的依賴關係時，可以成爲一個完全合適的解決方案。

然而，我們在谷歌的經驗表明，你不太可能在規模上擁有這三個屬性中的任何一個，並且隨着時間的推移保持它們持續工作。規模往往是顯示弱點的東西。隨着你的依賴網絡規模的擴大，無論是每個依賴的規模還是依賴的數量（以及由多個項目依賴於同一外部依賴網絡而產生的任何單一效應），的複合仿真度損失將開始佔據主導地位。這些故障表現爲誤報（理論上應該有效的實際不兼容版本）和漏報（求解器不允許的兼容版本以及由此產生的依賴地獄）。

無限資源下的依賴管理

’’’

’’’

在考慮依賴管理解決方案時，有一個有用的思想實驗：如果我們都能獲得無限的計算資源，依賴管理會是什麼樣子？也就是說，如果我們不受資源限制，而只受限於組織間的可見性和弱協調性，那麼我們能希望的最好結果是什麼？正如我們目前所看到的，該行業依賴的原因有三個：

它只需要本地信息（提供者不需要知道下游用戶的標識符）它不需要測試的可用性（在行業中還沒有普及，但在未來十年肯定會向這個方向發展）、運行測試的計算資源或監控測試結果的系統的可用性。這是現成的做法

“”’

對本地信息的要求並不是真正必要的，特別是因爲依賴性網絡往往只在兩種環境中形成：

在一個組織內在開放源碼軟件生態系統內，即使項目不一定合作，源碼也是可見的

’’’

在這兩種情況下，關於下游使用情況的重要信息是可用的，目前還沒有暴露或採取行動。也就是說，的有效主導地位的部分原因是我們選擇忽略了理論上我們可以獲得的信息。如果我們能夠獲得更多的計算資源，並且依賴性信息能夠很容易地浮出水面，社區可能會發現它的用途。

’’

雖然一個開放源碼軟件包可以有無數的閉源依賴，但常見的情況是，受歡迎的開放源碼軟件包在公開和私下裏都很受歡迎。依賴網絡不會（不能）積極地混合公共和私人依賴關係：通常，有一個公共子集和一個單獨的私有子集。

“”’’’

接下來，我們必須記住的意圖：據我估計，這種變化將很容易（或不容易）被採納。是否有更好的方式來傳達這一信息？是的，以實踐經驗的形式，證明該變化是容易採用的。我們如何獲得這種經驗呢？如果我們大部分（或者至少是有代表性的樣本）的依賴關係是公開的，那麼我們就在每一個提議的改變中對這些依賴關係進行測試。有了足夠多的這樣的測試，我們至少有了一個統計學上的論據，即從實際的定律意義上來說，這個變化是安全的。測試仍然通過，變化就是好的這與影響、修復或介於兩者之間的事情無關；沒有必要進行分類或評估。

“”

想象一下，開放源碼軟件的生態系統轉向一個變化伴隨着證據的世界，即它們是否安全。如果我們把計算成本排除在外，那麼這有多安全的真相來自於在下游依賴關係中運行受影響的測試。

“”“”“”

即使沒有正式的應用於整個開放源碼生態系統，我們當然也可以使用這樣的依賴關係和其他次級信號來做更有針對性的預提交分析。優先考慮大量使用的依賴項中的測試。優先考慮維護良好的依賴項中的測試。優先考慮那些有提供良好信號和高質量測試結果歷史的依賴關係中的測試。除了根據有可能給我們提供最多實驗性變化質量信息的項目來確定測試的優先級外，我們還可以利用變化作者的信息來幫助估計風險和選擇適當的測試策略。如果目標是任何人所依賴的都是一種破壞性的改變，運行所有受影響的測試在理論上是必要的。如果我們認爲目標更符合風險緩解，那麼統計論證就會成爲一種更有吸引力（和成本效益）的方法。

在第章中，我們確定了四種變化，從純粹的重構到對現有功能的修改。考慮到基於的依賴更新模型，我們可以開始將這些變化種類映射到類似的模型上，對於這些變化，變更的作者會估計風險並應用適當的測試水平。例如，僅修改內部的純重構變化可能被認爲是低風險的，並證明僅在我們自己的項目和重要的直接依賴者中運行測試。另一方面，刪除一個廢棄的接口或改變可觀察到的行爲的變化可能需要我們進行儘可能多的測試。

’’

爲了應用這樣的模式，我們需要對開放源碼軟件的生態系統進行哪些改變？不幸的是，相當多

所有的依賴項必須提供單元測試。儘管我們正不可阻擋地走向一個單元測試被廣泛接受和無處不在的世界，但我們還沒有到那一步。瞭解大多數開放源碼軟件生態系統的依賴網絡。目前尚不清楚是否有任何機制可用於在該網絡上執行圖形算法信息是公開的，可用的，但實際上沒有被普遍索引或使用。許多軟件包管理系統依賴性管理生態系統允許你看到一個項目的依賴項，但不允許查看反向邊緣和依賴關係。用於執行的計算資源的可用性仍然非常有限。大多數開發者沒有機會使用構建和測試的計算集羣。依賴項通常以固定方式表示。作爲的維護者，如果和的依賴項顯式地依賴於的特定固定版本，那麼我們就不能通過和的測試實驗性地運行更改。我們可能希望在計算中明確包括歷史和聲譽。一個提議的變更打破了一個長期以來一直通過測試的項目，這給我們提供了一種不同形式的證據，而不是一個最近才添加的項目中的破壞，並且由於不相關的原因而有破壞的歷史。

’“”

這裏面有一個規模問題：你要針對網絡中每個依賴關係的哪些版本來測試預提交的變化？如果我們針對所有歷史版本的完整組合進行測試，我們將消耗大量的計算資源，即使按照谷歌的能力。這個版本選擇策略最明顯的簡化似乎是測試當前的穩定版本（畢竟，基於主幹的開發是目標）。因此，在資源無限的情況下，依賴管理的模式實際上就是的模式。懸而未決的問題是，該模型是否可以有效地適用於更實際的資源可用性，以及提供者是否願意承擔更大的責任來測試其變化的實際安全性。認識到我們現有的低成本設施是對我們正在尋找的難以計算的真相的過度簡化，仍然是一項有益的工作。

>’>>因爲公共開放源碼軟件的依賴網絡一般不能依賴一堆私人節點，儘管有圖形固定。

>>>或者是非常接近於此的東西。

導出依賴

’’

到目前爲止，我們只討論了依賴；也就是說，這取決於其他人編寫的軟件。同樣值得思考的是，我們如何構建可以作爲依賴使用的軟件。這不僅僅是打包軟件並將其上傳到存儲庫的機制：我們需要考慮提供軟件的好處、成本和風險，對我們和我們的潛在依賴者都是如此。

“”“”’

像開源庫這樣無害的慈善的行爲，有兩種主要方式可以成爲一個組織的可能損失。首先，如果實施不力或維護不當，它最終會拖累你的組織的聲譽。正如社區的說法，我們應該優先考慮社區優先於代碼。如果你提供了很好的代碼，但卻是一個糟糕的社區成員，這仍然會對你的組織和更廣泛的社區造成傷害。其次，如果你不能保持同步，一個善意的發佈會成爲對工程效率的一種負擔。只要有時間，所有的分支都會變得沉重。

示例：開源

’’

’’“”“”’’

對於信譽的損失，可以考慮像谷歌在年左右開放我們的命令行標誌庫的經驗的情況。當然，回饋開源社區是一個純粹的善舉，不會返回困擾我們，對嗎？遺憾的是，不是。有很多原因共同促使這一善舉變成了肯定會傷害我們的聲譽，也可能會損害開放源碼社區

當時，我們沒有能力進行大規模的重構，所以所有內部使用該庫的東西都必須保持相同我們不能把代碼移到代碼庫的新位置。我們將我們的資源庫隔離成內部開發的代碼（如果需要分支，可以自由複製，只要正確重命名）和可能有法律許可問題的代碼（可能有更細微的使用要求）。如果一個開放源碼軟件項目接受來自外部開發者的代碼，這通常是一個法律問題項目發起人並不擁有該貢獻，他們只擁有對它的使用權利。

“”’’’

因此，項目註定是一個拋出的版本，或者是一個斷開的分支。貢獻給項目的補丁不能被重新納入谷歌內部的原始源碼，我們也無法將該項目轉移到中，因爲我們還沒有掌握這種重構形式，也無法讓內部的一切都依賴於開放源碼版本。

“”’’

此外，像大多數組織一樣，我們的優先事項隨着時間的推移而發生了改變。在最初發布庫的時候，我們對傳統領域（網絡應用、搜索）以外的產品感興趣，包括像谷歌地球這樣的產品，它有一個更傳統的發佈機制：爲各種平臺預編譯的二進制文件。在世紀末，在我們的中的一個庫，特別是像這樣的低級的東西，被用在各種平臺上，這是不正常的，但也不是沒有。隨着時間的推移和谷歌的成長，我們的關注點逐漸縮小，除了我們內部配置的工具鏈之外，很少有任何庫是用其他東西構建的，然後部署到我們的生產機羣。對於正確支持像這樣的開放源碼軟件項目來說，可移植性問題幾乎是不可能維持的：我們的內部工具根本沒有對這些平臺的支持，而我們的普通開發人員也不需要與外部工具進行互動。爲了保持可移植性，這是一場持久戰。

’’

隨着最初的作者和開放源碼軟件支持者轉到新的公司或新的團隊，最終很明顯，內部沒有人真正支持我們的開放源碼軟件項目沒有人能夠將這種支持與任何特定團隊的優先事項聯繫起來。考慮到這不是特定團隊的工作，也沒人能說清楚爲什麼它很重要，我們基本上讓這個項目在外部爛掉也就不奇怪了。隨着時間的推移，內部和外部的版本慢慢發生了分歧，最終一些外部開發者把外部的版本拆分，給了它一些適當的關注。

“”“’”’

除了最初的“哦，看，谷歌爲開源世界做出了一些貢獻”之外，沒有任何一部分能讓我們看起來很好，但考慮到我們工程組織的優先事項，它的每一個小部分都是有意義的。我們這些與它關係密切的人已經瞭解到，“在沒有長期支持它的計劃（和授權）的情況下，不要發佈任何東西。”整個谷歌工程部門是否已經瞭解到這一點還有待觀察。這是一個大組織。

“”“”

除了模糊的“我們看起來很糟糕”之外，這個故事中還有一些部分說明了我們如何受到由於發佈維護不當的外部依賴關係而產生的技術問題的影響。雖然庫是共享的，但被忽略了，但仍然有一些由支持的開源項目，或者需要在生態系統之外共享的項目。毫不奇怪，這些其他項目的作者能夠識別該庫內部和外部分支之間的公共子集。由於該通用子集在兩個版本之間保持了相當長的一段時間的穩定，因此它悄悄地成爲了在年到年間具有不同尋常的可移植性需求的少數團隊的“實現方法”。他們的代碼可以在內部和外部生態系統中構建，根據環境的不同，可以切換出庫的分支版本。

’’

然後，由於不相關的原因，庫團隊開始調整內部標誌實現中可觀察到但沒有記錄的部分。在這一點上，所有依賴於不支持的外部分支的穩定性和等效性的人都開始尖叫，他們的構建和發佈突然被破壞。一個值得在谷歌集羣中使用數千個的優化機會被大大推遲了，不是因爲難以更新億行代碼所依賴的，而是因爲極少數項目依賴於未經預測和意外的東西。定律再一次影響了軟件的變化，在這種情況下，甚至是由不同組織維護的分叉。

>’’>>這並不是說這是對的或明智的，只是作爲一個組織，我們讓一些事情從縫隙中溜走。>>>>往往是通過試驗和錯誤。

案例研究：

’’

一個更嚴重的技術依賴將我們自己暴露在意料外的更大風險中的例子來自於發佈谷歌的服務。這項服務允許用戶在現有框架的基礎上用幾種流行的編程語言之一編寫他們的應用程序。只要應用程序是用適當的存儲狀態管理模型編寫的，服務允許這些應用程序擴展到超大規模的使用水平：備份存儲和前端管理是由谷歌的生產基礎設施按需管理和複製的。

’“”“”’’’’’’

最初，對的支持是使用舊版本的解釋器運行的位構建。系統本身（當然）是在我們的中實現的，並與我們其他的通用工具一起構建，用和來支持後端。年，我們開始對運行時進行重大更新，同時安裝編譯器和標準庫，其結果是我們有效地將用當前編譯器構建的代碼與使用更新的版本的代碼聯繫起來一個項目如果升級了這些依賴中的一個，就同時升級了另一個。對於大多數項目來說，這並不是一個問題。對於少數項目，由於邊緣案例和海勒姆定律，我們的語言平臺專家最終做了一些調查和調試，以解除過渡的障礙。在一個可怕的海勒姆定律與商業實際相結合的例子中，發現它的許多用戶，即我們的付費客戶，不能（或不願）更新：要麼他們不想改變到較新的版本，要麼他們負擔不起從位到位的資源消耗變化。因爲有一些客戶爲的服務支付了大量的費用，能夠提出一個強有力的商業方案，即必須推遲強制切換到新的語言和編譯器版本。這就意味着的依賴關係中的每一段代碼都必須與舊的編譯器和標準庫版本兼容：對該基礎設施的任何錯誤修復或性能優化都必須跨版本兼容。這種情況持續了近三年。

“”’’

有了足夠多的用戶，你的系統的任何可觀察到的都會被某些人所依賴。在谷歌，我們把所有的內部用戶都限制在我們的技術堆棧的範圍內，並通過和代碼索引系統確保對他們的使用情況的可見性，所以更容易確保有用的改變是可能的。當我們從源碼控制轉向依賴管理，並失去了對代碼使用情況的可見性，或者受到來自外部團體（尤其是那些付錢給你的團體）的高優先級的影響時，要做出純粹的工程權衡就變得更加困難。發佈任何類型的都會使你暴露在競爭性的優先級和外部人員不可預見的限制的可能性中。這並不是說你不應該發佈；這只是爲了提醒你：的外部用戶比內部用戶的維護成本高得多。

’

與外界分享代碼，無論是作爲開放源碼發佈還是作爲閉源庫發佈，都不是一個簡單的慈善問題（在開放源碼的情況下）或商業機會（在閉源的情況下）。你無法監控的依賴用戶，在不同的組織中，有不同的優先級，最終會對該代碼施加某種形式的海勒姆定律的慣性。特別是當你工作的時間尺度較長時，你不可能準確地預測可能成爲有價值的必要或有用的變化的集合。當評估是否要發佈一些東西時，要意識到長期的風險：外部共享的依賴關係隨着時間的推移，修改的成本往往要高得多。

總結

’’’

依賴管理在本質上是一種挑戰我們正在尋找管理複雜的表面和依賴關係網絡的解決方案，這些依賴關係的維護者通常很少或根本沒有協調的假設。管理依賴關係網絡的事實上的標準是語義版本管理（），它對採用任何特定變化的感知風險提供了有損的總結。的前提是，在不知道有關的是如何被消費的情況下，我們可以先驗地預測變化的嚴重性。海勒姆定律告訴我們並非如此。然而，在小規模下工作得足夠好，當我們包括方法時，甚至更好。隨着依賴網絡規模的擴大，中的定律問題和保真度損失使得管理新版本的選擇越來越困難。

然而，我們有可能走向這樣一個世界：維護者提供的兼容性估計（版本號）被放棄，而採用經驗驅動的證據：運行受影響的下游包的測試。如果提供者承擔起更大的責任，針對他們的用戶進行測試，並明確宣傳預計會有哪些類型的變化，我們就有可能在更大的範圍內建立更高仿真的依賴網絡。

內容提要

’“”

“”’

更傾向於源控制問題，而不是依賴管理問題：如果你能從你的組織中獲得更多的代碼，以便有更好的透明度和協調，這些都是重要的簡化。

對於一個軟件工程項目來說，增加一個依賴關係並不是免費的，建立一個持續的信任關係的複雜性是具有挑戰性的。將依賴關係導入你的組織需要謹慎行事，並瞭解持續支持的成本。

依賴關係是一個合同：有付出就有收穫，提供者和消費者在該合同中都有一些權利和責任。供應商應該清楚地瞭解他們在一段時間內試圖承諾什麼。

是對人類認爲這一變化的風險有多大的一種有損壓縮的速記估計。與軟件包管理器中的求解器一起，將這些估計值升級爲絕對值。這可能會導致過度約束（依賴性地獄）或不足約束（應該一起工作的版本卻沒有）。

相比之下，測試和提供了一組新版本是否能一起工作的實際證據。