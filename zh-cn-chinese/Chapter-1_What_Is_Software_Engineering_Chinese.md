第一章軟件工程是什麼？

我們看到，編程和軟件工程之間有三個關鍵的區別：時間、規模和權衡取捨。在一個軟件工程項目中，工程師需要更多關注時間成本和需求變更。在軟件工程中，我們需要更加關注規模和效率，無論是對我們生產的軟件，還是對生產軟件的組織。最後，作爲軟件工程師，我們被要求做出更復雜的決策，其結果風險更大，而且往往是基於對時間和規模增長的不確定性的預估。

“”’’’

在谷歌內部，我們有時會說，軟件工程是隨着時間推移的編程。編程當然是軟件工程的一個重要部分：畢竟，編程首先是生成新軟件的方式。如果你接受這一區別，那麼很明顯，我們可能需要在編程任務（開發）和軟件工程任務（開發、修改、維護）之間進行劃分。時間的增加爲編程增加了一個重要的新維度。這是一個立方體三維模型不是正方形的二維模型，距離不是速度。軟件工程不是編程。

“”“”

瞭解時間對程序的影響的一種方法是思考“代碼的預期生命週期是多少？”這個問題的合理答案大約相差倍。想到生命週期幾分鐘的代碼和想象將持續執行幾十年的代碼是一樣合理。通常，週期短的代碼不受時間的影響。對於一個只需要存活一個小時的程序，你不太可能考慮其底層庫、操作系統（）、硬件或語言版本的新版本。這些短期系統實際上“只是”一個編程問題，就像在一個維度中壓縮得足夠扁的立方體是正方形一樣。隨着我們擴大時間維度，允許更長的生命週期，改變顯得更加重要。在十年或更長的時間裏，大多數程序依賴關係，無論是隱式的還是顯式的，都可能發生變化。這一認識是我們區分軟件工程和編程的根本原因。

>’“”“”>>我們不是指“開發生命週期”，而是指“維護生命週期”代碼將持續構建、執行和維護多長時間？這個軟件能提供多長時間的價值？

’’

這種區別是我們所說的軟件可持續性的核心。如果在軟件的預期生命週期內，你能夠對任何有價值的變化做出反應，無論是技術還是商業原因，那麼你的項目是可持續的。重要的是，我們只關注能力你可能因爲缺乏價值或其他優先事項而選擇不進行特定的升級。當你基本上無法對基礎技術或產品方向的變化做出反應時，你就把高風險賭注押在希望這種變化永遠不會變得至關重要。對於短期項目，這可能是一個安全的賭注。幾十年後，情況可能並非如此。

“”

另一種看待軟件工程的方法是考慮規模。有多少人蔘與？隨着時間的推移，他們在開發和維護中扮演什麼角色？編程任務通常是個人的創造行爲，但軟件工程任務是團隊的工作。早期定義軟件工程的嘗試爲這一觀點提供了一個很好的定義：“多人開發的多版本程序”。這表明軟件工程和程序設計之間的區別是時間和人的區別。團隊協作帶來了新的問題，但也提供了比任何單個程序員更多的潛力來產生有價值的系統。

>“”’>>這也許是一個合理且簡單的技術債務定義：那些“應該”做卻還未完成的事我們代碼的現狀和理想代碼之間的差距。>>>>也要考慮我們是否提前知道項目將長期存在的問題。>>“”>>關於這句話的原始出處有一些疑問；人們似乎一致認爲它最初是由或提出的，但它可能完全是由編造的。這句話的常見引文是軟件工程技術。由北約科學委員會主辦的會議報告年月日至日，意大利羅馬，布魯塞爾，北約科學事務司。

團隊組織、項目組成以及軟件項目的策略和實踐都支配着軟件工程複雜性。這些問題是規模所固有的：隨着組織的增長和項目的擴展，它在生產軟件方面是否變得更加高效？我們的開發工作流程隨着我們的發展，效率會提高，還是版本控制策略和測試策略的成本會相應增加？從軟件工程的早期開始，人們就一直在討論溝通和人員的規模問題，一直追溯到《人月神話》。這種規模問題通常是策略的問題，也是軟件可持續性問題的基礎：重複做我們需要做的事情要花多少錢？

’’

我們還可以說，軟件工程與編程的不同之處在於需要做出的決策的複雜性及其風險。在軟件工程中，我們經常被迫在幾個路徑之間做評估和權衡，有時風險很高，而且價值指標不完善。軟件工程師或軟件工程負責人的工作目標是實現組織、產品和開發工作流程的可持續性和管理擴展成本爲目標。考慮到這些投入，評估你的權衡並做出理性的決定。有時，我們可能會推遲維護更改，甚至接受擴展性不好的策略，因爲我們知道需要重新審視這些決策。這些決策應該是明確的和清晰的遞延成本。

“”“”“”’’’

在軟件工程中很少有一刀切的解決方案，這本書也是如此。考慮到“這個軟件能使用多久”的合理答案是倍，而“你的組織中有多少工程師”的範圍可能是，誰知道“你的項目有多少計算資源可用”的範圍是多少，谷歌的經驗可能與你的經驗不一致。在本書中，我們的目標是介紹我們在構建和維護軟件方面的發現，這些軟件預計將持續數十年，擁有數萬計的工程師和遍佈世界的計算資源。我們發現在這種規模下所需要的大多數做法也能很好地適用於複雜度較小的系統：考慮一下這是一個我們認爲在你們擴大的時候可以做的很好的工程生態系統的報告。在一些地方，超大規模有其自身的成本，我們更傾向於不付出額外的管理成本。我們發出警告。希望如果你的組織發展到足以擔心這些成本，你可以找到更好的答案。

’

在我們討論團隊合作、文化、策略和工具的細節之前，讓我們首先闡述一下時間、規模和權衡這些主要主題。

>>>關於軟件工程的論文（波士頓：，）。

時間與變化’

當新手學習編程時，編碼的生命週期通常以小時或天爲單位。編程作業和練習往往是一次編寫的，幾乎沒有重構，當然也沒有長期維護。這些程序通常在初始生產後不再重建或再次執行。這在教學環境中並不奇怪。也許在中學或中學後教育，我們可以找到團隊項目課程或實踐論文。如果是這樣的，項目很可能是學生們的代碼生命週期超過一個月左右的時間。這些開發人員可能需要重構一些代碼，也許是爲了應對不斷變化的需求，但他們不太可能被要求處理環境的更大變化。

我們還在常見的行業環境中找到短期代碼的開發人員。移動應用程序的生命週期通常很短，而且無論好壞，完全重寫都是相對常見的。初創初期的工程師可能會正確地選擇關注眼前目標而不是長期投資：公司可能活得不夠長，無法從回報緩慢的基礎設施投資中獲益。一個連續工作多年的開發人員可能有年的開發經驗，並且鮮少或根本沒有維護任何預期存在超過一年或兩年的軟件的經驗。

’’

另一方面，一些成功的項目實際上有無限的生命週期：我們無法準確地預測搜索、內核或服務器項目的終點。對於大多數谷歌項目，我們必須假設它們將無限期地存在，我們無法預測何時不需要升級依賴項、語言版本等。隨着他們生命週期的延長，這些長期項目最終會有一種不同於編程任務或初創企業發展不同的感受。

“”’’

考慮圖，它演示了兩個軟件項目的“預期生命週期”的範圍。對於從事預期生命週期爲小時的任務的程序來說，什麼類型的維護是合理的？也就是說，如果你正在編寫一個只需執行一次的腳本，這時操作系統推出了新版本，你應該放下手頭的工作去升級系統嗎？當然不是：升級並不重要。但與之相反，如果谷歌搜索停留在世紀年代的操作系統版本上顯然是一個問題。

>“”>>除了死亡、稅收和短暫的移動應用生命，沒有什麼是確定的

’’

’’’

預期生命週期範圍的低點和高點表明某處有一個過渡。介於一次性計劃和持續十年的項目，發生了轉變：一個項目必須開始對不斷變化的外部因素做出反應。對於任何一個從一開始就沒有升級計劃的項目，這種轉變可能會非常痛苦，原因有三個，每一個都會使其他原因變得複雜：

你正在執行本項目尚未完成的任務；更多隱藏的假設已經成立。嘗試進行升級的工程師不太可能具有此類任務的經驗。升級的規模通常比平時大，一次完成幾年的升級，而不是增量升級。

’“”

因此，在經歷過一次升級（或中途放棄）之後，高估後續升級的成本並決定“永不再升級”是非常合理的。得出這個結論的公司最終承諾放棄並重寫代碼，或決定不再升級。有時，更負責任的答案不是採取常規的方法避免痛苦的任務，而是投入資源用於減輕痛苦。這一切都取決於升級的成本、提供的價值以及相關項目的預期生命週期。

>’>>你自己的優先次序和品味會告訴你這種轉變到底發生在哪裏。我們發現，大多數項目似乎願意在五年內升級。一般來說，到年似乎是這一轉變的保守估計。

不僅完成了第一次大升級，而且達到可靠地保持當前狀態的程度，這是項目長期可持續性的本質。可持續性要求規劃和管理所需變化的影響。對於谷歌的許多項目，我們相信我們已經實現了這種持續能力，主要是通過試驗和錯誤。

“”“”

那麼，具體來說，短期編程與生成預期生命週期更長的代碼有何不同？隨着時間的推移，我們需要更多地意識到“正常工作”和“可維護”之間的區別。識別這些問題沒有完美的解決方案。這是不幸的，因爲保持軟件的長期可維護性是一場持久戰。

’海勒姆定律

“”“”’’

如果你正在維護一個由其他工程師使用的項目，那麼關於“有效”與“可維護”最重要的一課就是我們所說的海勒姆定律：

當一個有足夠多的用戶的時候，在約定中你承諾的什麼都無所謂，所有在你係統裏面被觀察到的行爲都會被一些用戶直接依賴。

’’’’’’

根據我們的經驗，這個定律在任何關於軟件隨時間變化的討論中都是一個主導因素。它在概念上類似於熵：對隨時間變化和維護的討論必須瞭解海勒姆定律，正如對效率或熱力學的討論必須注意熵一樣。僅僅因爲熵從不減少並不意味着我們不應該努力提高效率。在維護軟件時，海勒姆定律會適用，但這並不意味着我們不能對它進行規劃或試圖更好地瞭解它。我們可以減輕它，但我們知道，它永遠不可能被根除。

’

海勒姆定律代表了一種實踐知識，即使有最好的規劃、最好的工程師和可靠的代碼評審實踐，我們也不能假設完全遵守已發佈的契約或最佳實踐。作爲所有者，通過明確地接口約定，你將獲得一定的靈活性和自由度，但在實踐中，給定更改的複雜性和難度還取決於用戶對你的的一些可觀察行爲的有用程度。如果用戶不能依賴這些東西，那麼你的將很容易更改。如果有足夠的時間和足夠的用戶，即使是最無害的變更也會破壞某些東西；你對變更價值的分析必須包含調查、識別和解決這些缺陷的難度。

>“”“’”>>值得稱道的是，海勒姆非常努力地將其稱爲隱性依賴定律，但海勒姆定律是谷歌公司大多數人都認可的簡稱。>>“”>>見工作流程，一幅漫畫。

哈希排序

考慮哈希迭代排序的例子。如果我們在一個基於散列的集合中插入五個元素，我們將以什麼順序將它們取出？

>>>

’

’

大多數程序員都知道哈希表是無序的。很少有人知道他們使用的特定哈希表是否打算永遠提供特定的排序。這似乎不起眼，但在過去的一二十年中，計算行業使用這類類型的經驗不斷發展：

哈希洪水攻擊增加了非確定性哈希迭代的動力。研究改進的散列算法或散列容器的潛在效率收益需要更改散列迭代順序。根據海勒姆定律，如有能力程序員可根據哈希表的遍歷順序編寫程序。

“”“”“’”

因此，如果你問任何一位專家“我能爲我的散列容器設定一個的輸出序列嗎？”這位專家大概會說“不”。總的來說，這是正確的，但過於簡單。一個更微妙的回答是，“如果你的代碼是短期的，沒有對硬件、語言運行時或數據結構的選擇進行任何更改，那麼這樣的假設是正確的。如果你不知道代碼的生命週期，或者你不能保證你所依賴的任何東西都不會改變，那麼這樣的假設是不正確的。”，即使你自己的實現不依賴於散列容器順序，也可能被隱式創建這種依賴關係的其他代碼使用。例如，如果庫將值序列化爲遠程過程調用（）響應，則調用程序可能會根據這些值的順序結束。

“”“”

這是“可用”和“正確”之間區別的一個非常基本的例子。對於一個短期的程序，依賴容器的迭代順序不會導致任何技術問題。另一方面，對於一個軟件工程項目來說，如果有足夠的時間，這種對已定義順序的依賴是一種風險使更改迭代順序變得有價值。這種價值可以通過多種方式體現出來，無論是效率、安全性，還是僅僅是數據結構的未來驗證，以允許將來的更改。當這一價值變得清晰時，你需要權衡這一價值與破壞開發人員或客戶的痛苦之間的平衡。

>>>一種拒絕服務（）攻擊，其中不受信任的用戶知道哈希表和哈希函數的結構，並以降低表上操作的算法性能的方式提供數據。

’’

一些語言專門在庫版本之間，甚至在執行相同程序的隨機散列排序，以防止依賴關係。但即使這樣，也會出現一些令人驚訝的海勒姆定律：有些代碼使用散列迭代排序作爲一個低效的隨機數生成器。現在消除這種隨機性將破壞這些用戶原使用方式。正如熵在每個熱力學系統中增加一樣，海勒姆定律適用於所有可觀察到的行爲。

“”“”“”“”“”“”’“’‘’’‘’”

思考一下用“當前可用”和“一直可用”心態編寫的代碼之間的差異，我們可以提取出一些明確的關係。將代碼視爲具有（高度）可變生命週期需求的構件，我們可以開始對編程風格進行分類：依賴其依賴性的脆弱和未發佈特性的代碼可能被描述爲“黑客”或“聰明”而遵循最佳實踐併爲未來規劃的代碼更可能被描述爲“乾淨”和“可維護”。兩者都有其目的，但你選擇哪一個關鍵取決於所討論代碼的預期生命週期。我們常說，“如果‘聰明’是一種恭維，那就是程序，如果‘聰明’是一種指責，那就是軟件工程。”

“”爲什麼不以“無變化”爲目標？

在所有關於時間和對變化作出反應的討論中，隱含着一個假設，即變化可能是必要的？

’“”

與本書中的其他內容一樣，這取決於實際情況。我們很樂意承諾“對於大多數項目，在足夠長的時間內，它們下面的一切都可能需要更改。”如果你有一個用純編寫的項目，沒有外部依賴項（或者只有保證長期穩定性的外部依賴項，如），你完全可以避免任何形式的重構或困難的升級。在提供多方面穩定性方面做了大量工作，這是其首要任務。

’’

大多數項目更多地接觸到不斷變化的基礎技術。大多數編程語言和運行時的變化要比大得多。甚至用純實現的庫也可能改變以支持新特性，這可能會影響下游用戶。從處理器到網絡庫，再到應用程序代碼，各種技術都會暴露安全問題。你的項目所依賴的每一項技術都有一些（希望很小）包含關鍵和安全漏洞的風險，這些漏洞只有在你開始依賴它之後纔會暴露出來。如果你無法部署心臟出血或緩解推測性執行漏洞（如熔燬和幽靈）的修補程序，因爲你假設（或保證）什麼都不會改變，這是一場巨大的賭博。

“”’

效率的提高使情況更加複雜。我們希望爲數據中心配備經濟高效的計算設備，特別是提高效率。然而，早期谷歌的算法和數據結構在現代設備上效率較低：鏈表或二叉搜索樹仍能正常工作，但週期與內存延遲之間的差距不斷擴大，影響了看起來還像“高效”代碼。隨着時間的推移，升級到較新硬件的價值會降低，而無需對軟件進行相應的設計更改。向後兼容性確保了舊系統仍能正常工作，但這並不能保證舊的優化仍然有用。不願意或無法利用這些機會可能會帶來巨大的成本。像這樣的效率問題尤其微妙：最初的設計可能完全符合邏輯，並遵循合理的最佳實踐。只有在向後兼容的變化演變之後，新的、更有效的選擇才變得重要。雖然沒有犯錯誤，但隨着時間的推移，變化仍然是有價值的。

’’’

像剛纔提到的那些擔憂，沒有對可持續性的長期項目進行投入是存在巨大風險。我們必須能夠應對這些問題，並利用好機會，無論它們是否直接影響我們，或者僅僅表現爲我們所建立的技術的過渡性封閉中。變化本質上不是好事。我們不應該僅僅爲了改變而改變。但我們確實需要有能力改變。如果我們考慮到最終的必要性，我們也應該考慮是否加大投入使這種能力變得簡單易用（成本更低）。正如每個系統管理員都知道的那樣，從理論上知道你可以從磁帶恢復是一回事，在實踐中確切地知道如何進行恢復以及在必要時需要花費多少錢是另一回事。實踐和專業知識是效率和可靠性的重要驅動力。

規模和效率

’

正如（）這本書所指出的，谷歌的生產系統作爲一個整體是人類創造的最複雜的系統之一。構建這樣複雜系統並保持其平穩運行所涉及的複雜性需要我們組織和全球各地的專家進行無數小時的思考、討論和重構。因此，我們已經寫了一本書，講述了保持機器以這種規模運行的複雜性。

“’”

本書的大部分內容都集中在產生這種系統的組織規模的複雜性，以及我們用來保持系統長期運行的過程。再考慮代碼庫可持續性的概念：“當你能夠安全地改變你應該改變的所有事情，你的組織的代碼庫是可持續的，並且可以爲你的代碼庫的生命做這樣的事情。”隱藏在能力的討論中也是成本的一個方面：如果改變某事的代價太大，它可能會被推遲。如果成本隨着時間的推移呈超線性增長，運營顯然是不可擴展的。最終，時間會佔據主導地位，出現一些意想不到的情況，你必須改變。當你的項目範圍擴大了一倍，並且你需要再次執行該任務時，它會是勞動密集型的兩倍嗎？下次你是否有足夠的人力資源來解決這個問題？

’

人力成本不是唯一需要擴大規模的有限資源。就像軟件本身需要與傳統資源（如計算、內存、存儲和帶寬）進行良好的可擴展一樣，軟件的開發也需要進行擴展，包括人力時間的參與和支持開發工作流程的計算資源。如果測試集羣的計算成本呈超線性增長，每個季度人均消耗更多的計算資源，那麼你的項目就走上了一條不可持續的道路，需要儘快做出改變。

“”“”“”’

最後，軟件系統最寶貴的資產代碼庫本身也需要擴展。如果你的構建系統或版本控制系統隨着時間的推移呈超線性擴展，也許是由於內容增長和不斷增加的變更日誌歷史，那麼可能會出現無法持續的情況。許多問題，如“完成完整構建需要多長時間？”、“拉一個新的版本庫需要多長時間？”或“升級到新語言版本需要多少成本？”都沒有受到有效的監管，並且效率變得緩慢。這些問題很容易地變得像溫水煮青蛙；問題很容易慢慢惡化，而不會表現爲單一的危機時刻。只有在整個組織範圍內提高意識並致力於擴大規模，纔可能保持對這些問題的關注。

’

你的組織生產和維護代碼所依賴的一切都應該在總體成本和資源消耗方面具有可擴展性。特別是，你的組織必須重複做的每件事都應該在人力方面具有可擴展性。從這個意義上講，許多通用策略似乎不具有可擴展性。

>’>>谷歌如何運行生產系統。>>“”“”>>在本章中，當我們在非正式語境中使用“可擴展性”時，我們的意思是“在人類交互的次線性伸縮性”

’不可擴展的策略

只要稍加練習，就可以更容易地發現具有不可擴展的策略。最常見的情況是，可以通過考慮施加在單個設計並想象組織規模擴大倍或倍。當我們的規模增大倍時，我們會增加倍的工作量，而我們的工程師能跟得上嗎？我們的工程師的工作量是否隨着組織的規模而增長？工作是否隨着代碼庫的大小而變多？如果這兩種情況都是真實的，我們是否有機制來自動化或優化這項工作？如果沒有，我們就有擴展問題。

“’’”

考慮傳統的棄用方式。我們在第章中詳細討論了棄用，但常用的棄用方法是擴展問題的一個很好的例子。開發了一個新的小組件。決定是每個人都應該使用新的，停止使用舊的。爲了激發這一點，項目負責人說：“我們將在月日刪除舊的小組件；確保你已轉換爲新的小組件。”

這種方法可能適用於小型軟件項目，但隨着依賴關係圖的深度和廣度的增加，很快就會失敗。團隊依賴越來越多的小部件，單個構建中斷可能會影響公司不斷增長的百分比。以一種可擴展的方式解決這些問題，意味着需要改變我們廢棄的方式：不是將遷移工作推給客戶，團隊可以將其內部消化，並提供所需資源投入。

’“”’

年，我們試圖通過降低流失規則來阻止這種情況：基礎架構團隊必須將內部用戶遷移到新版本，或者以向後兼容的方式進行更新。我們稱之爲“流失規則”的這一策略具有更好的擴展性：依賴項目不再爲了跟上進度而花費更多的精力。我們還瞭解到，有一個專門的專家組來執行變更規模比要求每個用戶付出更多的維護工作要好：專家們花一些時間深入學習整個問題，然後將專業知識應用到每個子問題上。迫使用戶對流失作出反應意味着每個受影響的團隊做了更糟糕的工作，解決了他們眼前的問題，然後扔掉了那些對現在無效的知識。專業知識的擴展性更好。

“”“”’’

傳統的開發分支的使用是另一個有內在擴展問題的例子。一個組織可能會發現，將大的功能分支合併到主幹中會破壞產品的穩定性，並得出結論：“我們需要對分支的合併時間進行控制，還要降低合併的頻率”。這很快會導致每個團隊或每個功能都有單獨的開發分支。每當任何分支被確定爲“完整”時，都會對其進行測試併合併到主幹中，從而引發其他仍在開發分支上工作的工程師以重新同步和測試，造成巨大的工作量。這樣的分支機構管理模式可以應用在小型組織裏，管理到個這樣的分支機構。隨着一個組織的規模（以及分支機構的數量）的增加，我們很快就會發現，爲了完成同樣的任務，我們付出越來越多的管理成本。隨着規模的擴大，我們需要一種不同的方法，我們將在第章中對此進行討論。

規模化策略

隨着公司的發展，什麼樣的策略會帶來更低的成本？或者，最好是，隨着組織化的發展，我們可以制定什麼樣的策略來提供超高的價值？

“’”“”“”’

我們最喜歡的內部策略之一是爲基礎架構團隊提供強大的支持，維護他們安全地進行基礎措施更改的能力。“如果一個產品由於基礎架構更改而出現停機或其他問題，但我們的持續集成（）系統中的測試沒有發現問題，這不是基礎架構變更的錯。”更通俗地說，這是“如果你喜歡它，你應該對它進行測試”，我們稱之爲“碧昂斯規則。”從可伸縮性的角度來看，碧昂斯規則意味着複雜的、一次性的定製測試（不是由我們的通用系統觸發的）不算數。如果沒有這一點，基礎架構團隊的工程師需要跟蹤每個有任何受影響代碼的團隊，問他們如何進行測試。當有一百個工程師的時候，我們可以這樣做。我們絕對不能這樣做。

’’

我們發現，隨着組織規模的擴大，專業知識和共享交流論壇提供了巨大的價值。隨着工程師在共享論壇中討論和回答問題，知識往往會傳播。新的專家人數不斷增加。如果你有名工程師編寫，那麼一位願意回答問題的友好且樂於助人的專家很快就會產生一個數百名工程師編寫更好的代碼。知識是病毒，專家是載體，掃除工程師常見的絆腳石是非常有價值的。我們將在第章更詳細地介紹這一點。

>“”“”>>這是指流行歌曲《單身女士》，其中包括如果你喜歡它，你就應該給它戴上戒指。

示例：編譯器升級

’

考慮升級編譯器的艱鉅任務。從理論上講，編譯器的升級應該是簡單的，因爲語言需要多少工作才能向後兼容，但是在實際操作中又有多簡單呢？如果你以前從未做過這樣的升級，你將如何評價你的代碼庫是否與兼容升級？

根據我們的經驗，語言和編譯器升級是微妙而困難的任務，即使人們普遍認爲它們是向後兼容的。編譯器升級幾乎總是會導致編譯的微小變化：修復錯誤編譯、調整優化，或者潛在地改變任何以前未定義的結果。你將如何針對所有這些潛在的結果來評估你整個代碼庫的正確性？

’’’’’’

谷歌歷史上最具傳奇色彩的編譯器升級發生在年。當時，我們已經運行了幾年，擁有數千名工程師。我們大約有五年沒有升級過編譯器。我們的大多數工程師都沒有升級編譯器的經驗。我們的大部分代碼只針對在單一編譯器版本。對於一個由（大部分）志願者組成的團隊來說，這是一項艱難而痛苦的任務，最終變成了尋找捷徑和簡化的問題，以便繞過我們不知道如何採用的上游編譯器和語言變化。最後，年的編譯器升級過程非常痛苦。許多海勒姆定律問題，無論大小，都潛入了代碼庫，加深了我們對特定編譯器版本的依賴。打破這些隱式依賴性是痛苦的。相關工程師正在冒風險：我們還沒有碧昂斯規則，也沒有通用的系統，因此很難提前知道更改的影響，或者確保他們不會因回退而受到指責。

’

這個故事一點也不稀奇。許多公司的工程師都可以講述一個關於痛苦升級的故事。不同的是，我們在經歷了痛苦的任務之後認識到了這一點，並開始關注技術和組織變革，以克服規模問題，並將規模轉變爲我們的優勢：自動化（這樣一個人就可以做到更多）、整合一致性（這樣低級別的更改影響有限的問題範圍）和專業知識（以便少數人就可以做得更多）。

你更改基礎設施的頻率越高，更改就越容易。我們發現，在大多數情況下，當代碼作爲編譯器升級的一部分進行更新時，它會變得沒那麼脆弱，將來更容易升級。大多數代碼都經歷了幾次升級的一個系統中，它的停止取決於底層實現的細微差別。相反，它取決於語言或操作系統所保證的抽象。無論你升級的是什麼，代碼庫的第一次升級都比以後的升級要複雜得多，甚至可以控制其他因素。

>>>具體來說，來自標準庫的接口需要在命名空間中被引用，而針對的優化改變對我們的使用來說是一個重大的減值，因此需要一些額外的解決方法。

’

’’’

通過這些和其他經驗，我們發現了許多影響代碼庫靈活性的因素：

專業知識我們知道如何做到這一點；對於某些語言，我們現在已經在許多平臺上進行了數百次編譯器升級。穩定性版本之間的更改更少，因爲我們更有規律的採用版本；對於某些語言，我們現在每一到兩週進行一次編譯器升級部署。一致性沒有經過升級的代碼更少了，這也是因爲我們正在定期升級。熟悉因爲我們經常這樣做，所以我們可以在執行升級的過程中發現冗餘並嘗試自動化。這是與觀點一致的地方。策略我們有類似碧昂斯規則的流程和策略。這些程序的淨效果是，升級仍然是可行的，因爲基礎設施團隊不需要擔心每一個未知的使用，只需要擔心我們的系統中常規的使用。

潛在的教訓不是關於編譯器升級的頻率或難度，而是一旦我們意識到編譯器升級任務是必要的，我們就找到了方法，確保在代碼庫增長的情況下，由固定數量的工程師執行這些任務。如果我們認爲任務成本太高，應該學會避免，我們可以仍然使用十年前的編譯器版本。由於錯過了優化機會，我們需要額外支付的計算資源。考慮到年的編譯器對緩解推測性執行漏洞沒有效果，我們的中央基礎設施可能會面臨重大的安全風險，這不是一個明智的選擇。

>“”>>等人，《：運維解密》第五章減少瑣事。>>’>>根據我們的經驗，平均軟件工程師（）每單位時間產生相當恆定的代碼行數。對於固定的總體，隨着時間的推移，代碼庫的增長與月數成線性比例。如果您的任務所需的工作量與代碼行數成正比，那就令人擔憂了。

左移

’“”

我們發現，在開發人員工作流程的早期發現問題通常可以降低成本，這是一個普遍的真理。考慮一下開發人員工作流程的時間軸，該時間軸從左到右依次爲：從構思和設計開始，經過實施、審覈、測試、提交、金絲雀和最終的生產部署。如圖所示，在此時間軸上將問題檢測提前到左側，解決問題的成本會比等待時間更長。

’“”’’

這個術語似乎源一種觀點，即安全問題不能推遲到開發過程的最後階段，必須要求“在安全上向左轉移”。這種情況下的論點相對簡單：如果安全問題是在產品投入生產後才發現的，修復的成本就非常高。如果在部署到生產之前就發現了安全問題，那也需要花費大量的工作來檢測和修復問題，但成本更低些。如果你能夠在最初的開發之前發現安全問題，將缺陷提交到版本控制就被發現，修復的成本更低：他們已經瞭解該功能；根據新的安全約束規範進行開發，要比提交代碼後再讓其他人分類標識並修復它更簡單。

同樣的基本模式在本書中多次出現。在提交之前通過靜態分析和代碼審查發現的要比投入生產的成本更低。在開發過程的早期提供高質量、可靠性和安全性的工具和實踐是我們許多基礎架構團隊的共同目標。沒有一個過程或工具是完美的，所以我們可以採取縱深防禦的方法，希望儘早抓住圖表左側的缺陷。

權衡和成本

’“”’“’”“”“”“”

如果我們瞭解如何編程，瞭解我們所維護的軟件的生命週期，並且隨着在我們隨着更多的工程師一起開發和維護新功能，瞭解擴大規模時如何運維它，那麼剩下的就是做出正確的決策。這是顯而易見的：在軟件工程中，如同生活一樣，好的選擇會帶來好的結果。然而，這一觀點很容易被忽視。在谷歌內部，人們對“因爲我這麼說了”有反對的意見。重要的是，任何議題都要有一個決策者，當決策是錯誤的時候，要有明確的改進路徑，但目標是共識，而不是一致。看到一些我不同意你的衡量標準評價，但我知道你是如何得出這個結論的的情況是沒有問題的，也是可以預期的。所有這一切的內在想法是，每件事都需要一個理由；“僅僅因爲”、“因爲我這麼說”或“因爲其他人都這樣做”是潛在錯誤的決策。只要這樣做是有效的，在決定兩個工程方案的一般成本時，我們應該能夠解釋清楚。

“”

我們所說的成本是什麼呢？我們這裏不僅僅是指金錢。“成本”大致可以轉化爲努力的方向，可以包括以下任何或所有因素：

財務成本（如金錢）資源成本（如時間）人員成本（例如，工作量）交易成本（例如，採取行動的成本是多少？）機會成本（例如，不採取行動的成本是多少？）社會成本（例如，這個選擇將對整個社會產生什麼影響？）

’’

從歷史上看，忽視社會成本的問題尤其容易出現。然而，谷歌和其他大型科技公司現在可以可靠地部署擁有數十億用戶的產品。在許多情況下，這些產品是高淨效益的，但當我們以這樣的規模運營時，即使在可用性、可訪問性和公平性方面或潛在的濫用方面的微小差異也會被放大，往往對邊緣化的羣體產生不利影響。軟件滲透到社會和文化的各個方面；因此，明智的做法是，在做出產品和技術決策時，我們要意識到我們所能帶來的好處和壞處。我們將在第章對此進行更多討論。

’’

除了上述的成本（或我們對其的估計），還有一些偏差：維持現狀偏差（個體在決策時，傾向於不作爲、維持當前的或者以前的決策的一種現象。這一定義揭示個體在決策時偏好事件當前的狀態，而且不願意採取行動來改變這一狀態，當面對一系列決策選項時，傾向於選擇現狀選項），損失厭惡偏差（人們面對同樣的損失和收益時感到損失對情緒影響更大）等。當我們評估成本時，我們需要牢記之前列出的所有成本：一個組織的健康不僅僅是銀行裏是否有錢，還包括其成員是否感到有價值和有成就感。在軟件等高度創新和利潤豐厚的領域在工程設計中，財務成本通常不是限制因素，而人力資源是。保持工程師的快樂、專注和參與所帶來的效率提升會成爲主導因素，僅僅是因爲專注力和生產力變化大，會有的差異很容易想象。

示例：記號筆

在許多組織中，白板記號筆被視爲貴重物品。它們受到嚴格的控制，而且總是供不應求。在任何的白板上，都有一半的記號筆是乾的，無法使用。你有多少次因爲沒有一個好用的記號筆而中斷會議進程？多少次因爲記號筆水用完而導致思路中斷？又有多少次，所有的記號筆都不翼而飛，大概是因爲其他團隊的記號筆用完了，不得不拿走你的記號筆？所有這些都是因爲一個價格不到一美元的產品。

’

谷歌往往在大多數工作區域都有未上鎖的櫃子，裏面裝滿了辦公用品，包括記號筆。只要稍加註意，就可以很容易地拿到各種顏色的幾十支記號筆。在某種程度上，我們做了一個明確的權衡：優化無障礙頭腦風暴要比防止有人拿着一堆記號筆走神重要得多。

“”’’

我們的目標是對我們所做的每件事都有同樣程度的關注和明確的成本收益權衡，從辦公用品和員工津貼到開發者的日常體驗，再到如何提供和運行全球規模的服務。我們經常說，“谷歌是一家數據驅動的公司。”事實上，這很簡單：即使沒有數據，也會有證據、先例和論據。做出好的工程決策就是權衡所有可用的輸入，並就權衡做出明智的決策。有時，這些決策是基於本能或公認的最佳實踐，但僅是一種假設之後，我們用盡了各種方法來衡量或估計真正的潛在成本。

最後，工程團隊的決策應該歸結爲幾件事：

我們這樣做是因爲我們必須這麼做（法律要求、客戶要求）。我們之所以這樣做，是因爲根據當前證據，這是我們當時能看到的最佳選擇（由一些適當的決策者決策）。

“”

決策不應該是“我們這樣做是因爲我這麼說。”

>>>這並不是說決策需要一致做出，甚至需要有廣泛的共識；最終，必須有人成爲決策者。這主要是說明決策過程應該如何爲實際負責決策的人進行。

對決策的輸入

’’“’”

當我們權衡數據時，我們發現兩種常見情況：

所有涉及的數量都是可測量的或至少可以預估的。這通常意味着我們正在評估和網絡、美金和之間的權衡，或者考慮是否花費兩週的工作量，以便在我們的數據中心節省個。有些數量是微妙的，或者我們不知道如何衡量。有時這表現爲“我們不知道這需要多少工作量”。有時甚至更模糊：如何衡量設計拙劣的的工程成本？或產品導致的社會影響？

’

在第一類決策上沒有什麼理由存在缺陷。任何軟件工程的組織都可以並且應該跟進當前的計算資源成本、工程師工作量以及你經常接觸的其他成本。即使你不想向你的組織公佈確切的金額，你仍然可以制定一份版本表：這麼多的成本與這麼多或這麼多網絡帶寬。

“’”

有了一個協定的轉換表，每個工程師都可以自己進行分析。“如果我花兩週的時間將這個鏈表轉換成一個更高性能的數據結構，我將多使用的，但節省兩千個。我應該這樣做嗎？”這個問題不僅取決於和的相對成本，還取決於人員成本（對軟件工程師的兩週支持）和機會成本（該工程師在兩週內還能生產什麼？）。

’

對於第二類決策，沒有簡單的答案。我們依靠經驗、領導作風和先例來協商這些問題。我們正在投入研究，以幫助我們量化難以量化的問題（見第章）不過，我們所能提供的最好的廣泛建議是，意識到並非所有的事情都是可衡量或可預測的，並嘗試以同樣的優先級和更謹慎得對待此類決策。它們往往同樣重要，但更難管理。

示例：分佈式構建

’“”

考慮到你的構建。根據不可靠的推特投票結果顯示，大約有到的開發者在本地構建，即使是今天的大型、複雜的構建。纔有了這樣的笑話，如“編譯”漫畫所示。你的組織中有多少時間被浪費在等待構建上？將其與爲一個小團隊運行類似的成本進行比較。或者，爲一個大團隊運行一個小構建場需要多少成本？這些成本需要多少周月才能成爲一個淨收益？

’

早在年代中期，谷歌就完全依賴於本地構建系統：你切出代碼，然後在本地編譯。在某些情況下，我們有大量的本地機器（你可以在桌面電腦上構建地圖！），但隨着代碼庫的增長，編譯時間變得越來越長。不出所料，由於時間的浪費，我們的人員成本增加，以及更大、更強大的本地機器的資源成本增加等等。這些資源成本特別麻煩：當然，我們希望人們有一個儘可能快的構建，但大多數時候，一個高性能的桌面開發機器將被閒置。這感覺不像是投資這些資源的正確方式。

’

最終，谷歌開發了自己的分佈式構建系統。開發這個系統當然要付出代價：工程師花費了時間，工程師花更多的時間來改變每個人的習慣和工作流程，學習新系統，當然還需要額外的計算資源。但總體節約顯然值得我去做：構建速度變快了，工程師的時間被節約了，硬件投資可以集中在管理的共享基礎設施上（實際上是我們生產機羣的一個子集），而不是日益強大的桌面機。第章詳細介紹了我們的分佈式構建方法和相關權衡。

’

因此，我們構建了一個新系統，將其部署到生產環境中，並加快了每個人的構建速度。這就是故事的圓滿結局嗎？不完全是這樣：提供分佈式構建系統極大地提高了工程師的工作效率，但隨着時間的推移，分佈式構建本身變得臃腫起來。在以前的情況下，單個工程師受到的限制（因爲他們盡最大可能保持本地構建的速度）在分佈式構建系統中是不受限制的。構建圖中的臃腫或不必要的依賴關係變得非常普遍。當每個人都直接感受到非最佳構建的痛苦，並被要求去保持警惕時，激勵機制會更好地協調一致。通過取消這些激勵措施，並將臃腫的依賴關係隱藏在並行的分佈式構建中，我們創造了一種情況，在這種情況下，消耗可能猖獗，而且幾乎沒有人被要求去關注構建的臃腫。這讓人想起傑文斯悖論（）：一種資源的消耗可能會隨着使用效率的提高而增加。

“’”

總的來說，與添加分佈式構建系統相關的節省成本遠遠超過了與其構建和維護相關的負成本。但是，正如我們看到的消耗增加，我們並沒有以前預見到這些成本。勇往直前之後，我們發現自己處於這樣一種境地：我們需要重新認識系統的目標和約束以及我們的使用方式，確定最佳實踐（小型依賴項、依賴項的機器管理），併爲新生態系統的工具和維護提供資金。即使是相對簡單的我們花美元購買計算資源以收回工程師時間的權衡，也會產生不可預見的下游影響。

示例：在時間和規模之間做決定

’

很多時候，我們關於時間和規模的主題相互重合，相互影響。符合碧昂斯規則策略具備可擴展性，並幫助我們長期維護事物。對操作系統接口的更改需要許多小的重構來適應，但這些更改中的大多數都可以很好地擴展，因爲它們具有相似的形式：操作系統的變化對每個調用者和每個項目都沒有不同的表現。

有時時間和規模會發生衝突，而且沒有什麼地方能像在基本問題中那麼明顯：我們應該添加一個依賴性，還是分支重新實現它，來更好地滿足我們的需求？

’

這個問題可能出現在軟件棧（解決方案棧）各個層面，通常情況下，爲特定問題定製解決方案優於需要處理所有問題的通用解決方案。通過分支或重新實現程序代碼，併爲特定問題定製它，你可以更便捷地添加新功能，或更確定地進行優化，無論我們談論的是微服務、內存緩存、壓縮程序還是軟件生態系統中的其他內容。更重要的是，你從這樣一個分支中獲得的控制將你與基礎依賴項中的變更隔離開：這些變化並不是由另一個團隊或第三方供應商所決定的。你隨時決定如何對時間的推移和變化的作出必要地反應。

一條微博引發的思考再談“”之“軟件棧”譯法！軟件棧（），是指爲了實現某種完整功能解決方案（例如某款產品或服務）所需的一套軟件子系統或組件。

另一方面，如果每個開發人員都將他們的軟件項目中使用的組件是多樣化，而不是複用現有的組件，那麼可擴展性和可持續性都會受到影響。對底層庫中的安全問題作出反應不再是更新單個依賴項及其用戶的問題：現在要做的是識別該依賴關係的每一個易受攻擊的分支以及使用這個分支的用戶。

’

與大多數軟件工程決策一樣，對於這種情況並沒有一個一刀切的答案。如果你的項目生命週期很短，那麼的風險較小。如果有問題的分支被證明是範圍有限的，那是有幫助的，同時也要避免分支那些可能跨越時間段或項目時間界限的接口（數據結構、序列化格式、網絡協議）。一致性有很大的價值，但通用性也有其自身的成本，你往往可以通過做自己的事情來贏得勝利如果你仔細做的話。

重審決策，標記錯誤

’

致力於數據驅動文化的一個不明顯的好處是承認錯誤的能力和必要性相結合。在某個時候，將根據現有的數據做出決定希望是基於準確的數據和僅有的幾個假設，但隱含的是基於目前可用的數據。隨着新數據的出現，環境的變化，或假設的不成了，可能會發現某個決策是錯誤的，或在當時是有意義的，但現在已經沒有意義了。這對於一個長期存在的組織來說尤其重要：時間不僅會觸發技術依賴和軟件系統的變化，還會觸發用於驅動決策的數據的變化。

’’

我們堅信數據能爲決策提供信息，但我們也認識到數據會隨着時間的推移而變化，新數據可能會出現。這意味着，本質上，在相關係統的生命週期內，需要不時地重新審視決策。對於長期項目而言，在做出初始決策後，有能力改變方向通常是至關重要的。更重要的是，這意味着決策者需要勇氣承認錯誤。與人的直覺相反，勇於承認錯誤的領導人受更多的尊重。

’’’’’

以證據爲導向，但也要意識到無法衡量的東西可能仍然有價值。如果你是一個領導者，那就是你被要求做的：審時度勢，主張事在人爲。我們將在第章和第章中詳細介紹領導力

軟件工程與編程

在介紹軟件工程和編程之間的區別時，你可能會問，是否存在內在的價值判斷。編程是否比軟件工程更糟糕？一個由數百人組成的團隊預計將持續十年的項目是否比一個只有一個月的項目和兩個人構建的項目更有價值？

’’

當然不是。我們的觀點並不是說軟件工程是優越的，只是它們代表了兩個不同的問題領域，具有不同的約束、價值和最佳實踐。相反，指出這種差異的價值來自於認識到一些工具在一個領域是偉大的，但在另一個領域不是。對於只持續幾天的項目，你不需要依賴集成測試（參見第章）和持續部署（）實踐（參見第章）。同樣地，我們對軟件工程項目中的版本控制（）和依賴性管理（參見第章）的所有長期關注，並不適用於短期編程項目：利用一切可以利用的手段來解決手頭的任務。

“”“”

我們認爲，區分相關但不同的術語“編程”和“軟件工程”是很重要的。這種差異很大程度上源於隨着時間的推移對代碼的管理、時間對規模的影響以及面對這些想法的決策。編程是產生代碼的直接行爲。軟件工程是一組策略、實踐和工具，這些策略、實踐和工具是使代碼在需要使用的時間內發揮作用，並允許整個團隊的協作。

總結

’

本書討論了所有這些主題：一個組織和一個程序員的策略，如何評估和改進你的最佳實踐，以及用於可維護軟件的工具和技術。谷歌一直在努力打造可持續的代碼庫和文化。我們不認爲我們的方法是做事情的唯一正確方法，但它確實通過例子證明了它是可以做到的。我們希望它將提供一個有用的框架來思考一般問題：你如何維護你的代碼，讓它正常運行。

內容提要

”“”’”’

“軟件工程”與“編程”在維度上不同：編程是關於編寫代碼的。軟件工程擴展了這一點，包括在代碼的生命週期內對其進行維護。短期代碼和長期代碼的生命週期之間至少有倍的係數。假設相同的最佳實踐普遍適用於這一範圍的兩端是愚蠢的。在預期的代碼生命週期內，當我們能夠響應依賴關係、技術或產品需求的變化時，軟件是可持續的。我們可能選擇不改變事情，但我們需要有能力。海勒姆定律：當一個有足夠的用戶的時候，在約定中你承諾的什麼都無所謂，所有在你係統裏面被觀察到的行爲都會被一些用戶直接依賴。你的組織重複執行的每項任務都應在人力投入方面具有可擴展性（線性或更好）。策略是使流程可伸縮的好工具。流程效率低下和其他軟件開發任務往往會慢慢擴大規模。小心煮青蛙的問題。當專業知識與規模經濟相結合時，回報尤其豐厚。“因爲我說過”是做事的可怕理由。數據驅動是一個良好的開端，但實際上，大多數決策都是基於數據、假設、先例和論據的混合。最好是客觀數據佔這些輸入的大部分，但很少可能是全部。隨着時間的推移，數據驅動意味着當數據發生變化時（或假設消除時），需要改變方向。錯誤或修訂的計劃不在表中。