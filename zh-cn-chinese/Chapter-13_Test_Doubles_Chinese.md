第十三章測試替代

單元測試是保持開發人員生產力和減少代碼缺陷的重要工具。儘管對於簡單的代碼來說，單元測試很容易編寫，但當代碼變得更加複雜時，編寫單元測試就變得困難了。

’

例如，想象一下，嘗試爲一個函數編寫測試，該函數向外部服務器發送請求，然後將響應存儲在數據庫中。只需多付出一些努力，編寫少量的測試可能是可以做到的。但如果你需要寫成百上千個這樣的測試，你的測試套件很可能需要幾個小時才能運行，並且可能由於隨機網絡故障或測試相互覆蓋數據等問題讓測試變得不穩定。

’

在這種情況下，測試替代就會派上用場。測試替代可以是一個對象或函數，它可以在測試中代替真正的實現，類似於特技替身可以代替電影中的演員那樣。測試替代的使用通常被稱爲模擬，但我們在本章中避免使用這個術語，因爲正如我們將看到的，這個術語也被用來指代測試替代的更具體方面。

’

也許最明顯的測試替代類型是一個行爲類似於真實實現的對象的更簡單的實現，比如一個內存數據庫。其他類型的測試替代可以驗證系統的特定細節，例如通過使觸發罕見錯誤條件變得容易，或者確保在不實際執行函數實現的情況下調用重量級函數。

’

前兩章介紹了小型測試的概念，並討論了爲什麼它們應該包括測試套件中的大多數測試。然而，由於跨多個進程或機器的通信，生產代碼往往不適合小型測試的約束。測試替代可以比真正的實現更輕量級，允許你寫許多小測試，快速執行，並且不易出錯。

測試替代對軟件開發的影響

’

’’

測試替代的使用給軟件開發帶來了一些複雜的問題，需要做出一些權衡。本章將更深入地討論此處介紹的概念：

可測試性爲了使用測試替代，需要將代碼庫設計成可測試的測試應該可以用測試替代替換實際實現。例如，調用數據庫的代碼需要足夠靈活，以便能夠使用測試替代來代替真正的數據庫。如果代碼庫在設計時沒有考慮到測試，而你後來決定需要測試，那麼可能需要進行大量的提交來重構代碼，以支持使用測試替代。

適用性儘管適當地應用測試替代可以極大地提高工程速度，但其使用不當會導致測試變得脆弱、複雜且低效。當測試替代在大型代碼庫中使用不當時，這些缺點就會被放大，這可能會導致工程師在生產效率方面的重大損失。在許多情況下，測試替代是不合適的，工程師應該傾向於使用真實的實現。

仿真度仿真度是指測試替代的行爲與它所替代的真實實現的行爲有多大的相似性。如果測試替代的行爲與真正的實現有很大的不同，那麼使用測試替代的測試可能不會提供太多的價值例如，想象一下，嘗試用測試替代爲一個數據庫寫一個測試，這個數據庫忽略了添加到數據庫的任何數據，總是返回空結果。這樣做是完美的仿真度不能接受的；測試替代通常需要比實際的實現簡單得多，以便適合在測試中使用。在許多情況下，即使沒有完美的仿真度，使用測試替代也是合適的。使用測試替代的單元測試通常需要由執行實際實現的更大範圍的測試來支持。

谷歌的測試替代

’’

在谷歌，我們已經看到了無數的例子，證明測試替代可以爲代碼庫提升生產力和軟件質量方面的好處，以及在使用不當時可能造成的負面影響。我們在谷歌遵循的做法是基於這些經驗隨着時間的推移而演變的。從歷史上看，我們很少有關於如何有效地使用測試替代，但最佳實踐隨着我們看到許多團隊的代碼庫中出現了常見模式和反模式而不斷發展。

’

我們經過艱苦的歷程學到的一個教訓是過度使用模擬框架的危險，它允許你輕鬆創建測試替代（我們將在本章後面更詳細地討論模擬框架）。當框架首次在使用時，它們就像一把錘子，適合每一根釘子。它們使得針對獨立的代碼段編寫高度集中的測試變得非常容易，而不必擔心如何構建代碼的依賴關係。直到經過幾年和無數次測試之後，我們纔開始意識到這些測試的成本：儘管這些測試很容易編寫，但由於它們需要不斷的努力來維護，而很少發現，我們遭受了巨大的損失。谷歌的天平現在開始向另一個方向擺動，許多工程師避免框架，轉而編寫更真實的測試。

’

儘管本章中討論的實踐在谷歌公司得到普遍認可，但實際應用情況因團隊而異。這種差異源於工程師對這些實踐的認識差異，現有代碼庫中的習慣不符合這些實踐，或者團隊只做短期內最容易的事情而不考慮長期影響。

基本概念

’

在我們深入研究如何有效地使用測試替代之前，讓我們先介紹一些與之相關的基本概念。這些爲我們在本章後面討論的最佳實踐奠定了基礎。

測試替代的示例

想象一個需要處理信用卡支付的電子商務網站。在其核心部分，它可能有類似於例中所示的代碼。

在測試中使用真正的信用卡服務是不可行的（想象一下運行測試所產生的所有交易費用！），但是可以用一個測試用的替代來模擬真實系統的行爲。例中的代碼展示了一個非常簡單的測試替代。

’’

雖然這個測試替代看起來不是很有用，但在測試中使用它仍然可以讓我們測試方法中的一些邏輯。例如，在例中，我們可以驗證該方法在信用卡過期時的行爲是否正確，因爲測試執行的代碼路徑不依賴於信用卡服務的行爲。

本章下面的章節將討論如何在比這更復雜的情況下使用測試替代。

是可以更改程序中的行爲而無需在指定位置進行編輯的地方。

如果代碼的編寫方式能夠使代碼的單元測試成爲可能，那麼代碼就被稱爲可測試代碼。是一種通過允許使用測試替代使代碼可測試的方法它使被測系統可以使用不同的依賴項，而不是生產環境中使用的依賴項。

’

依賴注入是一種引入的常見技術。簡而言之，當一個類利用依賴注入時，它需要使用的任何類（即該類的依賴）被傳遞給它，而不是直接實例化，從而使這些依賴項可以在測試中被替換。

示例顯示了依賴項注入的示例。它接受實例作爲參數，而不是創建實例的構造函數。

調用這個構造函數的代碼負責創建一個合適的實例。生產代碼可以傳入一個與外部服務器通信的的實現，而測試可以傳入一個測試用的替代，如例所示。

爲了減少與手動指定構造函數有關的模板，可以使用自動依賴注入框架來自動構建對象。在谷歌，和是自動依賴注入框架，通常用於代碼。

對於動態類型的語言，如或，有可能動態地替換單個函數或對象方法。依賴注入在這些語言中不太重要，因爲這種功能使得在測試中使用依賴項的真實實現成爲可能，同時只覆蓋不適合測試的依賴項的函數或方法。

編寫可測試代碼需要前期投入。在代碼庫生命週期的早期，這一點尤其重要，因爲越晚考慮可測試性，就越難應用到代碼庫中。在沒有考慮到測試的情況下編寫的代碼通常需要重構或重寫，然後纔可以添加適當的測試。

模擬框架

’

一個框架是一個軟件庫，它使得在測試中創建測試替代更加容易；它允許您將對象替換爲模擬對象，模擬對象是在測試中內聯指定其行爲的測試替代。模擬框架的使用減少了模板代碼，因爲你不需要在每次需要測試時定義一個新類。

例演示了的使用，這是一個的模擬框架。爲創建了一個測試替代，並指定它返回一個特定的值。

“”’

大多數主要的編程語言都有模擬框架。在，我們在中使用，在中使用的組件，在中使用。

儘管模擬框架有助於更容易地使用測試替代，但它們也有一些重要的注意事項，因爲過度使用它們往往會使代碼庫更難維護。我們將在本章的後面介紹其中的一些問題。

測試替代的使用技巧

使用測試替代有三種主要技術。本節簡要介紹這些技術，讓您快速瞭解它們是什麼以及它們之間的區別。本章後面幾節將詳細介紹如何有效地應用它們。

知道到這些技術之間區別的工程師更有可能在面臨需要使用測試替代時知道使用哪種適當的技術。

僞造

’

是一個的輕量級實現，其行爲類似於真實實現，但不適合生產；例如，一個內存數據庫。例介紹了一個僞造的例子。

’

當你需要使用測試替代時，使用僞造通常是理想的技術，但是對於你需要在測試中使用的對象，僞造可能不存在，編寫僞造可能是一項挑戰，因爲你需要確保它在現在和將來具有與真實實現類似的行爲。

打樁

打樁是指將行爲賦予一個函數的過程，如果該函數本身沒有行爲，則你可以爲該函數指定要返回的值（即打樁返回值）。

例演示了打樁的使用。來自模擬框架的方法調用指定了方法的行爲。

’

打樁通常是通過模擬框架來完成的，以減少手動創建新的類來硬編碼返回值所需的模板。

’

雖然打樁是一種快速而簡單的應用技術，但它也有侷限性，我們將在本章後面討論。

交互測試

’’’’

交互測試是一種在不實際調用函數實現的情況下驗證函數調用方式的方法。如果函數沒有正確調用，測試應該失敗。例如，如果函數根本沒有被調用，調用次數太多，或者調用參數錯誤。

例展示了一個交互測試的實例。來自模擬框架的方法被用來驗證是否按預期調用。

’

與打樁類似，交互測試通常是通過模擬框架完成的。與手動創建包含代碼的新類以跟蹤函數調用頻率和傳入參數相比，這減少了模板文件。

交互測試有時被稱爲模擬。我們在本章中避免使用這個術語，因爲它可能與模擬框架混淆，模擬框架既可用於打樁，也可用於交互測試。

正如本章後面所討論的，交互測試在某些情況下很有用，但應儘可能避免，因爲過度使用很容易導致脆性測試。

真實實現

’

儘管測試替代是非常有價值的測試工具，但我們對測試的第一選擇是使用被測系統依賴的真實實現；也就是說，與生產代碼中使用的實現相同。當測試執行代碼時，其仿真度更高，因爲它將在生產中執行，使用真實實現有助於實現這一目標。

’

在谷歌，對真實實現的偏好隨着時間的推移而發展，因爲我們看到過度使用模擬框架有一種傾向，即使用與真實實現不同步的重複代碼污染測試，從而使重構變得困難。我們將在本章後面更詳細地討論這個主題。

在測試中更傾向於使用真實實現被稱爲經典測試。還有一種測試風格被稱爲模擬測試，其中傾向於使用模擬框架而不是真實實現。儘管軟件行業的一些人在進行模擬測試（包括第一個模擬框架的創造者），但在谷歌，我們發現這種測試風格很難擴展。它要求工程師遵循設計被測系統時的嚴格準則，而谷歌大多數工程師的默認行爲是以一種更適合經典測試風格的方式來編寫代碼。

傾向於現實主義而不是孤立主義

考慮到這些真實實現中的所有代碼都將在測試中執行，使用真實實現進行依賴測試會使被測系統更加真實。相比之下，使用測試替代的測試會將被測系統與其依賴隔離開來，這樣測試就不會在被測系統的依賴中執行代碼。

我們更喜歡真實測試，因爲它們能讓人對被測系統的正常工作更有信心。如果單元測試過於依賴測試替代，工程師可能需要運行集成測試或手動驗證他們的功能是按預期工作的，以獲得同樣的信心水平。執行這些額外的任務會減慢開發速度，如果工程師完全跳過這些任務，那麼與運行單元測試相比，執行這些任務太耗時，甚至會讓溜走。

將一個類的所有依賴項替換爲測試替代項可以任意地將被測系統與作者直接放入類中的實現隔離開來，並排除恰好位於不同類中的實現。然而，一個好的測試應該獨立於實現，它應該根據編寫正在進行測試，而不是根據實現的結構進行測試。

’

如果真實實現中存在錯誤，使用真實的實現會導致你的測試失敗。這是很好的。你希望你的測試在這種情況下失敗，因爲它表明你的代碼在生產中不能正常工作。有時，真實實現中的一個錯誤會導致一連串的測試失敗，因爲其他使用真實實現的測試也可能失敗。但是有了好的開發者工具，如持續集成（）系統，通常很容易追蹤到導致失敗的變化。

案例研究：

’“”

在，我們已經看到了足夠多的過度依賴模擬框架的測試，這促使我們在中創建了註解，它可以作爲靜態分析工具的一部分。這個註解是所有者聲明的一種方式，這個類型不應該被模擬，因爲存在更好的替代方案。

如果工程師試圖使用模擬框架來創建一個被註解爲的類或接口的實例，如例所示，他們會看到一個錯誤，指示他們使用更合適的測試策略，如真實的實現或僞造。這個註解最常用於那些簡單到可以按原樣使用的值對象，以及那些有精心設計的僞造的。

’’

爲什麼所有者會在意這個問題呢？簡而言之，它嚴重限制了所有者隨時間對其實現進行更改的能力。正如我們在本章後面將探討的那樣，每次使用模擬框架進行存打樁或交互測試時，它都會複製提供的行爲。

’

當所有者想要改變他們的時，他們可能會發現它已經在整個的代碼庫中被模擬了數千次甚至上萬次！這些測試替代很可能表現出違反被模擬類型的契約的行爲例如，爲一個永遠不能返回的方法返回。如果測試使用的是真正的實現或僞造，所有者可以對他們的實現進行修改，而不需要先修復成千上萬的有缺陷的測試。

如何決定何時使用真實實現

如果真實實現速度快、確定性強且依賴性簡單，則首選真實實現。例如，一個真實實現應該被用於值對象。例子包括一筆錢、一個日期、一個地理位置，或者一個集合類，如列表或地圖。

’

然而，對於更復雜的代碼，使用真實實現通常是不可行的。考慮到需要進行權衡，可能沒有關於何時使用真實實現或測試替代的確切答案，因此需要考慮以下因素。

執行時間

單元測試的一個最重要的特性是它們應該是快速的你希望能夠在開發過程中持續運行它們，以便能夠快速獲得代碼是否正常工作的反饋（你還希望它們在系統中運行時能夠快速完成）因此，當實際實現緩慢時，測試替代可能非常有用。

對於一個單元測試來說，多慢纔算慢？如果一個真正實現在每個單獨的測試用例的運行時間上增加一毫秒，很少有人會將其歸類爲慢。但如果它增加了毫秒，毫秒，秒等等呢？

這裏沒有確切的答案它可能取決於工程師是否感到生產率下降，以及有多少測試正在使用實際實現（如果有個測試用例，每個測試用例多一秒鐘可能是合理的，但如果有個測試用例就不一樣了）。對於臨界情況，通常更容易使用實際實現，直到它變得太慢而無法使用，此時可以更新測試以使用測試替代。

測試的並行化也有助於減少執行時間。在谷歌，我們的測試基礎設施使得將測試套件中的測試拆分到多個服務器上執行變得非常簡單。這增加了的成本，但它可以爲開發人員節省大量時間。我們在第章中對此有更多的討論。

另一個需要注意的權衡：使用一個真實實現會導致構建時間的增加，因爲測試需要構建真實實現以及它的所有依賴。使用像這樣的高度可擴展的構建系統會有幫助，因爲它緩存了未改變的構建構件。

確定性

如果對於被測系統的給定版本，運行測試的結果總是相同的，也就是說，測試要麼總是通過，要麼總是失敗，那麼這個測試就是確定性。相反，如果一個測試的結果可以改變，即使被測系統保持不變，那麼它就是非確定性。

測試中的非確定性會導致鬆散性即使被測系統沒有變化，測試也會偶爾失敗。正如在第章中所討論的，如果開發人員開始不相信測試的結果並忽視失敗，那麼鬆散性會損害測試套件的健康。如果使用一個真正實現很少引起鬆散性，它可能不需要響應失敗，因爲對工程師的干擾很小。但是，如果經常發生故障，可能是時候用一個測試替代真實實現了，因爲這樣做會提高測試的仿真度。

與測試替代相比，真正實現可能要複雜得多，這增加了它不確定性的概率。例如，如果被測系統的輸出因線程的執行順序不同而不同，利用多線程的真實實現可能偶爾會導致測試失敗。

不確定性的一個常見原因是代碼不夠封閉；也就是說，它依賴於測試無法控制的外部服務。例如，如果服務器過載或網頁內容更改，嘗試從服務器讀取網頁內容的測試可能會失敗。相反，應該使用測試替代來防止測試依賴於外部服務器。如果使用測試工具不可行，另一種選擇是使用服務器的封閉實例，其生命週期由測試控制。下一章將更詳細地討論封閉實例。

不確定性的另一個例子是依賴於系統時鐘的代碼，因爲被測系統的輸出可能因當前時間而異。測試可以使用硬編碼特定時間的測試替代，而不是依賴於系統時鐘。

依賴關係的構建

當使用真實實現時，你需要構造它的所有依賴項。例如，一個對象需要構造其整個依賴關係樹：它所依賴的所有對象，這些依賴對象所依賴的所有對象，等等。測試替代通常沒有依賴項，因此與構建實際實現相比，構建測試替代要簡單得多。

’

作爲一個極端的例子，想象一下嘗試在測試中後面的代碼段中創建對象。確定如何構造每個單獨的對象將非常耗時。測試還需要持續維護，因爲當這些對象的構造函數的簽名被修改時，測試需要更新：

使用測試替代是很有誘惑力的，因爲構建一個測試替代是很簡單的。例如，在使用模擬框架時，這就是構建一個測試替代的全部內容：

儘管創建這個測試替代要簡單得多，但使用真正實現有很大的好處，正如本節前面所討論的。以這種方式過度使用測試替代往往也有很大的弊端，我們在本章後面會看一下。所以，在考慮是使用真實實現還是測試替身時，需要做一個權衡。

與其在測試中手動構建對象，理想的解決方案是使用生產代碼中使用的相同的對象構建代碼，如工廠方法或自動依賴注入。爲了支持測試的使用情況，對象構造代碼需要有足夠的靈活性，能夠使用測試替代，而不是硬編碼將用於生產的實現。

僞造測試

’

如果在測試中使用真實實現是不可行的，那麼最好的選擇通常是使用僞造實現。與其他測試替代技術相比，僞造測試技術更受歡迎，因爲它的行爲類似於真實實現：被測試的系統甚至不能判斷它是與真實實現交互還是與僞造實現交互。示例演示了一個僞造文件系統。

’<><>’

爲什麼僞造測試很重要？

僞造測試是一個強大的測試工具：它們可以快速執行，並允許你有效地測試代碼，而沒有使用真實實現的缺點。

一個僞造的就可以從根本上改善的測試體驗。如果將其擴展到各種的大量僞造，僞造可以極大地提高整個軟件組織的工程速度。

’

另一方面，在一個使用僞造測試很少的軟件組織中，速度會慢一些，因爲工程師最終會在使用真正實現時遇到困難，從而導致測試緩慢和不穩定。或者工程師可能會求助於其他測試替代技術，如打樁或交互測試，正如我們將在本章後面討論的那樣，這些技術可能會導致測試不清晰、脆弱且效率較低。

什麼時候應該寫僞造測試？

僞造測試需要更多的努力和更多的領域經驗來創建，因爲它需要與真實實現類似的行爲。僞造實現代碼還需要維護：當真實實現的行爲發生更改時，僞造實現代碼也必須更新以匹配此行爲。因此，擁有真實實現的團隊應該編寫並維護一個僞造實現代碼。

如果一個團隊正在考慮編寫一個僞造測試，就需要權衡使用僞造測試所帶來的生產力的提高是否超過了編寫和維護的成本。如果只有少數幾個用戶，可能不值得他們花費時間，而如果有幾百個用戶，這可以顯著提高生產率。

’’

爲了減少需要維護的僞造測試代碼的數量，僞造測試代碼通常應該只在測試中不可行的代碼根處創建。例如，如果一個數據庫不能在測試中使用，那麼應該爲數據庫本身編寫一個僞造測試，而不是爲調用數據庫的每個類編寫。

如果需要跨編程語言複製僞造實現代碼的實現，例如對於具有允許從不同語言調用服務的客戶端庫的服務，則維護僞造實現代碼可能會很麻煩。這種情況下的一個解決方案是創建一個僞造服務實現，並讓測試配置客戶端庫以向該僞造服務發送請求。與將僞造實現代碼完全寫入內存相比，這種方法更爲重要，因爲它需要測試跨進程進行通信。但是，只要測試仍然可以快速執行，那麼這是一個合理的權衡。

僞造測試的仿真度

’

也許圍繞着創建僞造測試的最重要的概念是仿真度；換句話說，僞造測試的行爲與真實實現的行爲的匹配程度。如果僞造測試的行爲與真實實現的行爲不匹配，那麼使用該僞造測試就沒有用處當使用該僞造測試時，測試可能會通過，但同樣的代碼路徑在真實實現中可能無法正常工作。

’

完美的仿真並不總是可行的。畢竟，僞造是必要的，因爲真實實現在某種程度上並不適合。例如，在硬盤存儲方面，一個僞造數據庫通常不會與真正的數據庫一樣，因爲僞造數據庫會把所有東西都存儲在內存中。

然而，主要的是，僞造測試應該保持對真實實現的契約的完整性。對於的任何給定的輸入，僞造測試應該返回相同的輸出，並對其相應的實際實現執行相同的狀態更改。例如，對於數據庫的真實實現，如果一個項目在其不存在的情況下被成功保存，但在已經存在的情況下會產生一個錯誤，僞造數據庫必須符合這個相同的行爲。

’’’’

一種思考方式是，僞造測試必須對真正的實現有完美的仿真度，但只能從測試的角度來看。例如，一個僞造不需要保證給定輸入的值與真實實現產生的值完全相同測試可能不關心具體的值，只關心給定輸入的值是唯一的。如果的契約沒有保證將返回哪些特定的值，那麼僞造函數仍然符合契約，即使它與真實實現沒有完美的仿真度。

完美的仿真度通常不適用於僞造的其他示例包括延遲和資源消耗。但是，如果你需要顯式測試這些約束（例如，驗證函數調用延遲的性能測試），則不能使用僞造函數，因此你需要求助於其他機制，例如使用真實實現而不是僞造函數。

僞造實現代碼可能不需要擁有其對應的真實實現的功能，尤其是在大多數測試不需要這種行爲的情況下（例如，罕見邊緣情況下的錯誤處理代碼）。在這種情況下，最好讓僞造測試快速失效；例如，如果執行了不受支持的代碼路徑，則引發錯誤。該故障告知工程師，在這種情況下，僞造測試是不合適的。

僞造測試應當被測試

僞造測試必須有自己的測試，以確保它符合其相應的真實實現的。沒有測試的僞造最初可能會提供真實的行爲，但如果沒有測試，隨着時間的推移，這種行爲會隨着真實實現的發展而發生變化。

’

爲僞造測試編寫測試的一種方法是針對的公共接口編寫測試，並針對真實實現和僞造測試運行這些測試（這些被稱爲合同測試）。針對真實實現運行的測試可能會更慢，但它們的缺點會被最小化，因爲它們只需要由僞造實現代碼的所有者運行。

如果沒有僞造測試怎麼辦？

如果沒有僞造測試，首先要求的所有者創建一個。所有者可能不熟悉僞造測試的概念，或者他們可能沒有意識到僞造測試對用戶的好處。

’’’

如果一個的所有者不願意或無法創建一個僞造測試，你可以寫一個。實現這一點的一種方法是將對的所有調用封裝在一個類中，然後創建一個不與對話的類的僞造測試版本。這樣做也比爲整個創建一個僞造測試簡單得多，因爲通常你只需要使用行爲的一個子集。在谷歌，一些團隊甚至將他們的僞造測試貢獻給的所有者，這使得其他團隊可以從僞造測試中獲益。

最後，你可以決定定位於使用真實實現（並處理本章前面提到的真實實現的權衡問題），或者求助於其他測試替代技術（並處理本章後面提到的權衡問題）。

’

在某些情況下，可以將僞造實現代碼視爲優化：如果使用真實實現的測試太慢，可以創建僞代碼以使它們運行得更快。但是，如果僞造實現代碼的加速比不超過創建和維護僞造實現代碼所需的工作量，那麼最好還是堅持使用真實實現。

打樁

正如本章前面所討論的，打樁是一種測試函數硬編碼行爲的方法，否則函數本身就沒有行爲。它通常是一種快速而簡單的方法來替代測試中的真實實現。例如，例中的代碼使用打樁來模擬信用卡服務器的響應。

過度使用打樁的危害

’

因爲打樁在測試中很容易應用，所以在使用真實實現不容易的情況下，使用這種技術是很誘惑力的。然而，過度使用打樁會導致需要維護這些測試的工程師的生產力的重大損失。

測試變得不清晰

’

打樁涉及編寫額外的代碼來定義被打樁的函數的行爲。額外的代碼會影響測試的意圖，如果你不熟悉被測系統的實現，這些代碼會很難理解。

’

打樁不適用於測試的一個關鍵標誌是，如果你發現自己爲了理解爲什麼測試中的某些功能是打樁的，而在思路已經躍出了被測系統。

測試變得脆弱

’’

打樁測試將你的代碼的實現細節泄露給你的測試。當生產代碼中的實現細節改變時，你需要更新你的測試以反映這些變化。理想情況下，一個好的測試應該只在面向用戶的行爲發生變化時才需要改變；它應該不受實現變化的影響。

測試有效性降低

“”

在打樁的情況下，沒有辦法確保被打樁的函數表現得像真實實現，比如像下面這個片段中的語句，硬編碼了方法的部分契約（如果傳入和，將被返回）。

’

如果被測試的系統依賴於真實實現的契約，打樁測試是一個糟糕的選擇，因爲你將被迫複製契約的細節，而且沒有辦法保證契約的正確性（即，打樁函數對真實實現的仿真度）。

此外，使用打樁測試無法存儲狀態，這會使測試代碼的某些方面變得困難。例如，如果你在一個真實實現或位置實現上調用，你可能會通過調用來檢索項目，因爲這兩個調用都是在訪問內部狀態，但在打樁測試中，沒有辦法這樣做。

一個過度使用打樁測試的例子。

例說明了一個過度使用打樁的測試。

例重寫了同樣的測試，但避免了使用打樁測試方式。注意這個測試是如何精簡的，並且在測試中沒有暴露實現細節（比如如何使用交易處理器）。不需要特別的設置，因爲信用卡服務器知道如何操作。

’’

顯然，我們不希望這樣的測試與外部信用卡服務器交互，因此更適合使用假信用卡服務器。如果一個僞造不可用，另一個選擇是使用一個真實實現，與一個封閉的信用卡服務器交互，儘管這會增加測試的執行時間。（我們將在下一章中探討封閉服務器。）

什麼情況下才適合使用打樁測試？

’

當你需要一個函數返回一個特定的值以使被測系統進入某種狀態時，打樁方式就很合適，而不是真實實現的萬能替代品，例如例要求被測系統返回一個非空的事務列表。因爲一個函數的行爲是在測試中內聯定義的，所以打樁可以模擬各種各樣的返回值或錯誤，而這些返回值或錯誤可能無法從真實實現或僞造測試中觸發。

’

爲了確保其目的明確，每個打樁函數應該與測試的斷言直接相關。因此，一個測試通常應該打樁少量的函數，因爲打樁太多會導致函數不夠清晰。一個需要打樁許多函數的測試是一個跡象，表明打樁被過度使用，或者被測系統過於複雜，應該被重構。

’’

請注意，即使打樁測試是合適的，真實實現或僞造測試仍然是首選，因爲它們不會暴露實現的細節，與打樁測試相比，它們能給你更多關於代碼的正確性的保證。但打樁可以是一種合理的技術，只要它的使用受到限制，使測試不會變得過於複雜。

交互測試

正如本章前面所討論的，交互測試是一種驗證函數如何被調用的方法，而不需要實際調用該函數的實現。

’

模擬框架使執行交互測試變得容易。然而，爲了保持測試的有用性、可讀性和應變能力，只在必要時執行交互測試是很重要的。

推薦狀態測試而非交互測試

與交互測試相比，最好是通過狀態測試來測試代碼。

通過狀態測試，你可以調用被測系統，並驗證返回的值是否正確，或者被測系統中的其他狀態是否已正確更改。示例給出了一個狀態測試示例。

’

’’

示例說明了一個類似的測試場景，但使用了交互測試。請注意，此測試無法確定數字是否實際已排序，因爲測試替代不知道如何對數字進行排序它所能告訴你的是，被測試系統嘗試對數字進行排序。

’

’

在谷歌，我們發現強調狀態測試更具可擴展性；它降低了測試的脆弱性，使得隨着時間的推移更容易變更和維護代碼。

’“”

交互測試的主要問題是它不能告訴你被測試的系統是否正常工作；它只能驗證是否按預期調用了某些函數。它要求你對代碼的行爲做出假設；例如，首選“如果”狀態測試，因爲它實際上驗證了該假設（例如，將項目保存到數據庫，然後查詢數據庫以驗證該項目是否存在）。如果調用了，則假定該項將保存到數據庫中。

交互測試的另一個缺點是，它利用被測系統的實現細節驗證某個函數是否被調用，你向測試暴露了被測系統調用這個函數。與打樁類似，這個額外的代碼使測試變得脆弱，因爲它將生產代碼的實現細節泄漏到測試中。谷歌的一些人開玩笑地把過度使用交互測試的測試稱爲變更檢測器測試，因爲它們對生產代碼的任何改變都會失敗，即使被測系統的行爲保持不變。

什麼時候適合進行交互測試？

在某些情況下，交互測試是有必要的：

你不能進行狀態測試，因爲你無法使用真實實現或僞造實現（例如，如果真實實現太慢，而且沒有僞造測試存在）。作爲備用方案，你可以進行交互測試以驗證某些函數被調用。雖然不是很理想，但這確實提供了一些基本的功能，即被測系統正在按照預期工作。對一個函數的調用數量或順序的不同會導致不在預期內的行爲。交互測試是有用的，因爲用狀態測試可能很難驗證這種行爲。例如，如果你期望一個緩存功能能減少對數據庫的調用次數，你可以驗證數據庫對象的訪問次數沒有超過預期。使用，代碼可能看起來類似於這樣：

交互測試不能完全替代狀態測試。如果無法在單元測試中執行狀態測試，請強烈考慮用更大範圍的執行狀態測試的範圍測試來補充測試套件。例如，如果你有一個單元測試，通過交互測試來驗證數據庫的使用，考慮添加一個集成測試，可以對真實數據庫進行狀態測試。更大範圍的測試是減輕風險的重要策略，我們將在下一章中討論它。

交互測試的最佳實踐

在進行交互測試時，遵循這些做法可以減少上述弊端的一些影響。

傾向於只對狀態改變的功能進行交互測試

’’

當被測系統調用一個依賴關係上的函數時，該調用屬於兩類中的一類：

改變狀態對被測系統以外的範圍有副作用的函數。例子：

不改變狀態沒有副作用的函數；它們返回關於被測系統以外的範圍的信息，不修改任何東西。例如：

。

一般來說，你應該只對狀態變化的函數進行交互測試。考慮到被測系統將使用函數的返回值來執行你可以斷言的其他工作，對非狀態變化函數執行交互測試通常是多餘的。交互本身對於正確性來說不是一個重要的細節，因爲它沒有副作用。

’

對非狀態變化的函數進行交互測試會使你的測試變得很脆弱，因爲你需要在交互模式發生變化時更新測試。由於附加的斷言使得確定哪些斷言對於確保代碼的正確性很重要變得更加困難，因此它還使得測試的可讀性降低。相比之下，狀態改變的交互代表了你的代碼爲改變其他地方的狀態所做的有用的事情。

例展示了對狀態變化和非狀態變化函數的交互測試。

例狀態改變和非狀態改變的相互作用

’

避免過度規範化

在第章中，我們將討論爲什麼測試行爲比測試方法更有用。這意味着一個測試方法應該關注於驗證一個方法或類的一個行爲，而不是試圖在一個測試中驗證多個行爲。

在進行交互測試時，我們應該通過避免過度指定哪些函數和參數被驗證，來達到應用同樣的原則。這將導致測試更清晰、更簡潔。這也導致了測試對每個測試範圍之外的行爲的改變有彈性，所以如果改變了一個函數的調用方式，更少的測試會失敗。

’

示例說明了過度規範的交互測試。測試的目的是驗證用戶名是否包含在問候語提示中，但如果不相關的行爲發生更改，測試將失敗。

例說明了交互測試在指定相關參數和函數時更加謹慎。被測試的行爲被分成獨立的測試，每個測試都驗證了確保它所測試的行爲是正確的所需的最小量。

例指向明確的交互檢驗

總結

’’

我們已經瞭解到，測試替代對工程速度至關重要，因爲它們可以幫助全面測試代碼並確保測試快速運行。另一方面，誤用它們可能是生產率的主要消耗，因爲它們可能導致測試不清楚、不可靠、效率較低。這就是爲什麼工程師瞭解如何有效應用測試替代的最佳實踐非常重要。

關於是使用真實實現還是測試替代，或者使用哪種測試替代技術，通常沒有確切的答案。工程師在爲他們的用例決定合適的方法時可能需要做出一些權衡。

儘管測試替代對於處理測試中難以使用的依賴項非常有用，但如果你想最大限度地提高代碼的可信度，在某些時候你仍然希望在測試中使用這些依賴項。下一章將介紹更大範圍的測試，對於這些測試，不管它們是否適合單元測試，都將使用這些依賴關係；例如，即使它們很慢或不確定。

內容提要

’

真實實現應優先於測試替代。如果在測試中不能使用真實實現，那麼僞造實現通常是理想的解決方案。過度使用打樁會導致測試不明確和變脆。在可能的情況下，應避免交互測試：因爲交互測試會暴露被測系統的實現細節，所以會導致測試不連貫。